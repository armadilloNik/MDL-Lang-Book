!=.
\f-
ii
The
MDL
Programming Language
S. W. C-alley and Greg Pﬁstcr
Laboratory f or Computer Science
Massachusetts Institute of Technology
Massachusetts 02139



2 The MDL Progratnrning Language
Abstract
The MDI. |tro;ramtnin; lnttgttage began existence in late i970 (under the nattte Muddle) as a
successor to l.i\|i tMnnn. i974). a ramlitlate vehicle for the Dynamic Modeling System. and a possible
base for itnplenmitzttinn of |"l;t|t|tt'r (llewitt. I969). The original design goals included an
iltlet:\\"ti\'1' ttlit't.;lalt'\i t-|t\'ir<uitnt-nt for programming. debugging. loading. and editing: ease in
learning and use: facilities for structured. tnodttlar. shared programs: extensibility of syntax. data
types amt operators: data-type checking for debugging and optional data-type declarations for
compiled eft'iriem_y; :tssnri:\li\'t' storage. coroutining. and graphics. Along the way to reaching those
goals. it tlerclopt-tl flexible input/output (including the ARPA Network). and flexible interrupt and
signal ltamlling. lt now serves as a l-nse for software prototyping. research. development. education.
and imptrmt-ut.1timt of the majority of programs at MIT-DMS: a library of sharable modules. a
coherent user interf:tt't‘. special research projects. autonomous daemons. etc.
This ttm-||mt~nt \s':\s originally intended to be a simple low-level introduction to MDL. It has.
|ln\\'t'vr't'. ntqtlitrtl .1 mse of t'lt"pl|attli:\\is and now amounts to a discursive description of the whole
interpreter. as rt-aliml in Mill. release numbers 55 (ITS version) and l05 (Tenex and Tops-20
versions). tSignifit~:t||t changes frttttt the previous edition are marked in the margin.) A low-level
intrntlneliou may still he hatl by restricting oue's attention to specially-marked sections only. The
scope of the rlntument is enufinetl as much as possible to the interpreter itself. Other adjuncts
(compiler. assetiililer. pre-lmuletl user programs. library) are mentioned as little as possible. despite
their value in prmunting the language seen by a user front "basic survival" to "comfortable living".
Indeed. -\llll cnttltl not fulfill the ahove design goals without the compiler. assembler. structure
editor. cmttrnl-stark printer. context printer. pretty-printer. dynamic loader. and library system - all
of which are not part of the interpreter but programs written in MDL and symbiotic with one
another. Further infnrtnation on these adjuncts can be found in Lebling's (i979) document.
XE‘! KJRDS: HDL
lhddle
Programming Languages
(c) Copyright H179 Massacltusetts institute of Technology. All rights reserved.



The MDL Programming Language 3
Acknowledgements
I was not a tttetttber of the original group which labored for two years in the design and initial
impletnetttation of Mttddle: that group was composed principally of Gerald Susstnan. Carl Hewitt.
Chris Reeve. Dave Crcssey. and later Bruce Daniels. I would therefore like to take this opportunity
to thank my Mttdtlle mentors. chiefly Chris Reeve and Bruce Daniels. for remaining civil through
several tttntttlts of verbal badgering. l believe that I learned tnore than ‘just another programming
language" in learning Mttddle. and I atn grateful for this opportunity to pass on sotne of that
knowledge. What I cannot pass on is the knowledge gained by using Muddle as a system: that I can
only ask you to share.
For editing the contettt of this document and correcting sotne misconceptions. I would like to thank
Chris Reeve. Bruce Daniels and especially Gerald Sussman. one of whose good ideas I finally did use.
Greg Pfister
December l5. I972
Since Greg left the fold. I have taken up the banner and updated his document. The main sources
for small revisions have been the on-line file of changes to MDL. for which credit goes to Neal
Ryan as well as Reeve and Daniels. attd the set of on-line abstracts for interpreter Subroutittes,
contributed by ttnttantetl members of the Prograttttttittg Technology Division. Sotne new sections
were written almost entirely by others: Dave Lebling wrote chapter 14 and appendix 3. jim Michener
section 14.3. Reeve chapter l9 and appendix I. Daniels and Reeve appendix 2. Brian Berkowitz
section 22.7. Tak To sectinn l7.2.2. and Ryan section l7.l.3. Sue Pitkin did the tedious task
of marking phrases in the manuscript for indexing. Pitts jarvis and jack Haverty advised on the
use of PUB and the XGP. Matty PTD people commented helpfully on a draft version.
My task ltas been to impose some uniformity attd structure on these diverse sources (so that the
result sounds less like a dozen hackers typing at a dozen terminals for a dozen days) and to enjoy
some of the richness of MDL frottt the inside. I especially thank Chris Reeve (“the oracle") for the
patience to answer questions and resolve doubts. as he no doubt has done ittnumerable times before.
S. W. Galley
May 23. I979
This work was supported by the Advanced Research Projects Agency of the Department of Defense
and was tnomtored by the Office of Naval Research under cotttract N000l4-75-C-0561.
':"|;islrdoctttttettt was prepared using the PUB systetn (originally from the Stanford Artificial
he tgettce Laboratory) and printed on the Xerox Graphics Printer of the M.I.T. Artificial
Intelligence Laboratory.



4 The MDL Programming Language
Foreword
Trying to explain MDL to an uninitiate is somewhat like trying to untie a Gordian knot. Whatever
topic one chnmes to discuss first. full discttssion of it appears to imply discussion of everything
else. What follows is a discursive presentation of MDL in an order apparently requiring the fewest
forward references. lt is not perfect iu that regard: however. if you are patient and willing to
accept a few. stated things as "magic" until they can be explained better. you will probably not have
too many prnbletns understanding what is going on.
There are no "practice problems": you arc assumed to be learning MDL for sotne purpose. and your
work in arltieving that purpose will be tuore useful and motivated than artificial problems. in
several cases. the examples contain illustrations of important points which are not covered in the
text. Ignore examples at your peril.
This doruutent does not assume knowledge of any specific programming language on the your part.
However. "cotnputational literacy" is assumed: you should have written at least one program before.
Also. very little familiarity is assumed with the interactive time-sharing operating systems under
which MDL rnus -- ITS. Teuex. and Tops-20 -- namely just file and user naming conventions.
Notation:
Sections marked [l] are recommended for an uuiuitiate's first reading. in lieu of a separate
introduction or primer for MDL. [On first reading. text within brackets like these should be
ignored.)
Most specifically itttlicated examples herein are composed of pairs of lines. The first line of a pair.
the input. always entls in S (which is ltow the ASCII character ESC is represented. and which always
represents itl. The second line is the result of MDL's groveling over the first. lf you were to type
all the first lines at MDL. it would respond with all the second lines. (More exactly. the "first line‘
is one or utore objects in MDL followed by S. and the ‘second line‘ is everything up to the next
"first liue".l
Anything which is tvritten in the MDL language or which is typed on a computer tertninal appears
herein in a gotltic font. as in ROOT. A tnetasyntactic variable - something to be replaced in actual
use by something else -- appears as radhslirr. in an italic font: often the variable will have both a
meaning and a data type (as hercl. but sometimes one of those will be omitted. for obvious reasons.
An ellipsis (...) intlicates that something uninteresting has been omitted. The character ’“ means
that the following character is to be 'coutrollified': it is usually typed by holding down a terminal's
CTRL key and striking the other key.




1 I
I
The MDL Prngraunming Language 5
List of Chapters
Page Nann-
l6 I. Basic Interaction
I 20 '1. Rrml. Evalualc. and Print
27 3. Iluilt-in Fnnrlions
30 <1. \’alue\ of Amlns
35 5. Simplr I-‘unctinus
43 6. I).1|.1 'I'}'p<~s
52 7. Slruclurvd Ohjccls
7| 8. Trulh
78 9. I-'unc.|inns
89 I0. Ixwnping
98 II. Input/Oul|u|I
IIG I2. Lnvalivcs
‘ I20 I3. A*\ﬂ\‘i.=\Ii0Il Wropcrlic‘)
I24 I-I, Dam-I)‘p<' Dvrlaralinns
I38 I5. Lﬂical Rlr-rkillg
I I-16 I6. lirrﬂrs. I-'ra|n("». clc.
I I52 I7. .\I.1rrv\-n|1<~ra!in||s
I I59 I8. |'\I.-n-h|m~ Wards and Bits
f I63 I9. COI\lpiIf‘(I Prognnus
I69 20. (Inn:-ulim~s
I77 ‘ll. lmrrnupls
I92 22. Smmgv Mnuagcment
20! 25. MDL as a Sysxem Process
204 24. Efficiency and Tam-fulness
r
I
I
I
4
 



—
G
Page Seclinn
I6
I6
I6
I8
I8
20
20
20
2|
2‘!
2'2
22
‘Z2
23
24
‘24
24
25
26
27
27
27
28
28
29
30
30
30
30
3|
31
32
32
Tl
3').
33
33
C|i.1|ner l. Basic liilcrnclioii
Ll Lnnding MDL [I]
l.'2 Typing [I]
L3 Lnailing n File [l]
l.-l Ermrs -- Simple Consideralions [l]
List of Sections
Cllaplrr 2. Road. F.\‘3|\li\lE. and Prinl
Z!
‘Z
'2
2
'2
Clmpic-r ‘J. lluill-in Flmclinils
l ('-vm'r.1l[l]
‘Z I'l|ilmr\pl|)‘ (lYPEsl [l]
2.3 I-l\.1mplc (TYPE FIX) [l]
-I F\.1|npl¢ (TYPE FLOM] [I]
5 F.\:\mpIe(lYPF /non, PNAHEHI]
6 F 1X1-s, l'LOA1s. and ATOM» versus READ: Specifics
2.fv.l READ and FIX(‘(kpninl Numbers
2.6.2 RPM‘! and PRINT versus FLOA‘l‘i|\g-point Numbers
2.6.3 Rlﬂl) and l‘NI\HEs
2.6.3.1 Non-l‘llAHEs
2.6.3.2 lixamplrs
‘.’_.(i.3..'l \ (llaekslashl in ATOM!»
2.6.3.-1 liminples of Awful ATOHs
‘ll Rcpr(*sr'|n:|tin|| [l]
3.2 E\'aIu.1iim| [l]
3.3 lluill-in Fmicliniis (TYPE SUBR. TYPE FSUBR) [1]
3.4 F.n.nnplcs (+ and FIX; Arithmetic) [I]
3.5 /\ri|lnnr>|ic: Details
Clinplcr -I. \".\lucs of Atoms
-1.l Ccncr.1l[l]
-L2 Global Values
-1.2.1 sns [11
4.2-.>. GVAL [11
<l.',‘_.3 Nnio rm SUBRs and FSUBRs
-I 2.1 (=UNI\SSIGN
4.3 Lncal Values
-l.3.l srr [1]
~|.:*.~1 {VAL [11
-1.3.11 uunsslcu
4.-l VALUE
List of Sections
The MDL Programming Language



The MDL Programming Language
35
35
35
36
$9
40
Chapter 5. Sintplc Functions
5.l Ccncral [l)
5.2 Representation [I]
5.3 Application of FUNCTIONs: Binding [I]
5.4 Defining FUNCT10Ns (FUNCTION and DEFINE) ll]
5.5 Exantples (Comments) [l]
43
43
43
44
44
44
45
45
46
46
46
45
48
Chapter 6. Data Types
6.l General [I]
6.2 Primed Representation [l]
6.3 SUBR\ Related to TYPEs
6.3.1 TYPE [t1
6.3.2 PRIMTYPE [ll
6.3.: TYPEPRIH [I]
6.3.4 CHTYPE [I]
6.4 Mnrc SUBRs Related to TYPEs
6.4.l ALLTYPES
6.4.2 VALID-TYPE?
6.4.3 NEVTYPE
6.4.4 PRINTTYPE. EVALTYPE and APPLYTYPE
52
52
52
52
Chapter 7. Structured Objects
7.l Manipulation
7.|.| LENGTH [11
7.l.2 NIH [I]
52 7.1.3 nest [1]
53 7.l.4 PUT [I]
53 7.l.5 GET
53 7.1.0 /\Pl‘LYlng a FIX [11
54 7.l.7 SUBSTRUC
54 7.2 Representation of Basic Structures
54 7.2.l LIST [I]
54 7.2.2 VECTOR [I]
54 7.2.3 UVECTOR [l]
55 7.2.4 STRING [l]
55 7.2.5 BYTES
55 7.2.6 IEHPLATE
55 7.3 Evaluation of Basic Structures [l]
55 7.4 Examples [I]
56 7.5 Generation of Basic Structures
56 7.5.l Direct Representation [l]
ss 7.5.2 QUOTE [I]
57 7.5.3 LIST, VECTOR, UVECTOR. and STRING (llle SUBFB) [1]
57 7.5.4 ILIS'l , IVECTOR, IUVECTOR, and ISTRING [1]
58 7.5.5 FORM and IFORH
List of Sections



8 The MDL Programming Language IE
59 7.6 Unique Properties of Primitive 'I'YPEs
59 7.6.I LIST (thc PRIHTYPEI [I]
59 7.6.I.I PUTREST [I]
59 7.6.1.2 CONS
60 7.6.2 "Array" PRIHTYPEs [I1
60 7.6.'Z.I BACK [I]
60 7.6.2.2 TOP [I]
60 7.6.3 "Vector' PR1HTYPEs
60 7.6.3.I GROW
6I 7.6.3.2 SORT
63 7.6.-1 VECTOR (the PRIHTYPEI [I]
63 7.6.5 UVEC'IOR (Ihe PRIHTYPE) [I]
63 7.6.5.I UTYPE [I]
64 7.6.5.2 CIIUTYPE [I]
64 7.6.6 STRING (the PRIHTYPE) and CHARACTER [I]
65 7.6.6.1 ASCII [I]
65 7.6.6.2 PARSE [I]
65 7.6.6.3 LPARSE [I]
65 7.6.6.-I UNPARSE [I]
65 7.6.7 BYTES
G6 7.6.8 TEMPLATE
as 7.1 sssmtrm [11
66 7.7.I Represenuttiou [I]
67 7.7.2 Evaluation [I]
67 7.7.3 Examplcs [I]
68 7.7.4 Note on Efficiency [I]
69 7.7.5 SEGHENTs in FORHs [I]
69 7.8 Self-rcferencing Structures
69 7.8.! Self-subset
70 7.8.2 Self-element
7I Chapter 8. Truth
7| B.I Truth Values [I]
7I 8.2 Predicates [I]
7I 8.2.1 Arithmetic [I]
72 8.2.2 Equality and Membership [I]
73 8.2.3 Bnnlean Operators [I]
74 8.2.4 Object Properties [I]
75 8.3 COND [I]
75 8.3.l Examples [I]
76 8.4 Shortcuts with Conditionais
76 8.4.1 AND and OR as Short CONDs
77 8.4.2 Embedded Unconditional:
78 Chapter 9. Functions
List of Sections



-E-»——~—
The MDL Prngnunlnlillg Language 9
78 ‘ll "OPT lONI\L" [I]
79 9.? TUT‘LEs
79 9.2.1 "TUI‘LE" and TUPLE (Ille TYPE) [1]
30 9.2.2 TUI'l E (1110 SUBRJ and ITUPLE
8| 9.3 "NIX" [I]
82 9.4 OUOTEd arglllnenls
82 9.5 "ARCS"
83 9.6 "CA|.\."
83 9.7 FVAL and "BIND"
34 917.l Lncnl \'aIll('s versus EHVZRONHENB
34 9.3 ACTIVATION, "NAME", "ACT", AGAIN, llld RETURN [I]
86 9.9 1\rg11|11r111 List Summary
83 fllﬁ AFN Y [I]
‘ 88 91ll CLOSURE
‘ 89 Chaplet I0. Irmping
59 l0.l FROG and REPEAT [I]
89 l0.l.l “mic EVI\L11alinn [I]
90 l0.|.‘.¥ AGAIN and RETURN ill PROG and REPEAT [I]
90 l0.l.3 F\:.1|11pl('<[l]
‘J1 I032 HAPF and MAPR: Basics [I]
92 l0.‘.!.l HAN" [I]
9'1 l0.?..'.l HI\T‘R [I]
92 10.2.3 F.x:ullplP.\ [I]
94 l0.fi Mnrc 011 HAPF and HAPR
94 l0.3.l HAPRCT
95 I011 HAPSTOP
95 l0.3.3 HI\T‘l.l'_/\VE
‘ 95 l0.3.-I Only lwo argu|11c111.s
95 l0.f7.5 STACKFORH
95 |O.'l GO and T/KG
97 l0.5 Lnnping versus Recursion
98 Cluaplcr II. lnpullO111pul
1 98 Il.l (inluvrrsinla I/O
‘ 93 lI.l.l lnpul
99 ll.l H READ
99 ll.l L17. RE/\DCIlR
99 lI.l.l.3 NUUCHR
99 ll.l.'Z Oulpul
99 ll.l.'2.l PRINT
99 |l.l.?.9. PRINT
I00 ll.l.‘Z.3 PRINC
loo ll.l.'Z.-I TERPRT
I00 11.1.2.5 our
List of Sections



I0
I00
I0]
I0!
I0‘!
I02
I03
I03
I03
I03
I04
I0-I
I05
I05
I06
I00
I06
I05
I00
I06
I06
I07
I07
I07
I07
I08
I08
I09
I09
I09
IIO
IIO
lI0
IIO
III
III
III
III
lI2
IIS
II3
II3
II3
II4
II5
IIS
II.I.'2.6 FLAISIZE
IL2 cu/mnrl (rm TYPE)
Il.2.l OPEN
ll.‘2.2 OPEN-NR
ll.2.3 CIIAHNEL (tho SUBR)
II.?..'l F IU;-EXISIS?
Il.'2.5 CLOSE
II.'Z.G CIIANLISI
Il.T!.7 IIICIIAN and OUICIIAN
Il.2.3 (Inmems of C!lI\NNELs
ll't48J Oulpm CHANNEL:
II.2.8.2 Inpul CllANNELs
ll.3 Fml-nf-File "Routine"
lI.'I Iinnged IIO
II.-I.I Input
ll.4.l.l REA08
ll.~I.L2 READSIRING
II.-1.2 Output
II.~I.‘Z.I PRIIITB
Il.¢I.‘Z.2 PRINTSTRING
lI.»I.§7._3 IHAGF
II.5 Dmnprd IIO
II.5.l Output: GC—DUHP
II.5.‘.'! Input: SC-READ
II.G 5I\VI': Files
Il.G.l SAVE
II.5.‘.Z RESTORE
IL? Oilwr I10 Functions
Il.7,I IOI\D
II.7.‘2 FLOAD
|I.7.3 SIIMIE
II.7_-I ACCESS
II.7.5 F ILE-LENGTH
II.7.G F ILECOPY
Il.7.7 RESEI
II.7.S Blll OUI
II.T.'J RE IIIINE
IL8 Tcnuilml CHI\HNELs
II.S.I IICIIOPAIR
II.B.‘Z I IYHIIIO
II.8.3 IYI
ll.9 IlIl(‘l'||:lI CllANNELs
Il.l0 The ‘NET’ Device: the ARPA Network
II.I0.I NEISIAIE
II.I0.2 NETACC
List of Sections
The MDL Programming Language
5
1
1
1



The MDL Programming Language ll
us u.|o.s nets
IIG Chapter l2. Locatives
[I6 l2.l Obtaining Locatives
H6 l2.l.I LLOC
II7 l2.l.2 GLOC
II7 l2.l.3 AT
II7 l2.I.-1 GETPL and GETL
117 I22 LOCATIVE?
II8 l2.3 Using Locativcs
H8 |2.3.t IN
H8 l2.3.2 SETLOC
H9 12.4 Note on Locatives
I20 Chapter I3. Association (Properties)
I20 13.1 Associative Storage
I20 I3.l.l PUTPROP
I20 I3.l.7. PUT
= I20 l3.l.3 Removing Associations
* l2l l$.2 Associative Retrieval
IZI l3.2.l GETPROP
l2I I32/Z GET
l2l t3.3 Examples of Association
123 l3.4 Examining Associations
I24 Chapter M. Data-type Declarations
I25 l-1.1 Patterns
I28 l4.2 Exaniplcs
130 I-1.3 The DECL Syntax
I3] I-L4 Good l)ECLs
I31 l4.5 Global 0ECLs
‘ ISI l4.5.l GDECL and HANIFEST
I32 I-1.5.2 HANIFEST? and UNHANIFEST
I32 14.5.3 GBOUND?
13$ 14.6 nsunrre (again)
t I34 l4.7 Controlling DECL Checking
‘ 134 |4.7.| osct-cnzcx
E I34 H.7.2 SPECIAL-CHECK and SPECIAL-MODE
i I34 14.7.3 GET-DECL and PUT-DECL
. 135 14.7.4 DECL?
‘ I35 14.8 orrssr
J l36 14.9 The RSUBR DECL
I38 Chapter I5. Lvxical Blocking
I I38 l5.l Basic Considerations
List of Sections



15.2 0BLIS1s
15.2.1 OBLIST Names
15.2.2 HOBLIST
15.2.3 O8L1ST?
15.3 READ and 0BLISTs
15.-1 PRINT and 0BLISTs
l5.S1ni1ialS1alc
15.6 BLOCK and ENDBLOCK
15.7 SUBRs Associated with Lexical Blocking
15.7.1 READ (again)
15.7.2 PARSE and LPARSE (again)
15.7.3 LOOKUP
15.7.4 ATOH
15.7.5 REMOVE
15.7.6 INSERT
15.7.7 PNAHE
15.7.8 SPNAHE
15.8 Examplcz Another Solu
Chapler 16. Errors. Frames. etc.
16.1 LISTEN
16.2 ERROR
15.3 FRAME (1112 TYPE)
16.3.1 ARGS
16.3.2 FUNCT
16.3.3 FRAME (the SUBR)
16.3.-1 Examples
16.-1 ERRET
16.5 RETRY
16.6 UNVIND
16.7 Comrol~C (*8)
16.8 Con1ro1~S (*5)
16.9 OVERFLOV
Chapier 17. Macro-operations
17.1 READ Macros
17.1.1 ‘I. and 71%
17.1.2 LINK
1i0n 10 the INC Problem
17.1.3 Program-defined Macro-characters
17.1.3.1 READ (finally)
17.1.3.2 Examples
17.1.5.3 PARSE and LPARSE (finally)
17.2 EVAL Macros
17.2.1 DEFHAC and EXPAND
17.2.2 Example
List of Sections
The MDL Programming Language
1"
1
1



The MDL Programming Language I5
I59 Chapter I8. Machine Words and Bits
I59 I8.l IIORIB
I60 I8.2 BITS
‘ I60 I8.3 GEIBITS
I l6I ISA PUTBIT5
‘ IGI l8.5 Bilwise Boolean Operations
I62 I8.6 Bilwise Shifting Operations
I63 Chaplor I9. Compiled Programs
I63 I9.I RSUBR (the TYPE)
I63 I92 The Reference Vector
I64 I93 RSUBR Linking
I64 I9.-I Pure and Impure Code
I65 I9.5 TYPE-C and TYPE-U
' ass 19.6 asunn (the suan)
I I66 I0.7 RSUUR-ENTRY
I66 I0.8 RSUBR§ in Files
I67 I9.9 Fixups
I69 Chapter 20. Cornulincs
I69 20.1 PROCESS (lhe TYPE)
I70 20.2 STATE of a PROCESS
I no 20.: rnocess (llue susm
' I70 20.4 RESUME
. I7| 20.5 Switrliillg PROCESSes
I7I 20.5.1 Slarling Up a New PROCESS
I7l 20.5.2 Top-Icvel Return
I72 20.5.3 Symmetric RESUHEing
I73 20.6 Example
I73 20.7 Other Coroutiuing Features
‘ I73 20.7.1 BREAK-SEQ
I74 20.7.2 MAIN
I I74 20.7.3 ME
I I74 20.7.4 RESUHER
I74 20.7.5 SUICIDE
I75 20.7.6 ISTEP
I75 20.7.7 FREE-RUN
I75 20.8 Sm-aki||css with PROCES$es
I76 20.9 Final Notes
1
I77 Chapler 2|. Inlerrupls
I77 2l.I Definitions of Terms
I78 21.2 EVENT
179 21.3 HANDLER (the SUBR)
. I79 2l.-I OFF
List of Sections



I4 The MDL Programming Language
I80 2l.5 IHEADER and HANDLER (the TYPEs)
I80 2l.5.l IIIEADER
ISI 2I.5.2 HANDLER
I8I 2I.6 Other SUBRs
182 21.7 Priorities and Interrupt Levels
I82 2l.7.t Interrupt Processing
I83 2l.7.2 INT-LEVEL .
I33 2I.7.3 DISHISS I
I8-1 2l.8 Specific Interrupts
I84 2l.8.l ‘CHAR’ received
I85 2I.8.2 'CHIlR" wanted
I85 2l.8.3 ‘CHAR’ for new line
I85 2I.8.4 "GC"
I86 21.8.5 ‘DIVERT-ABC‘
I87 2l.8.6 'CLOCK‘
I87 2I.8.7 'BLOCKED'
I87 2I.8.8 "UNBLOCKED'
I87 2l.8.9 ‘READ’ and ‘WRITE’
I88 2l.8.I0 'SYS00\JN'
I88 2I.8.II ‘ERROR’
I89 ‘2l.8.l2 "IPC'
I89 2I.8.I3 ‘INFERIOR’
I89 2I.8.I4 "RUN'I' and "REALT"
I89 21.8.15 "Dangerous" Interrupts
I90 21.9 Uscr-Defined Interrupts (INTERRUPT)
I9I 2l.l0 Wailing for Interrupts
I9I 2I.I0.I HANG
I91 2I.I0.2 SLEEP
I92 Chapter 22. Storage Management
I92 22.l Movable Garbage-collected Storage
I93 22.l.l Stacks and Other Internal Vectors
I94 22.2 Immovable Storage
I94 22.2.l Garbage-collected: FREEZE
I94 22.2.2 Non-garbage-collected: STORAGE (the PRIHIYPE)
I94 22.3 OIIICI Storage
I95 22.4 Garbage Collection: Details
I95 22.5 EC
I95 22.6 BLOAT
I98 22.7 BLOAT-SIM’
I99 22.8 GC-HON
I99 22.9 Related Subroutines
I99 22.9.1 SUBSTITUTE
I99 22.9.2 PURIFY
List of Sections



l
20!
'20l
201
20?
20:2
202
203
203
203
‘ 203
20»!
20-I
205
‘Z07
208
203
208
209
209
21]
225
258
260
265
266
267
27l
>
The MDL Prngrainining Language
Cllnpior 122. l\lDL as a Syslem Process
‘Ill llflh
23.2 Names
23.3 lixiu
‘Z3 -l Imrr-process Communication
'.Z3.'l.l SEND and SEND-WAIT
23.-l.'2 The "1PC' Interrupt
23.4.3 Il"C~OFF
23‘-I.'l ll'C-ON
23.4.5 DEHSIG
Chaplrr ‘H. Fffiricncy and Tastefulness
2-l.l Fffiriency
2~l.l_| Exzunple
‘Z-L12 (Inc.-uing a LIST in Forward Order
2! L’; Rmrl-only Free Variables
2-l.-l Glnhal and Local Values
'2-L5 M.1l.ing Offsels for Arrays
'2-LG Tables
24.7 Ncsliug
Appendix l. A Look Inside
Appcnrliw '2' Predefined Subroutines
Appendix 3. Predefined Types
Appendix '1. Error Messages
Appendix 5. Initial Senings
References
Topic Index
Name Index
List of Sections



u’-1
I6 The MDL Programming Language
Chapter 1. Basic Interaction
The pltrpnsr of this rliaptrr is to provide you with that tninintal amount of information needed to
experiment with i\lDl. while reading this document. lt is strongly recommended that you do
experiment. especially npon reaching chapter 5 (Simple Functions).
l.l. Loading MQL l|
First. catch your rnlihit. Soul:-linw get the interpreter running - the program in the file SYS:TS MDL
in the ITS \'€f!~l¢'IIl or SYS:HDL.S/\V in the Tenex version or SYS:HDL.EXE in the Tops-20 version.
The itnt-rptctcr will first l)'p(' out smne news relating to MDL. if arty. then type
l.ISlEN1llG-M-LEVEL l PROCESS 1
and then wait for you to type something.
The progratn which you are now running is an interpreter for the language MDL. Q it knows how
to do is intcrprct l\lDl. expressions. There is no special 'comtnand language": you cotntnunicate
with tho prngrani -- ntakc it do things for yon -- by actually typing legal MDL expressions. which it
then intcrprets. 1'-‘vrrytliittgt you can dn at a terminal catt he done itt a program. and vice versa. in
exactly the saute way.
The program will he referred to as just "MDL" (or "the interpreter") from here on. There is no
antbignity, since lltc program is just an incarnation of the concept "MDL'.
l.2. T1p_itt_g_[l1
Typing a cliaractcr at MDL normally just causes that character to be echoed (primed on your
terminal) atttl r('tttt‘tttbt't't‘tl in a bttlfcr. The only characters for which this is normally not true act
35 fO|lﬂ\vs:
Typing S (li<&Cl causes MDL to echo dollansign and causes the contents of the buffer (the characters
l - 1.2 Basic interaction
I
l
l
i



The MDL Progrannning Language l7
which you've typed) to be interpreted as an expression(s) in MDL. When this interpretation is done.
the result will be printed and MDL will wait for more typing. ESC will be represented by the glyph
8 in this document.
Typing the rubnnt character (DEL itt the ITS and Tops-20 versions. control-A in the Tenex version)
causes tlte last character itt the buffer -- the one tnost recently typed - to be thrown away (deleted).
lf you now itnntediately type attother ruliout. once again the last character is deleted -- namely. the
second most recently typed. Etc. The character deleted is echoed. so you can see what you're doing.
On some "display" terminals. rnbout will "echo" by causing the deleted character to disappear. If no
characters are in the buffer. rubout echoes as carriage-return line-feed.
Typing "@ (control-atsign) deletes everything you have typed since the last S, and prints a carriage-
return line-feed.
Typing ‘D (control-D) causes the current input buffer to be typed back out at you. This allows you
to see what you really have. without the confusing re-echoed characters produced by rubout.
Typing "L (control-Ll produces the same effect as typing ‘D, except that. if your terminal is a
"display" terntiual (for example. IMLAC. ARDS. Datapoint). it first clears the screett.
Typing “G (control-C) causes MDL to stop whatever it is doing and act as if an error had occurred
(section 1.4). ‘G is generally tttost useful for temporary interruptions to check the progress of a
computation. “G is "reversible" -~ that is. it does not destroy any of the "state" of the computation it
interrupts. To "undo" a "G, type the characters
(ERRET T>$
(This is discussed more fully far below. in section l6.4.)
Typing “S (control-S) causes MDL to throw lay what it is currently doing and return to a normal
"listening" state. (ln the Tenex and Tops-20 versions. “O also should have the satne effect.) “S is
generally tttost useful for aborting infinite loops and similar terrible things. “S destroys whatever
is going on. and so it is E reversible.
Most expressions itt MDL include “brackets” (generically meant) that must be correctly paired and
nested. lf you end your typing with the pair of characters !$ (exclamation-point ESC). all currently
unpaired bracLets (hut not double»quotcs. which bracket strings of characters) will automatically be
paired and interpretation will start. Without the !. MDL will just sit there waiting for you to pair
thent. If you have improperly nested parentheses. brackets. etc.. within the expression you typed. an
error will occur. and MDL will tell you what is wrong.
Once the brackets are properly paired. MDL will immediately echo carriage-return and line-feed. and
the next thing it prints will be the result of the evaluation. Thus. if a plain S is not so echoed. you
1.2 Basic Interaction



I8 The MDL Programming Language
have some cxpressiott ttnclosed. ln that case. if you have not typed any characters beyond the S,
you can usually rub nnt the $ and other characters back to the beginning of the unclosed expression.
Otherwise. what yon have typed is beyond the help of rubout and *0; if you want to abort it. use
‘S
MDL accepts and distinguisltes between upper and lower case. All ‘built-in functions“ must be
referenced in upper case.
1.3. Loading a File |l[
If you have a program in MDL that you have written as an ASCII file on some device. you can
‘load’ it by typing
< F LOAD Ii/e>$
where hie is the name of the file. in standard operating-system syntax. enclosed in "s (double-
quotes). Otnitted parts of the file name are talten by default frotn the ﬁle name "DSk: INPUT >‘
(in the ITS version) or "DSK: IHPUT.HUD" (in the Tenex and Tops-20 versions) in the current disk
directory.
Once you type S. MDL will process the text in the file (including FLOADs) exactly as if you had
typed it on a terminal and followed it with S, except that 'vaIues' produced by the computations
are not printed. When MDL is finished processing the file. it will print ‘DONE’.
When MDL starts rtmning. it will FLOAD the file ‘HUDDLE INIT' (ITS version) or “HUDDLE.INIT"
(Tenex and Tops-20 versions). if it exists.
l.4. Errors ~- Simple Considerations l[
Whett MDL decides for some reason that something is wrong. the standard sequence of evaluation is
interrupted and an error function is called. This produces the following terminal output:
' E R ROR*
ofIen—h yphenated-reason
funch'on-m- which-error-O€CUr!ed
L I S T E N I NG -AT- LEVE L integer PROCESS integer
You can now interact with MDL as usual. typing expressions and having them evaluated. There
exist facilities (built-in functions) allowing you to find out what went wrong. restart. or abandon
whatever was going on. ln particular. you can recover from an error - that is, undo everything but
l.2 - l.4 Basic Interaction



w Tltc MDL Progratnnting Language 19
3‘ side effects and return In the initial typing phase - by typing the following first line. to which
1 MDL will rcspond with the second lino:
<EliRE l>$
' t LISTENING-AT-LEVEL l PROCESS 1
If you lypr the‘ fnllmving first line while still in the error stale (before <ERRET>). MDL will print. as
shown. the :irgumt~nts (or 'par:mleters" or "inputs" or "independent variables") which gave
indigesliun to tho unhappy function:
(ARES (FRAME (FRAHE)>>S
[ mg;-r-:cnIs I0 unhappy Iundion ]
1 This will bc rn\'plaincd by and by.
i
I
I
1.4 Basic Interaction
 



=-—
20 The MDL Programming Language
Chapter 2. Read, Evaluate, and Print
2.l. General Ll]
Once you type S and all brackets are correctly paired and nested. the current contents of the input
buffer go through prncvssittg by three functions successively: first READ, which passes its output to
EVAL ("evaluate"). which passes its output to PRINT, whose output is typed on the terminal.
[Actually. the sequence is more like READ, CRLF. EVAL, PRINI, CRLF (explained in chapter ll);
MDL gives you a rarri.1ge~return line-feed wlten the READ is complete. that is. when all brackets are
paired.]
Functionally.
READ: printable representations --> MDL objects
EVAL: MDL objects ~-> MDL objects
PRINT: MDL objects --> printable representations
That is. READ takes ASCII text. such as is typed in at a terminal. and creates the MDL objects
represented by that teat. PRINT takes MDL objects. creates ASCll text representations of them. and
types thetn out. EVAL, which is the really itnportattt one. performs transformations on MDL
objects.
2.2. Pltilnsnplty 4TYP[sl Lu
ltt a general sense. when you are interacting with MDL. you are dealing with a world inhabited only
by a particular set of objects: MDL objects.
MDL objects are best considered as abstract entities with abstract properties. The properties of a
particular MDL object depend ttpott tlte class of MDL objects to which it belongs. This class is the
2 - 2-7 Read. Evaluate. and Print



The MDL Programming Language 21
TYPE of the MDL object. Every MDL object has a TYPE. and every TYPE has its own peculiarities.
There are litany different TYPEs in MDL: they will gradually be introduced below. but in the
meantime here is a representative sample: SUBR (the TYPE of READ, EVAL and PRINT). FSUBR, LIST,
VECTOR, FORH. FUNCTION, etc. Since every object has a TYPE, one often abbreviates ‘an object of
TYPE type” by saying "a type". -
The laws of the MDL world are defined by EVAL. In a very real sense. EVAL is the only MDL object
which "acts". which "does something". ln "acting". EVAL is always ‘following the directions‘ of some
MDL object. Every MDL object should be looked upon as supplying a set of directions to EVAL;
what these directions are depends heavily on the TYPE of the MDL object.
Since EVAL is so ever-prt-sent. an abbreviation is in order: ‘evaluates to something‘ or "EVALs to
sameflti/15" shmtld be talten as an abbreviation for ‘when given to EVAL, causes EVAL to return
something".
As abstract entities. MDL objects are. of course. not "visible". There is. however. a standard way of
representing abstract MDL objects in the real world. The standard way of representing any given
TYPE of MDL object will be given below when the TYPE is introduced. These standard
representations are what READ understands. and what PRINT produces.
2.3. Example §TYPE l-‘IQ [I]
15
1
The following has occurred:
First. READ recognized the character 1 as the representation for an object of TYPE FIX, in particular
the one which corresponds to the integer one. (FIX means integer, because the decimal point is
understood :tlw:tys to be in a fixed position: at the right-hand end.) READ built the MDL object
corresponding to the decitnal representation typed. and returned it.
Then EVAL noted that its input was of TYPE FIX. An object of TYPE FIX evaluates to itself. so
EVAL returned its inpttt undisturbed.
Then PRINT saw that its input was of TYPE FIX, and printed on the terminal the decimal character
representation of the corresponding integer.
2.2 - 2.3 Read. Evaluate. and Print



III" K
22 The MDL Programming Language
2.4. Exatngle (TYPE FLOAT} [I1
1.05
1.0
What went on was entirely analogous to the preceding example. except that the MDL object was of
TYPE FLOAT. (FLOAT ineans a real number (of litnited precision), because the decimal point can float
around to any convenient position: an internal exponent part tells where it “really” belongs.)
2.5. Exantgle (TYPE ATOH, PNAP'lE[ Ill
GEORGES
GEORGE
This time a lot more happened.
READ noted that what was typed had no special meaning, and therefore assumed that it was the
representation of an identifier. that is. an object of TYPE ATOM. ('Atom" means more or less
indivisible.) READ therefore attempted to look up the representation itt a table it keeps for such
purposes [:t lIST of O8LISTs. available as the local value of the ATOM OBLISTJ. lf READ finds an
ATOM in its table corresponding to tlte representation. that ATOM is returned as READ's value. If READ
fails in looking ttp. it creates a new ATOM, puts it itt tlte table with the representation read [INSERT
into <1 .Ol'tLIST> usually]. and returns the new ATOM. Nothing which could in any way be
referenced as a legal "value' is attached to the new ATOM. The initially-typed representation of an
ATOM becomes its PHAHE. meanittg its natne for PRINT. One often abbreviates 'object of TYPE AT!!!
with PNAME name“ by saying "ATOM name’.
EVAL, given an ATOM, returned just that ATOM.
PRINT, given an ATOM. typed out its PNAME.
At the end of this chapter. the question "what is a legal PNAME' will be considered. Further on. the
methods used to attach values to ATOHs will be described.
2.6. FIXes. FLOATs. and ATOMs versus READ: Specifics
2.6.1. READ and FIXed-point Numbers
READ considers any grouping of characters which are solely digits to be a FIX, and the radix of the
2.4 - 2.61 Read, Evaluate. and Print



f
.8
Z§ll-IUSIUII
tl
l
i
l
t
t
l
The MDL Progratnnting Language 23
represeltlatimt is decimal by default. A - (hyphen) immediately preceding such a grouping
represents a |tet_.;ative FIX. The largest FIX representable on the PDP-10 is two to the 35th power
minus one. or 3-1 359 738 367 (decimal): the smallest is otte less than the negative of that number. If
you attetttpt to type in a FIX outside that range. READ converts it to a FLOAT; if a program you
write attempts to produce a FIX outside that range. an overflow error will occur (unless it is
disabled).
The radix used by READ and PRINT is changeable by the user: however. there are two formats for
representations of FIXes which cause READ to use a specified radix independent of the current one.
These are as follows:
(ll If .1 group of digits is itnntediately followed by a period (.). READ interprets that group as
the decinml representation of a FIX. For example. 10. is always interpreted by READ as the
decimal representation of ten.
(‘Zl If a group of digits is ituntetliately enclosed on both sides by asterisks ("). READ interprets
that group as the octal representation of a FIX. For example. "10’ is always interpreted by
READ as the octal represettlatiott of eight.
2.6.2. READ attd PRINT versus FLOATing-point Numbers
PRINT can product-. and READ can understand, two different formats for objects of TYPE FLOAT.
The first is "decitn.1l-point" notation. the second is "scientific' notation. Decimal radix is always
used for representations of FLOATs.
“Decimal-point" notation for a FLOAT consists of an arbitrarily long string of digits containing one
. (period) which is followed by at least one digit. READ will tnalte a FLOAT out of any such object.
with a litnit of precision of one part in 2 to the 27th power.
“Scientific” notation consists of:
(I) a nntnher.
('2) ittttttetliately followed by E or e (upper or lower case letter E).
(3) itntttetliately followed by an exponent.
wlterc a "number" is an arbitrarily long string of digits. with or without a decimal point (see
following note): and an "exponent" is up to two digits worth of FIX. This notation represents the
"number" to the "t-.\~ponent" power of tett. Note: if the 'uumber' as above would by itself be a FIX,
and if the "ea-potteut" is positive. and if the result is within the allowed range of FIXes. then the
result will be a FIX. l-'nr example. READ understands l0El as 100 (a FIX). but 10E-I as 1.0000000 (a
FLOAT).
The largest-magnitude FLOAT which can be handled without overflow is l.70141l8E+38 (decimal
radix). The smallest-tttagnitttde FLOAT wltich can be handled without underflow is .14693679E-36.
2.6.1 - 2.6.2 Read. Evaluate. and Print
' 



24 The MDL Programming Language
2.6.3. READ and l"NAl‘|[s
The question "tvltat is a legal PN!\ME?" is actually ttot a reasonable one to ask: any non-empty string
of arbitrarv characters can be llte PNAME of an ATOM. However. some PNAHEs are easier to type to
READ than others. Bttt even the question "what are easily typed PNAt1Es?' is not too reasonable,
because: READ decides that a group of characters is a PNAHE by default: if it ca|t't possibly be
anything else. it's a PM/\l“lE. So. the rules governing the specification of PNAMEs are tnessy. and best
expressed in terms oi’ what is ||ot a PNAHE. For simplicity. you catt just consider any uninterrupted
group of t|p|)t'r- and lower-case letters attd (customarily) hyphens to be a PNAME; that will always
work. if you are neither a perfectionist ttor a ntasocltist. sltip to the next chapter.
2.6.31. Nott-l‘Nl\l‘lEs
A group of cltaraclers is t_t_c1a PNAHE if:
(ll it rt‘pr(‘s(‘IIl.\ a FLOAT or a FIX, as described above -- that is. it is composed wholly of digits.
or digits and a single . (period). or digits and a . and the letter E or e (with optional minus
signs in the right places).
(2) It begins with a . (period).
(3) it contains -- if typed interactively -- any of the characters which have special interactive
effects: “E1. “D, “L, ‘G. “S, “O, $(ESC).rubout.
(4) it contains a format character -- space. carriage-return. line~feed. form-feed, horizontal tab.
vertical tab.
(5) it contains a , (conuna) or a I (number sign) or a ' (single quote) or a ; (semicolon) or a X
(percent sign).
(6) It contains any variety of bracket -- ( or ) or [ or ]or ( or ) or ( or ) or ".
In addition. the character \ (backslash) has a special interpretation. as mentioned below. Also. the
pair of characters !- (exclamation-point hyphen) has an extremely special interpretation. which you
will reach at chapter l5.
The characters tnentioned in cases 4 through 6 are "separators' -- that is. they signal to READ that
whatever it was that the preceding characters represented. it's done now. They catt also indicate the
start of a new object's representation (all the opening ‘brackets’ do just that).
2.6.3.2. Examples
The following examples are not in the ‘standard format" of ‘line Iyped in$ result printed‘. because
they are not. in some cases. complete objects: hence. READ would continue waiting for the brackets to
2-5-3 - 2-5-3-2 Read. Evaluate. and Print



The MDL Prngratntttittg Language 25
be closed. In other cases. they will produce errors during EVALuation if other -- currently irrelevant
-- contlitinm are not mt-t. Instead. the right-hand column will be used to state just what READ
thought the input in the left-hand colttntn really was.
ABCS an ATOM of PNAME ABC
ahc$ an ATOM of PNAME abc
ARBITRARILY-LONG-PNAME§ an ATOM of PNAME ARBITRARILY-LONG-PNAME
1.73455 a FLOAT, PRINTed as 1.2345000
l.2.345S an ATOMof PNAME 1.2.345
ft.or.BS an ATOM of PNAME A.or_B
.A.or.[lS ttot an ATOM, but (as explained later) a FORM containing
an ATOM of PNAME A.or'.B
MORE THAN ONE$ three ATOMs, with PNAME5 HORE, and THAN, attd ONE
ab(cd$ an ATOM of PNAME ab, followed by the start of something
else (The something else will contain an ATOM of PNAME
beginning cd.)
l2345/U45 an ATOM of PNAME l2345A34 (lf the A had been an E, the
object would have been a FLOAT.)
2.6.3.3. \ lllackslnsltl in ATONs '
If yott have :\ stmnge. uncontrollable compulsion to have what were referred to as "separators" above
as part nf the PNAI-lF.< of your ATOlls. you can do so by preceding them with the character \
(backslasltl. \ will also ntagit-ally turn an otherwise normal FIX or FLOAT into an ATOM if it appears
alttnngst the digits. In fact. hack-sl.1slt in front of Qycltaracter changes it from something special
to "just nttmlier character“ (inclttding the cltaracler \). It is an escape cltaracter.
When PRINI confronts an ATOM ti-lticlt had to be backslaslted in order to be an ATOM, it will
dutifully type out the required \s. They will not. however. necessarily be where you typed them:
they will ittstend he at those positions which will cause READ the least grief. For example, PRINT will
type out .1 PHAME which consists wholly of digits by first typing a \ attd then typing the digits - no
tnatter where you originally typed the \(or \s).
2.0.3.2 - 2.6.3.3 Read. Evaluate. and Print



26 The MDL Programming Language
2.6.3.4. Emmples nf Awful I\l0Hs
The following cxainplcs illustrate the amount of insanity that can be perpetrated by using \- Th!
format of the examples is again non-standard. this time not because anything is unfinished or in
error. but becnnsc rnnnnenting is needed: PRINT doesn't do it full justice.
a\ 0ne\ and\ a\ t.woS one ATOM, whose PNAHE has four spaces in it
an ATOM of PNAHE 123456789, which PRINTs as
\l234567B9
l234\56789S
l23\ S an ATOM of PNAHE l23space. which PRINTS IS \123\ ,
with a space on the end
\\S an ATOM whose PNAME is a single backslash
2.6.3.4 Read. Evaluate. and Print
l
\
i .
l
I
1 1
I
1.



The MDL Progranuning Language 27
Chapter 3. Built-in Functions
3.]. Repre_s§tltg_l§1p_ﬂ]
Up to this pniltt. all the objects we have been concerned with have had no internal structure
disceruihle in .\lDl.. While the characteristics of objects with internal structure differ greatly. the
way READ and PRINT handle tlteut is uniform. to wit:
READ, when applied to the representation of a structured object, builds and returns an object of
the indicated TYPE with elements formed by applying READ to each of their representations in
turn.
PRINT, when applied to a structured object. produces a representation of the object. with its
elements represented as PRINT applied to each of them in turn.
A MDL object which is used to represent the application of a function to its arguments is an object
of TYPE FORM. Its priuterl representation is
< fun: erg-I arg-2  arg-N >
where lime is an object which designates the function to be applied. attd arg-1 through arg-N are
objects which designate the arguments or ‘actual parameters‘ or "inputs'. A FORH is just a
structured object which is stored and can be manipulated like a LIST (its "primitive type" is LIST —
chapter 6). The application of the function to the arguments is done by EVAL. The usual meaning
of "function" (uncapitalizedl in this document will be anything applicable to arguments.
3.2. Evaluitiiu]
EVAL applied to a FORM acts as if following these directions:
First. exatnine the /uric (first element] of the FORM. If it is an ATOH, look at its "value" (global or
local. in that nrder -- see ttcxt chapter). lf it is not an ATOM, EVAL it and look at the result of the
3 - 3.2 Built-in Functions



_ i _;_ i _  
28 The MDL Programming Language
evaluation. tr what you are looking at is not something which can be applied to arguments.
COItlp|:\i|| (via the ERROR function). Otherwise. inspect what you are looking at and follow its
directions in evalttatittg or not evaluating the arguments (chapters 9 and l9) and then "apply the
function" -- that is. EVAL the hotly of the object gotten from lune.
3.3. Built-in Fttttctintts (TYPE SUBR, TYPE FSUBR) Q]
The hnilt-in functions of MDL come itt two varieties: those which have all their arguments EVALed
before nprratillg mt thcnt (TYPE SUBR, for "subrotttiue". pronounced 'subber") and those which have
none of their .-trgtnnrnts EVALcd (TYPE FSUBR, historically from Lisp (Moon. l974). pronounced
"effsnhht-r"). Collrrtivoly they will be called F/SUBRs. although that term is not meaningful to the
interpreter. See appendix 2 for a listing of all F/SUBRs and short descriptions. The term
"Subroutine" will be used herein to ntean both F/SUBRs and cotnpiled user programs (RSUBB and
RSUBR-EHTRYs -- cliaptcr I9).
Unless otherwise staterl. 9353 MDL built-in Subroutiue mentioned is of TYPE SUBR. Also, when it
is stated that an argnntcnt of a SLIBR tnttst be of a particular TYPE, note that this means that EVAL
of what is there ntnst he of the particttlar TYPE.
Another convenient abbreviation which will be used is 'the SUBR pname' in place of "the SUBR which
is initially the ‘value’ of the ATOM of PNAHE pname'. ‘The FSUBR pname' will be used with a similar
meaning.
3.4. Examples (+ and FIX; Arithmetic]_[l]
(+ 2 4 6)$
12
The SUBR + adds ntttnliers. Most of the usual arithtnetic functions are MDL SUBRs: +, -, ", I,
HIN. MAX, H00, Sill, COS, ATAN, SORT, LOG, EXP. ABS. (See appendix 2 for short descriptions
of these.) All except H00, which wants FIXes. are indifferent as to whether their arguments are
FLOAT or FIX or a tttixtttre. In the last case. they exhibit "contagious FLOATing': one argument of
TYPE FLOAT forces the result to be of TYPE FLOAT.
(FIX l.0>S
l
The SUBR FIX explicitly returns a FIXcd-point number corresponding to a FLOATing-point number.
FLOAT does the opposite.
<+ 5 <1‘ 2 3)>5
3.2 - 3.4 Built-in Functions



The MDL Progratnttting Language 29
ll
(SORT <0 <" 3 3) (' 4 4)>)$
5.0
(- 5 3 2>$
A O
t
ut
v
M
-s
<t~utt12.o>s
1.0
<1 11 1 2.o>s
0.5
Note this last result: tlte division of two FIXes gives a FIX with truncation. not rounding. of the
retnaintler: the intcrtttrdiate result remains a FIX until a FLOAT argument is encountered.
3.5. Arithntt-tic: Details
+, -, '. /. MIN, and MAX all tal-;c any ntttttber of arguments. doing the operation with tlte first
argntttettt and the serrtnd. tltetl with that result attd the third argument. etc. If called with no
argnntents. each returns the identity for its operation (0, 0, 1, l, the greatest FLOAT, attd the
least FLOAT. rc\pt‘ctivt'|y): if called with one argutnettt. each acts as if the identity attd the argument
had been stlppiicd. They all will cause an overflow or underflow error if any result. intermediate or
final. is tno large or tnn small for the machine's capacity. (That error can be disabled. if necessary
-~ section [(3.9).
One aritlmtetic functintt that always requires sotne discussion is the pseudo-rattdotn-number
generator. MD] ‘s is named RANDOM, and it always returns a FIX. uniformly distributed over the
whole range of F1Xes. If RANDOM is never called with arguments. it always returns the exact same
sequence tit’ ttuntbcrs. for cntwettiettce in debugging. "Debugged" programs should give RANDOM two
argutttcnts on the first call. which becontc the seeds for a new sequence. Popular choices of new
seeds are tlte ttttttthers given by TIME (wlticlt see). possibly with bits modified (chapter 18). Example
("pick a ntttnber front one to ten"):
(+ 1 (MOD (RANDOM) l0))S
4
3.4 - 3.5 Built-in Functions



30 The MDL Programming Language
Chapter 4. Values of Atoms
4.l.Gen_t1al]|[
There are two Limls of "value" which can be attached to an ATOM. An ATOM can have either. both. or
neither. They interact in no way (except that alternately referring to one and then the other is
ineffirietttl. Tht‘st' two values are referred to as the local value and the global value of an ATOM.
The terms "local“ and "global" arc relative to PROCESSes (chapter 20). not functions or programs.
The SUBRs which reference the local and global values of an ATOM, and some of the characteristics
of local versus global values. follow.
4.2. Clolwal_\'_:tl\|es
4.2.1. SE TB [l]
A global valne can be assigned to an ATOM by the SUBR SETS (‘set global"), as in
(SETG Mom any)
where atom must EVAL to an ATOM, and any can EVAL to anything. EVAL of the second argument
becomes the global value of EVAL of the first argument. The value returned by the SETG is its
second argument. namely the new global value of alom.
Examples:
(SETS F00 <SETG BAR 50D>)S
500
The abnve made the global values of both the ATOM FOO and the ATOM BAR equal to the FIXed-point
number 500.
(SETS BAR l'0O>$
4 - 4.2.1 Values of Atoma



The MDL Progratuuting Language 3|
F00
That made the global value of the ATOM BAR equal to the ATOM F00.
4.2.2. GVAL [1]
The SUBR GVAL (“global value") is used to reference the global value of an ATOM.
<GVI\L afom)
returns as a value the global value of atom. ll’ atom does not evaluate to an ATOM, or if the ATOM to
which it evalttates has no global value. an error occurs.
GVAL applied to an ATOM anywhere. in atty PROCESS. in any function. will return the same value.
Any SETG attytvhere changes the global value for everybody. Global values are context-independent.
READ tuttler-t.1uds the character , (comma) as an abbreviation for an application of GVAL to
whatever follows it. PRINT always translates an application of GVAL into the comma format. The
following are ahsolutely equivalent:
, atom ( GVAL afOm>
Assuming the examples itt section 4.2.l were carried out in the order given. the following will
evaluate as indicated:
.l'00S
500
<GVAL F00)$
500
,BAR$
F00
t .BAR$
500
4.2.3. Note on SUBRs and FSUBRs
The initial GVM.s of the I\TOHs used to refer to MDL ‘built-in‘ Subroutines are the SUBRs and FSUBRs
whiclt actually get applied when those ATOMs are referenced. if you don't like the way those
Supplied routines work. you are perfectly free to SETS the ATOMs to your own versions.
4.2,] . 4.2.3 Values of Atoms



32 The MDL Programming Language
4.2.4. GUNASSIGN
( GUNASSIGN atom)
(‘global unassign") causes atom to have no assigned global value. Whiihtf 0|‘ I10! ii hit! °l'\¢
previously. The storage used for the global value can become free for other uses.
4.3. Local Values
4.3.|. set [:1
The SUBR SET is used to assign a local value to an ATOM. Applications of SET are of the form
<SET atom any)
SET returns EVAL of any just like SETG.
Examples:
(SET BAR (SET F00 l00)>$
100
Both BAR and F00 have been given local values equal to the FIXed-point number 100.
(SE T FOO BARN»
BAR
FOO has been given the local value BAR.
Note that neither of the above did anything to any global values FOO and BAR might have had.
4.12. LVAL [1]
The SUBR used to extract the local vnlne of an ATOH is named LVAL. As with GVAL, READ
understands an abbreviation for an application of LVAL: the character . (period). and PRINT
produces it. The following two representations are equivalent. and when EVAL operates on the
corresponding MDL object. it returns the current local value of atom:
<LVAL alom> .a!om
4.2.4 - 4.3.2 Values of Atoms



1* 11,; MDL Progrannning Language 38
The local \-alne of an ATOM is unique within a PROCESS. SETting an ATOH in one PROCESS has no
effect on its LV/\L in another PROCESS, because each PROCESS has its own ‘control stack‘ (chapters
20 and 22).
1' Assume Q of the previous examples in this chapter have been done. Then the following evaluate as
indicated:
.BI\R$
I00
<l.VAL BAR)$
100
.FOO$
BAR
, .FOO$
FOO
4.3.3. UNASSIGN
(UNASSIGN alum)
causes alom to have no assigned local value. whether or not it had one previously.
4 4 VALUE
VALUE is a SUBR which takes an ATOM as an argument. and then:
(l) if the ATOM has an LVAL, returns the LVAL;
(2) if the ATOM has no LVAL but has a GVAL, returns the GVAL;
(3) if the ATOM has neither a GVAL nor an LVAL, calls the ERROR function.
i
r This order of seeking a value is the opposite of that used when an ATOH is the first element of a
i FORM. The latter will be called the GILVAL. even though that name is not used in MDL.
Exam I :
.0 P E
‘T <UNASSIGN A>$
it A
<ssrs A 1>s
t
(VALUE A>S
1
i <SET A 2>s
“ 4 432-a4 VﬂuuofAwms
i



i
1
I
34 The MDL Programming Language ‘
ii
2 ':
(VALUE ms 1
2 “
,A$ 4
1 .
i
i
‘I
!
1
1
1
u
4-4 Values of Atoms



age
ns
The MDL Progranttning Language 35
Chapter 5. Simple Functions
5.l. General |l|
The MDL equivalent of a 'progratn" (uncontpiled) is an object of TYPE FUNCTION. Actually, full-
blown "programs" arc usually composed of sets of FUNCTIONs. with most FUNCTIONs in the set acting
as "sub|trogr.1tns".
A FUNCTION may he considered to be a SUBR or FSUBR which you yourself define. it is ‘run’ by
using a FORM to apply it to arguments (for example, <!unclion arg-1 arg-2  >). and it always
"returns" a single object. which is used as the value of the FORM that applied it. The single object
may be ignored by wltatever "ran" the FUNCTION ~- equivalent to "returning no value" - or it may be
a structured object rotttainittg many objects -- equivalent to "returning many values‘. MDL is an
"applir:ativo" Iattgttago. itt contrast to "imperative" languages like Forlran. ln MDL it is impossible
to return values through arguments in the normal case: they can be returned only as the value of the
FORM itself. or as side effects to structured objects or global values.
In this (‘l|t\plt‘r a simple subset of the FUNCTIONs you can write is presented. namely FUNCTIONs
which "act lil.e" SlIBRs with rt fixed number of arguments. While this class corresponds to about 907.
of the l'UHCTl0Hs ever written. you won't be able to do very much with them until you read further
and learn more about MDL'.s control and ntanipulatory machinery. However. all that machinery is
just a bunch or Sutltts and FSUBRs. and yott already know how to "use" them: you just need to be told
what they do. Once you have FUNCTIONs under your belt. you can immediately make use of
everything presented front this point on in this document. ltt fact. we recommend that you do so.
5-2. Representation |l[
A FUNCHOH is just another data object in MDL, of TYPE FUNCTION. lt can be manipulated like any
other data object. PRINT represents a FUNCTION like this:
IFUNCTION (elements)
5 - 5.2 Simple Functions



 ‘
36 The MDL Programming Language
that is. a number sign. the ATOM FUNCTION, a left parenthesis. each of the elements of the
FUNCTION, antl a right pan-ntItt~sis. Sittce PRINT represents FUNCTIONs like this. you can type them
in to READ this way. (But there are a few TYPEs for which that implication is false.)
The eletncnts of a FUNCTION can be "any number of anythings'; however. when you E a FUNCTION
(apply it with a FORM). EVAL will complain if the FUNCTION does not look like
iFUNCT1ON (achalom argumenlsiisl derl body)
where ad and decl are optional (section 9.8 and chapter 14): body is Q least 1% MDL object - any
old MD]. ohjcct: anti. in this simple case. arguments is
(any number of ATOMs)
that is. something RFAD and PRINTed as: left parenthesis. any number - including zero - of ATOHs.
right parentltesis. (This is actually a normal MDL object of TYPE LIST, containing only ATOHs.)
Thus. these FIINCTIOM will cause errors -- but only when used:
#FuttCTION () -- no argument LIST or body
‘FUNCTION ((1) 2 7.3) -- non-AT0l'lin argument LIST
IFUNCTION ((A B C D)) -- no body
IFUNCIION (<+ I 2) A C) -— no argument LIST
These FUNCTIONs will never cause errors because of format:
arunctton (() t 2 3 4 s)
aruuctton (ta) A)
-‘FUNCTION (()()()()(l()()(l)
nruncttou ((A a c 0 EE F s H utvn) <+ .A .HIYA>)
nruuctton ((0) <szts c <- .0 ,c>> <~ <noo ,c a> .o>)
and the last two actually do sotnetlting which might be useful. (The first three are rather
pathological. but legal.) -
5.3. Appﬂqatinlt nl'_l’UNCTI0ll.s: Binding [1]
FUNCTIONs. like SUBRs and FSUBRs. are applied using FORl'ls. So,
(‘FUNCTION ((X) (" .X .X>) 5>S
25
applied the tttdicatvtl FUNCTION to 5 attd returned 25.
5.2 - 5.3 Simple Functions



T  
I
1
,e ) The MDL Prograuttttittg Language 37 Y
Q What EVAL does when applying a FUNCTION is tlte following:
I
n (1) Create a "world" in which tlte ATOMs of the argument LIST have been g to the values )
applictl to the FUNCTION, attd all other ATOMs have their original values. This is called
N T "binding". V
-- ltt the above. this is a ‘world’ itt which X is SET to 5.
(2) lu th:tt new "world". evalttate all tlte objects in tlte body of the FUNCTION, one after the
Y other. front first to last. l
1
-- ltt the above. this uteans evaluate (' .X .X> itt a "world" where X is SET to 5.
_ (3) Throw away the "tvorld" created. attd restore the LVALs of all ATOMs bound itt this ‘
‘ 2 application of the FUNCTION to their originals (if atty). This is called "unhittding".
| -- ltt the above. this sitttply gives X back the local value. if any. that it had before binding.
(4) Retttrtt as a value the la_st valtte obtained when the FUNCTION's body was evaluated ltt step
(2)
-- ltt the above. this ntcans return 25 as the value.
The "world" tttentiottr-tl above is actually an object of TYPE ENVIRONMENT. The fact that such )
"worlds" are separate front the FUNCTION: which cause their generation means that LII MDL
FUNCTION< can be used recursively.
l
The only thing that is at all trnttblesottte itt this sequence is the effect of creating these new '
i "worlds". itt particular. the fact that the gm-ions world is completely restored. This means that if.
inside a FUNCTION, you SET one of its argutueut ATOMs to something. that new LVAL will 5E be ‘
1 retttetttberetl when EV/\L leaves the FUNCTION. However. if you SET an ATOM which is Lt in the l
argument LIST (or SETG Q1 ATOM) the new local (or global) value ﬂit: remetnbered. Examples:
(SET X O>$
0
I (‘FUNCTION ((X) (SET X <" .X .X>>) 5>$ ‘
l 25
.xs J
O
. l
i .
5.3 Simple Functions
; .4
 



-s  
38 The MDL Programming Language
On the other hand.
(SET Y 0)!
0
(JUNCTION ((X) (SET Y (" .X .X)>) 5>$
25
.Y$
25
By using PRINT as .1 SUBR, we can "see" that an argu|nent's LVAL really is changed while EVALuating
the body of a FUNCTION:
(SET X 5>S
5
(tiFllNCTION ((X) (PRINT .X> <+ .X 10)) IDS
3 13
.X$
5
The first nlttnher after the application FORH was typed out by the PRINT; the second is the value of
the application,
Remetnhcring that t.VALs of ATOt1s [E in argument LISTs are not changed. we can reference them
Within FUNCTIONs. as in
(SET Z l00>$
100
<iFllNCTION ((Y) (I .Z .Y)) 5)!
20
ATOHs nscrl like Z nr Y in the above examples are referred to as "free variables". The use of free
variables. while nftmt quite rnnvcnicnt. is rather dangerous unless you know exactly how a
FUNCTION will ;tQ\_a_\j_s_ be used: if a FUNCTION containing free variables is used within a FUNCTION
within a FUNCTION within . . .. one of those FUNCTIONs might just happen to use your free variable
in its argntnent LIST, binding it to some unknown value and possibly causing your use of it to be
erroneous. Please note that "dangerous". as used above, really means that it may be effectively
ttttpossihle (ll for other people to use your FUNC‘l'IONs. and (2) for yﬂ to use your FUNCTIONs a
month (two wec-Its?) later.
5.3 Simple Functions



8
-f
I‘<lIfIZIlI
The MDL Programnting Language 39
'||i_|Ig_j._|_N_Cl I§Ns [FUNCTION and DEFINE} |l|
5 -i Deft___
Obviously, typing QFUNCTION (...) all the time is neither reasonable nor adequate for many
pm-poses. Nnnnnlly. you just want a FUNCTION to be the GVAL of some ATOH - the way SUBRs and
F5UBRs are -- so you can use it repeatedly (and recursively). Note that you generally do gtg want a
FUNCTION tn be the LVAL of an ATOM; this has the same problems as free variables. (Of course. there
are always cases where you are being clever and Ewe ATOH to be re-bound . . . .)
One way to "name" a FUNCTION is
(SETG SQUARE IFUHCTION ((X) (F .X .X>))$
iFUllCTION ((X) (* .X .X))
So that
(SQUARE 5)!»
25
<SOUI\RE 100 >3
10000
Another way. which is sotnewhat cleaner itt its typing:
(SETG SQUARE (FUNCTION (X) (F .X .X)))$
IFUNCTION ((X) (F .X .X))
FUNCTION is an FSUBR which simply makes a FUNCTION out of its arguments and returns the created
FUNCTION.
This. however. is generally the li_t'st way:
<DEFINE soutnz (x) <~ .x .x>>s
SQUARE
.souARcs
rrunctrou ((x) <- .x .x>)
The last two litres innnediately above are just to prove that DEFINE did the ‘right thing‘.
DEFINE is an FSUBR which SFTGs EVAL of its first argument to the FUNCTION it makes from the rest
of its argttments. and then returns EVAL of its first argument. DEFINE obviously requires the least
typing of the :tbt\\'E methods. and is "best" from that standpoint. However. the real reason for using
DEFINE is the fnllntt-ing: ll‘ [VAL of DEFINE's first argument already IE a GVAL, DEFINE produces an
error. This helps tn Let-p you from aecidently redefining things - like MDL SU8Rs and FSUBRs. The
SETG cnnstrnctinlts shonltl be used only when you really do want to redefine something. DEFINE will
be used itt the rest of this document.
5.4 Simple Functions



“F”
40 The MDL Programming Language
[Actt|2tlly. if it is absnllttcly necessary to use DEFINE to ‘redefine’ things. there is a ‘switch’ which
can be used: if the LVAL of the ATOM REDEFINE is T (or anything not of TYPE FALSE). DEFINE will
produce no errors. The normal state can be restored by evaluating (SET REDEFINE <>>. See
chapter 8.]
5.5. Examples (Cnmmctttsl [I]
Using SQUARE as defined above:
(DEFINE llYl"0T (SIDE-l SIDE-Z)
;"Ttt'ls is at comment. This FUNCTION finds the
length of the hypotenuse of a right triangie
of sides SIDE-1 and SIDE-2.‘ .-
<SORT (+ <SOUARE .SIDE-1) (SQUARE .S1UE~2>))>S
IIYPOI
<HYPOT 3 4>$
5.0
Note that rzirringt--returns. line-l't-rtls. tabs. etc. are just separators. like spaces. A comment is 111
single MDL t\b_]t'ct which follows a ; (setnicolon). A comtnent can appear between any two MDL
objects. A cmnmcut is totally ignored by EVAL but remetnbered and associated by READ with the
place in the Ftlttcttott (nr any other structured object) where it appeared. (This will become clearer
after chapter lf!.l The "s (dotthlc-qttnies) serve to make everything between them a single MDL
object. whose TYPE is STRING (chapter 7). (SORT is the SUBR which returns the square root of its
argument. it always returns a FLOAT.)
A whimsical FUNCTION:
(DEFINE ONE (TIIETA) ;"This FUNCTION always returns 1.‘
<+ <SOUARE (SIN .TllETA>>
(SQUARE (COS .THETA)>>>$
ONE
(ONE 5).’:
0.999999%
(ONE 0.23>S
0.99999999
ONE always retttrtts (approximately) one. since the sum of the squares of sin(x) and cos(x) is unity
for any .\. (SIN and COS always return FLOI\Ts. and each takes its argument ln radians. ATAN
(arctangentl returns its value in radians. Any other trigonometric function can be compounded
from these three.)
5.4 - 5.5 Simple Functions
ll
F
y l
F
4
t
l
s->_ ?<~..c
T
4



I
.gQ The MDL Prngrantnting Language 4|
ch 1 MDL doesn't have a general "to the power‘ SUBR, so let's define one using LOG and EXP (log base e.
-i|| f and e to a power. respectively: again. they return FLOATs).
.“ .
' (DEFINE " (NUH PVR) (EXP <" .PlIR (LOG .NUH)>)>S
‘ ll
| <*~ 2 2>s
4 .000000l
<" 5 3>S
125.0000!)
("" 25 0.5>$
5.000000]
Two FUtlC‘l'IOlls which use a single global variable (Since the GVAL ls used. it cannot be rebound):
(DEFINE START () (SETG EV O))$
START
(DEFINE STEP () (SETG GV (+ ,GV l>))$
STEP
(START)$
0
it (STEP)$
IL 1
he <SlEP>$
er Z
»L <STEP>$
ts 3
START and STEP take no argnntents. so their argument LIST: are empty.
An interesting. hut pathological. FUNCTION:
(DEFINE INC (ATH) (SET .ATH <+ ..ATH l>>>S
INC
(SET A 0>$
0
(INC A)!»
l
(INC A)$
2
[Y .A$
\N 2
ed
INC takes an ﬁg as an argttntent. and SETs tltat ATOM to its current LVAL plus l. Note that inside
INC. tltc ATOM ATM is SET to the ATOM which is its argument; thus ..ATH returns the LVAL of the
‘Bi. llnwevcr. there is a problem:
9 5.5 Simple Functions



42 The MDL Programming Language
(SET ATM 0>$
0
(INC /\Tl‘1).l>
‘ERROR’
ARG-NROIJG-TYPE
0
LISTENING-AT-LEVEL 2 PROCESS I
(ARIES (FRAME (FRAHE>)>$
[ATM l]
The error ocrtlrrrtl bcraltsc .ATH was ATM, the argument to INC, and thus . .ATH was ATM also. We
really w.-mt the rmtcrtttnst . in . .AlH to be done in the 'world' (ENVIRONMENT) which existed ju_st_
before INC was entered -- and this definition of INC does both applications of LVAL in its own
"world". Tcclmiqttcs for doing INC "correctly" will be covered below. Read on.
5.5
1 1*
Simple Functions
Tl
Q
A
th
llt
m
A
“F
di
W
oi
tn
Ill
It
pl
fr
Bl
in
Q
T
k.
R,



age
We
'|ust
awn
The MDL Prograntming Language 43
Chapter 6. Data Types
6.l. General |l[
A MDL object cottsists of two parts: its TYPE and its ‘data part‘ (appendix l). The interpretation of
the "data part‘ of an object depends of course on its TYPE. The structural organiaation of an object.
that is. the way it is organized in storage. is referred to as its "primitive type". While there are
many differettt TYl‘Es of objects in MDL. there are fewer primitive types.
All structured objects in MDL are ordered sequences of elements. As such. there are SUBRs which
operate on all nf them uniformly. as ordered sequences. On the other hand. the reason for having
different primitive typos of structured objects is that there are useful qualities of structured objects
which are mutually incompatible. There are. therefore. SUBRs whiclt do not work on all structured
objects: these SUBRs exist to take full advantage of those mutually incompatible qualities. The
most-commnnly-uscrl primitive types of structured objects are discussed in chapter 7. along with
those special SUl1Rs operating on them.
lt is very easy to make a new MDL object that differs frotn an old one only in TYPE, as long as the
primitive type is unchanged. It is relatively difficult to make a new structured object that differs
from an old one in primitive type. even if it has the same eletttents.
Before talking any ntore about structured objects. some information needs to be given about TYPE:
in general.
6.2. Printed Representation |l[
There are many TYPEs for which MDL has no specific representation. There aren't enough different
kinds of brackets. The representation used for TYPEs without any special representation is
Hype representation-as-if-ihwere-ifs-primifiva-type
READ will understand that format for Qty TYPE, and PRINT will use it by default. This
5 - 6.2 Data Types



-
44 The MDL Programming Language
representational format will be referred to below as ‘I notation’. It was used above to represent
F UNCTIONs.
s.s. suaru Rglitl to TYPEs
s.s.t. tws [t]
(TYPE ﬁlly)
returns an [Lyn wltme PH/\t~t[ corresponds to the TYPE of any. There is no TYPE "T\'PE'. To type a
TYPE (aren't hmnonynts wont.lerful?). just type the appropriate ATOM, like FIX or FLOAT or ATOM etc.
However. in this document we will use the convention that a ntetasyntactic variable can have type
for a "data type": for example. fo0.'{ype means that the TYPE of foo is ATOM, but the ATOM must be
something that the SUBR TYPE can return.
Examples:
(TYPE l>$
FIX
(TYPE 1.0>$
FLOAT
(TYPE +>$
ATOH
(TYPE .+)S
SUBR.
(TYPE GEORGE>S
ATOM
6.3.2. PR1H1YPE[l]
(PRIHTYPE any)
evaluates to the primitive type of any. The PRIHTYPE of any is an ATOM which also represents a
TYPE. The way an object can be manipttlated depends solely upon its PRIHTYPE; the way it is
evaluated depends upon its TYPE .
Examples:
(PRIHTYPE l)$
UORD
<PRIHTYPE l.0>$
6.2 - 6.3.2 Data Types
 



I
ge The MDL Progrannning Language 45
wono
, <PRIHTYPE ,+>s
‘ voao
I <valnrws ssons:>s
ATOM
Ill
6.3.3. TYPEPRIH [I]
<TYPEPRIM type)
returns the PRIHTYPE of an object whose TYPE is lype. type is. as usual, an ATOM used to designate I
‘ TYPE.
ea Y
tc.
P9 4
be
Examples:
(TYPEPRIH FIX)S
WORD
<TYPEPRIH FLOAT)$
WORD
<TYPEPRIM SUBR)$
WORD
<lYPEPRIH ATOH)S
ATOM
(TYPEPRIH FORH)$
LIST
&3A.CHTYPE[H
<CHTYPE any lyre)
, (“change type") returns a new object that has TYPE type a||d the same "data part" as any (appendix
I)
<CHTYPE (+ 2 2) FORM>S
<+ 2 2)
V I
3‘ An error is generated if the PRIHTYPE of any is not the same as the TYPEPRIH of Iype. An error will
I ilio be gem-r.-tted if the attempted CHTYPE is dangerous andlor senseless, for example. CHTYPEing a
; FIX to a SUBR. Unfortunately. there are few useful examples we can do at this point.
I
[CHTYPEing a FIX to a FLOAT or vice versa produces. in general. nonsense. since the bit formats for
FIXes and FLOATs are different. The $UBRs FIX and FLOAT convert between those formats. Useful
N‘ ($3.2 - 6.3.4 Data Types
i
L



46 The MDL Programming Language
obscurity: liccattsr nf their internal representations on the PDP-10. <CHTYPE (MAX) FIX) gives the
least possible FIX, antl analngnnsly for HIPL]
Passing note: "Q notation" is just an instruction to READ saying “READ the representation of the
PRIHTYPE ltrirtttally aml (litcrallyl CHTYPE it to the specified TYPE". [Or. if the PRIHTYPE is
TEMPLATE. "apply the GVAL of the TYPE name (which should be a TEMPLATE constructor) to the given
elements of the PRIHTYPE TEMPLATE as arguments.']
6.4. More SUBRs Riletl to TYPEs
6.4.l. ALLTYPES
<ALLTYl"ES>
returns .1 VECTOR (chapter 7] containing just those ATOHs which can currently be returned by TYPE
or PRIHTYPE . This is the very "TYPE vector‘ (section 22.1) that the interpreter uses: look, but don‘! 
touch. No e.\an|plt:s: try it. or see appendix 3.
6.4.2. VALID—TYPE 7
(VALID-TYPE 2 alom)
returns QFALSE () if atom is not the natue of a TYPE, and the same object that (TYPE-C atom)
(section l9.5) returns if it is.
6.4.3. NE\-(TYPE
MDL is a type-extensible language. in the sense that the programmer can invent new TYPEs and use
thetn in et-cry way that the predefined TYPEs can be used. A program-defined TYPE is called a
NEHTYPE . New l‘RIMTYl"Es cannot be invented except by changing the interpreter: thus the TYPEPRIH
of a NENTYPE llHl\l he (‘|Iﬁ\(‘ll from thnse already available. But the name of a NEHTYPE (an ATOM of
course) can be rltnselt freely -- so long as it does not conflict with an existing TYPE name. More
importantly. the ptngrattl that defines a HEHTYPE can be included in a set of programs for
manipulating nlijrrts of the NEHTYPE in ways that are more meaningful than the predefined SU8Rs
of MDl..
Typically an nhjcct of a NEWTYPE is a structure that is a model of some entity in the real world - or
wliatcrrr wnrld the program is concerned with - and the elements of the structure are models of
parts or aspects nr the real-world entity. A NEHTYPE definition is a convenient way of formalizing
6.14 - 6.4.3 Data Types
1--_.l.¢qn--4--¢.
t
t
Tl
llt
If
wz
I0
ca
PI
Ft
pt
Sl
ai
yl
Si
nl
yl
"\>2"G'""!=Q.Z
<&QO-ﬁt-I
-r\-I-v9"‘T\_l



uage
- the
the
E is
iven
TYPE
ion’!
tom)
l use
ed a
PRIH
ill of
viore
for
U8Ra
- or
ls of
ling
Y?“
l
H
it
A_-_. -—L>
it
t
I
The MDL Programming Language 47
‘his ¢(|rrp\|l0Il(|(‘ll(‘(‘. nf writing it dowtt for all to see and use rather than keeping it in your head.
If the defining set of programs provides functions for manipulating the NEVTYPE objects in all
ways that are meaningful for the intended uses of the NEVTYPE, then any other program that wants
to use the til-j\HVt'tf ran call the manipulation functions for all its needs. and it need never know or
care about the internal details of the NEUTYPE objects. This technique is a standard way of
providing ntodnl.1rity and abstraction.
For example. stt|tp0'~e you wanted to deal with airline schedules. If you were to construct a set of
programs that define and manipulate a NENTYPE called FLIGHT, then you could make that set into a
standard package oi‘ programs and call on it to handle all information pertaining to scheduled
airline flights. Since all FLIGl|Ts wottld have the same quantity of information (more or less) and
you wnttltl want quick access to individual eletnents. you would not want the TYPEPRIH to be LIST.
Since the rlentents would he of various TYPEs. you would not want the TYPEPRIH to be UVECTOR -
nor its variations STRING or BYTES. The natural choice would be a TYPEPRIH of VECTOR (although
you could gain spare and lose tilne with TEHPLATE instead).
Now. the intlividual elements of a FLIGHT \vonld. no doubt. have TYPEs and meanings that don't
change. The elements of a FLIGHT might he airline code. flight number. originating-airport code.
list of interim-diate strips. destination-.1irport code. type of aircraft. days of operation, etc. Each and
every FLIGHT tvrvttltl have the airline code for its first eletnent (say). the flight number for its second.
and so on. lt is natural tn invent names (AT0l1s) for these elements and always refer to the elements
by name. For exatuplv. yott cnuld <SETG AIRLINE 1) or (SETG AIRLINE (OFFSET 1 FLIGHT>) —
and in either case <M/\NIFEST AIRLINE) so the contpiler catt generate more efficient code. Then. if
the local value of F were a FLIGHT, (AIRLINE .F> would return the airline code. and (AIRLINE .F
AA> would set the airline cnde to AA. Once that is done. you can forget about which element comes
first: all you nerd tn know are the names of the offsets.
The next step is to notice that. outside the package of FLIGHT functions. no one needs to know
whether AIRLINE is just an offset or in fact a function of sonte kind. For example. the scheduled
duration of a flight might not be explicitly stored in a FLIGHT, just the scheduled times of
departure and arrival. But. if the package had the proper DURATION function for calculating the
dnratinn. tltelt the call (DURATION .F> could return the duration. no matter how it is found. In this
way the internal details of the package are conveniently hidden frotn view and abstracted away.
The form of HEHIYPE tlefittilion allows for the TYPEs of all components of a NEHTYPE to be declared
(Chapter l-ll. for use hnth by a prngrannner while debugging programs that use the NEHTYPE and by
the compiler for generating faster code. It is very convenient to have the type declaration in the
HEVTYPE definition itself. rather than replicating it everywhere the NEHTYPE is used. (If you think
this declarntimt might be obtrttsive while debugging the programs in the NEUTYPE package. when
Inconsistent imprm-etnents are being made to various programs, you can either disassociate any
declaration front the NEWTYPE or turn off MDL type-checking completely. Actually this declaration
is typically more usel'nl to a programmer during development than it is to the compiler.)
<NEVTYPE atom Iype)
6.4.3 Data Types



 
48 The MDL Programming Language
returns atom. aftcr rausing it to become the represetttalion of a brand-new TYPE whose PRIHTYPE is
<TYPEPRItl f\'D!‘). What NEVIYPE actually does is make atom a legal argument to CHTYPE and
TYPEPRIH. (Note that nanies of new TYPEs can be blocked lexically to prevent collision with other
ttatnes. just like any other I\‘lOl1s -- chapter 15.) Objects of a HEUTYPE-created TYPE can be generated
by creating an object nl‘ the appropriate PRIHTYPE and using CHTYPE. They will be PRINTed
(initiallyl. and can he directly typed itt. by the use of 'ﬂ notation" as described above. El/AL of any
object whose TYPE was created by HEHTYPE is initially the object itself. and. initially. you cannot
APPLY something nf a generated TYPE to arguments. But see below.
Examples:
<NEVTYPE GARGLE FlX>S
GARGLE
<TYPEPRIM GARBLE>$
WORD
(SET A <CHTYPE l GARGLE>)$
iGﬁRGLE *00D00O00000l'
(SET B !GARGLE 100)$
iGARGLE '000000000l44'
(TYPE .B>5
GARGLE
<PRIMTYPE .B)$
WORD
6.4.4. PRINTTYPE , EVALTYPE and APPLYTYPE
<PR]NTTYPE type how)
<EVALTYPE type haw)
<APPLYlYPE Iype how)
all return !_\p0.<1fl(’l' specifying how MDL is lo deal with ll.
These three Slllllls can be used to make newly-generated TYPEs behave in arbitrary ways. or to
change the rlt.1|'.1t‘lerislirs of standard MDL TYPEs. PRINTTYPE tells MDL how to print type.
EVALTYPE how tn evaluate it. and APPLYTYPE how to apply it in a FORM.
how can be eithr-r a TYPE or solnclltittg that can be applied to arguments.
lf how is a TYPE. MDL will treat Iype just like the TYPE given as how. how must have the same
TYPEPRlH25fyp&
If how is applicable. it will be used itt the following way:
6.4.3 - 6.4.4 Data Type:



age
E is
and
her
lied
Ted
my
not
The MDL Prngraniming Language 49
for PRINTIYPE. how should lake one argument: the object being output. how should output
gqllltlillllg witlpnlll formatting (PRINI-style): its result is ignored. (Note: how cannot use an output
SUBR on Ivan/5 nwn r_tpi_>: endless recursion will result. OUTCHAN is bound during the application to
the CHI\llllEL in use. nr In .1 pseudo-internal channel for FLATSIZE - chapter ll.) If how is the SUBR
PR1Nr_ ;_,;.~¢- will receive no special lrealuient in printing. that is. it will be printed as it was in an
initial l\ll)L or immediately after ils defining NEHTYPE.
For EVALTYPE. how should take one argument: the object being evaluated. The value returned by
how will be uml as EVAL of the object. ll‘ haw is the SUBR EVAL, lype will receive no special
treatment in cvalnaiinri.
For APPLYIYPE. row should lake at least one argument. The first argument will be the object being
applied: the rt-st will he the objects it was given as arguments. The result returned by how will be
used as the result of the application. If how is the SUBR APPLY, lype will receive no special
lreatinenl in applicnlinn Io arguments.
If any of lhcse SUBRs is given only one argument. that is if how is omitted. it returns the currently
active how la TYPE or an applicable object). or else IFALSE () if type is receiving no special
lrealnient in that operation.
Unfortunately. these examples are fully understandable only after you have read through chapter ll.
(DEFINE RON/\N-PRINT (NUHB)
(COND (<0R <L=? .llUMB 0) (G? .NUHB 3999))
(PRINC <CHTYPE .NUl1B TIHE>))
(T
<RCPR1NT </ .uuus 1ooo> ~![s\r11>
<RCPRIllT </ mums 1oo> -s[!\c s\n z\n]>
uzcmru <1 .uur1a 10> -![!\x !\L !\c]>
uzcwunr .~uns '![l\I s\v !\x]>)>>s
ROMAN-PRINT
(DEFINE RCPRINT (MOON V)
(SET MODN (HOD .l1O0N 10)
)
<C0liD (<==? 0
(<==? l
-to (<==?
vpe. (<==?
(<==?
(<==?
((::
(<==? 7
ame (<==? B
<PRIliC
(PRINC
'ﬂ
m m a w N
rpea
.l10Dli>)
.HODll> <PRIHC <1
.HODll) (PRINC (1
.HODN> <PRINC (1
.HOOll> <PRINC (1
.HODN) (PRINC (2
.MODN) (PRINC <2
.HODN> (PRINC (Z
.l‘l0Dll)
(2 .V>>
(1 .V>>
V)))
V)) (PRINC (1
V>) <PRINC <1
V)) (PRINC (Z
V»)
.V>) (PRINC <1
V)) (PRINC (1
6.4.4
V>>)
V)> <PRINC (1 .V>>)
V)))
V»)
.V>) (PRINC (1 .V>))
Data Types



The MDL Programming Language
(PRINC <1 .V))
<PR1NC <1 .V)))
(<==? 9 .HODN> <PRINC (I .V)> (PRINC (3 .V)))>>$
RCPRINT
<PRINIIYP£ TIME FIX) ;"fair1y harmless but necessary hera'S
TIME
<PRINTIYPE FIX ,ROHAN-PRINT) ;'hee hee!'S
FIX
<+ 2 2>$
IV
19845
HCHLXXXIV
<PRINTIYP£ FIX ,PRINT>$
FIX
<NENIYPE GRITCH LIST) ;'a new TYPE of PRIHTYPE LIST'$
GRITCH
(EVALTYPE GRITCH>S
#rALSE ()
<F.VALTYPE GRIICH LIST) ;'evaluated like a LIST'$
GRITCH
<EVALTYPE GRITCH)S
LIST
HGRIICH (A <+ 1 2 3) !<SET A 'ABC'>) ;'Type in one.'S
iGRITCH (A 6 !\A !\8 !\C)
<NEVTYPE HARRY VECTOR) ;'a new TYPE of PRIHTYPE VECTOR'$
HARRY
(EVALTYPE HARRY IFUNCTION ((X) (1 .X)))
;"Hhen a HARRY is EVALad, return its first alement.'$
HARRY
ammnv [1 2 3 4]:
I
<NEwTYPE WINNER LIST) ;'a TYPE with funny app11cat1on'$
WINNER
<APPLYTYP£ VINNER>S
IFALSE ()
<APPLYTYPE WINNER (FUNCTION (H 'TUPLE' I) (!.V !.T)>)$
WINNER
<APPLYTYPE VINNER>$
druNCTION ((V 'TUPLE' T) (!.H !.T))
<ﬂHINNER (A B C) <+ I 2) q>$
(A B C 3 0)
Q44
Daaljpu



The MDL Programming Language
51
The following sequence makes MDL look just like Lisp. (This example is understandable only if
you know Lisp (Moon. 1974): it is included only beuuse it is so beautiful.)
So now:
(EVALTYPE LIST FORPDS
LIST
<EVALTYPE ATGT ,LVAL)$
ATOH
(0 l 2)!
3
(SET ‘A 5”
5
AS
5
To complete the job. of course. we would have to do some SETS‘: car is 1, cdr is ,REST, and
lambda is ,FlINCTION. If you really do this example. you should "undo' it before continuing:
<EVALTYPE ‘ATOM ,EVAL>S
ATDH
<EVALTYPE LIST ,EVAL)$
LIST
5.4.4 Data Types



52 The MDI. Programming Language 
Chapter '7. Structured Objects ‘
This chapter discusses structured objects in general and the five basic structured PRIHTYPB. [We
defer detailed discussion of the structured PRIHTYPEs TUPLE (section 9.2) and STORAGE (section
22.2.21]
7.l. Manipulation
The following SU8Rs operate uniformly on all structured objects and generate an error if not
applied to a structured object. Hereafter. structured represents a structured object.
7.l.l. LENGTH ll]
<LENGTH structured)
evaluates to the number of elements in structured.
7.l.2. NTH [I]
(NIH structured fix)
evaluates to the tixth element of structured. An error occurs if lix is less than 1 or greater than
<LENGTH structured). fix is optional. l by default.
7.1.2. REST tn
(REST structured fix)
evaluates to structured without its first fix elements. fix is optional, I by default.
Obscure but important side effect: REST actually returns structured 'CHTYPErl' (but not through
‘I - 7.l.3 Structured Objects
t



l
l
<
4
F
t
I
l
~
l
l l
l
3
2
The MDL Progrmntning Language 53
;pplication of CHTYPE) to its PRIMTYPE. For example, REST of a FORH is a LIST. REST with an
explicit second argntnent of 0 has no effect except for this TYPE change.
7.I.-‘I. PUT [l]
(PUT structured Iix anything—Iegal)
first nt:tl.cs .=tn_-,tt1In;f-/051.1! the Ii:-1h element of structured. then evaluates to structured. anytht'ng~Iegal
is anything which can legally be an element of structured} often. this is synonymous with ‘any MDL
object". hnt sec below. An error occurs if fix is less than l or greater than (LENGTH structured).
(PUT is actually more general than this -~ chapter I3.)
7.|.5. GET
(GET structured fix)
evaluates the saint‘ as <NTt<l struttured ﬁx). lt is more general than NTH, however (chapter 13). and
is incltttlml here only for sytnntelry with PUT.
7.l.6. APPLYing a FIX [I]
EVAL nnderstantls the application of an object of TYPE FIX as a 'shorthand" call to NTH or PUT,
depending on whctltcr it is given one or two arguments. respectively {unless the APPLYTYPE of FIX is
changed]. That is. [VAL considers the following two to be identical:
(fix structured)
<NTH structured fix)
and these:
(ﬁx structured Object)
(PUT structured lix object)
[l*lowever. the cntnpiler (Lehling. 1979) cannot generate efficient code from the longer forms unless
it is stlrc that In is a FIX (section 9.l0). The two constructs are not identical even to EVAL, if the
order of evaluation is signiﬁcant: for example. these two:
<NTH .X (LENGTH (SET X .Y>>> <(LENGTH (SET X .Y>> .X)
are E identical]
7.l.3 - 7.l.6 Structured Objects



54 The MD]. Programming Language
7.l.7. SUBSTRUC
SUBSTRUC ("sttbstrnrtnre") facilitates the construction of structures that are composed of sub-parts of
existing structures. A special case of this would he a 'substring' function.
<SUl3STRllC ham.-structured res|:!ix amounhlix Imstruclured)
copies the first art-at/tn‘ elements of (REST from res!) into another object and returns the latter. All
arguments are ﬂ|)liﬂll7l| except from. which tnnst be of PRIHTYPE LIST. VECTOR. TUPLE (treated like
a VECTOR). STRING. BYIES, nr UVECTOR. res! is 0 by default. and amount is all the elements by
default. to. if given. receives the copied elements. starting at its beginning: it must be an object
whose TYPE is the PRIHTYPE of I.-om (a VECTOR if from is a IUPLEI. if to is ttot given. a new object is
returned. of TYPE <PRIHTYPE !rOm> (a VECTOR if from is a TUPLE). which Lt/et' shares with from.
The copying is done in one fell swoop. not an element at a titne. Note: due to an implementation
restriction. if /rant is of PRIHTYPE LIST, it must not share any elements with lo.
7.2. ReggsLent__a_tinti of llasic Structures
7.2.]. L151 [I]
( element-I e/emenl-Z  element-N )
represents a LIST of Nelements.
7.2.2. vzctotz [t]
[ elemenl -1 e'!cmenI—2 . . . elemenl-N ]
represents a VECTOR of Nelentents. [A TUPLE is just like a VECTOR, but it lives on the control stack]
7.2.5. uvecton [1]
![ elen-en!-1 element-2  element-N !]
represents a UVECTOR (ultifnrtn vector) of N elements. The second ! (exclamation-point) is optional
for input. [A STORAGE is an archaic kind of UVECTOR that is not garbage-oollected.]
7.l.7 - 7.2.3 Structured Objects



iage
s of
All
like
5)’
ject
:t is
ram.
tion
ck.]
anal
The MDL Programming Language 55
7.2.4. strum: [ll
"<haracters"
represents a STRING of ASCII text. A STRING containing the character ' (double-quote) is
fgprtstllled by placing a \ (backslash) before the double-quote inside the STRING. A \ in a STRING
is represented by |\vo consecutive hackslashes.
7.2.5. BYTES
ﬁn (e/empnf-I element-2 . . . e/emen!-N)
represents a string of N uniformly-sized bytes of size n bits.
7.2.5. TEHPLME
( element-1 element-2  e/amen!-N }
represents a TEMPLATE of N elements when output. not input - when input. a I and I TYPE "H15!
precede it.
7.3. Evaluation nf Basic Structures [I1
This soctinn and the next two describe how EVAL treats the basic structured TYPEs [in the absence of
any nlmlifying EVALTYPE calls (section 64.4))
EVAL of a STRING [or BYTES or TEHPLATE] is just the original object.
EVAL acts exactly the same with LISTs. VECTORs. and UVECTORs: it generates a new object with
elements equal to EVAL of the elements it is given. This is one of the simplest means of
constructing a structure. However. see section 7.7.
7.4. Examples [l|
(l 2 (+ 3 4>)S
(l 2 7)
(SET FOO [5 (- 3) (TYPE "ABC'>]>S
[5 -3 STRING]
(2 .F0O)$
E“ 7.2.4 - 7.4 Structured Objects



56 'l'he MDT. Programming Languagg
-3 t
(TYPE <3 .F00>)$
ATOM
(SET BAR ![("meow") (.F0O)])S
![("nleow") ([5 -3 STRING])l]
(LENGTH .BAR>S
2
(REST (l (2 .BI\R>)>$
[-3 STRING]
[<SUBSTRUC (1 (Z .BAR)) 0 Z)]$
[[5 -3]]
(PUT .l-'00 l SNE!\KY> ;'llat.ch out for .BAR !"$
[SNEAKY -3 STRING]
.BAR$
'[("menw") ([SN[AKY -3 STRING])!]
(SET FOO (REST (1 (l .BAR)> 2>)S
now!
.BARS
![('rneow") ([SNFAKY -3 STRINBDI]
7.5. Generation of llasic Structures
Since LISTs. VECTORs. UVECTORs. and STR1N8s [and BYTESes] are all generated in I fairly uniform
manner. lll('l|l0d$ of generating them will be covered together here. lTEHPLATEs cannot be generated
by the interpreter itself: see lebling (l979l]
7.5.l. Direct Represclttatiotl [I]
Since EV!\L of a LIST, VECTOR, nr UVECTOR is a new LIST, VECTOR, or UVECTOR with elements which
are EVAL nf the nriginal cletncnts. simply evaluating a representation of the object you want will
generate it. (Care nmst be l3k¢|\ when representing a UVECTOR that all elements have the same
TYPE.) This metliml of generation was exclusively used itt the examples of section 7.4. Note that
new STRING‘: [and BYTESes] will not be generated in this manner. since the contents of a STRING are
not interpreted nr cnpicd by EVAL. The same is true of any other TYPE whose TYPEPRIH happens to
be LIST. VFCTOR. or UVECTOR (again. assuming it neither has been EVALTYPEd nor has a built-in
EVALTYPE, as do FORM and SEGMENT].
7.5.2. QUOTE [I]
QUOTE is an FSUBR of one argument which returns its argument unevaluated. READ and PRINT
7.4 - 7.5.2 Structured Objects



orm
tted
tith
will
tme
hat
are
s to
t-in
INT
acts
l
W
it
1
t
The MDL Prngratntuing Language 57
understand the character ' (single-quote) as an abbreviation for a call to QUOTE, the way period and
comm; work for LVAL and GVAL. Examples:
<+ l Z>$
3
'<+ l Z>S
<¢ 1 2>
Any LIST, VECTOR, or UVECTOR in a program that is constant and need not have its elements
evaluated should he represented directly and inside a call to QUOTE. This technique prevents the
structure from being copied each time that portion of the program is executed. Examples hereafter
will adhere tn this dietitian. (Note: one should never modify a OUOTEcl object. The compiler will one
day put it in read-only (pure) storage.)
7.5.3. LIST, VECTOR. UVECTOR, and STRING (the SUBRs) [I]
Each of the Stlltks LIST, VECTOR. UVECTOR, and STRING takes any number of arguments and
returns an nbject of the appropriate TYPE whose elements are EVAL of its arguments. There are
limitations on what the arguments to UVECTOR and STRING lnay EVAL to. due to the nature of the
objects generated. Sec sections 7.6.5 and 7.6.6.
LIST, VECTOR, and UVECTOR are generally used only in special cases. since Direct Representation
usually produces exactly the saute effect (in the absence of errors). and the intention is more
apparent. [Nmt-: if .L is a LIST, (LIST !.L> makes a copy of .L whereas (!.L) doesn't: see section
7.7.] STRING, on the other hand. produces effects very different from literal 5TRINGs.
Examples:
<LISl I (4 2 3) ABC>$
(1 5 ABC)
(l (v Z 3) ABC)$
(l 5 ABC)
(STRING "A" <2 "OHERT') (REST "ABC"> 'hello">S
"AVBChello‘
‘A (+ 2 3) (5)"$
‘A <~ 2 3) (5)"
7.5.4. ILIST. IVECTOR. IUVECTOR, and ISTRING [I]
Each of the SUBRs ILIST, IVECTOR, IUVECTOR, and ISTRING ("implicit' or ‘iterated’ whatever)
creates and returns an object of the obvious TYPE. The formal of an application of any of them is
( Ifhing number-Of-elemenfs:/ix expressiomany )
7.5.2 - 7.5.4 Structured Objects



58 The MDL Programming Language
where lilting is one of ILIST, IVECTOR. IUVECTOR, or ISTRING. An object of LENGTH number—of-
elements is generated. whose elements are EVAL of expression.
expression is optional. Wltcn it is not specified. ILIST. IVECTOR, and IUVECTOR return objects
filled with nhjrrts nf TYPE LOSE (PRIHTYPE HORD) as place holders. a TYPE which can be passed
around and have its IYPE checked. but otherwise is an illegal argument. if expression is not
specified in ISTRING, you get a STRING made up of “B characters.
When E\prt_*.*-.410» is supplird as an argument. it is re-EVALuated each time a new element is
generated. (Arttntlly. E\II\L of cxprcsston is re-EVALuated. since all of these are SUBRs.) See the last
example for hnw this argument may be used.
[By the way, in .1 cmtstrttct like <IUVECTOR 9 '.X>, even if the LVAL of X evaluates to itself. so that
the ' could be omitted without changing the result. the compiler is much happier with the ' in
place]
IUVECTOR and ISIRING again have limitations on what expression may EVAL to; again. see sections
7.6.5 and 7.6.6.
Exam p lcs:
<ILIST 5 6>$
(6 6 6 6 6)
<IVl'.CTOR 2>S
[HOSE *000lJ00000000" ILOSE "0000U00000O0']
<st:t A o>s
o
<IUVECTOR 9 -<sst A <¢ .A 1>>>s
![l23456789!]
7.5.5. FORM and IFORH
Sometimes the ltcetl arises tn create a FORM without EVALing it or making it the body of a FUNCTION.
In such cases the Sllllils FORM and IFORH ("implicit form’) can be used (or QUOTE can be used). They
are entirely analogous to LIST and ILIST. Example:
(DEFINE INC-FORM (A)
(FORM SET .A (FORM + 1 (FORM LVAL .A>)>>$
INC-FORI1
(INC-FORM FO0)$
(SET F00 (0 l .FOO>)
7.5.4 - 7.5.5 Structured Object:
t
l
F
l
t
i
i
l
i
i
1
l
t
A
F
-._.___,;
__.rx..'
l
t
T
7.*
7.
A
tn
L
ot
7.
cl
tl
E1
P
P
<
7
(
t
I
I
 i



uage
-r—0!-
-jects
assed
. not
nt is
: last
Ilhll
' in
tions
"ION .
They
ajecu
The MDL Prngratnming Language 59
76. UnirLu§Prop_e_rQes of Primitive TYPEs
. Z6J.LISl(thePRIHTYPE]H]
‘ An object of PRIHTYPE LIST may be considered as a "pointer chain" (appendix I). Any MDL object
may be an cletttettt of a PRIHTYPE LIST. It is easy to add and remove elements of a PRIHTYPE
1 U51, but the higher N is. the longer it takes to refer to the Nth element. The SU8Rs which work
i only on objects of PRIMTYPE LIST are these:
7.G.l.l. PUTREST [I]
<PUTREST head.-pnmlype-/is! fail:prim!ype-list)
L
1 ¢|,;"g¢-5 head ﬁn that (REST head) is fail (actually <CHTYPE tail LISl'>). then evaluates to head. Note
- that this actually changes headt it also changes anything having head as an element or a value. For
" example:
I <s£t now [<s£t ARF (B v)>]>t
[(3 ")1
y <PUTREST .ARF '(3 4)>s
l to 3 4)
‘ .novs
f [ta 3 4)]
t PUTREST is probably most often used to splice lists together. For example. given that .L is of
PRIHTYPE LIST. to leave the first m elements of it intact and take out the next n elements of it,
<PUTREST (REST .L (- m 1)) (REST .l. (+ m n))>. Specifically,
; <s&r nuns (1 2 3 4 5 6 1 a 9)>s
} tt 2 a 4 s 6 1 a 9)
1 <PUlREST (REST .uuns a> <asst .uuns 7>>s
y (4 a 9)
t .NUH$$
~ <1 2 3 4 a 9)
t
_ 7.6.1.2. CONS
l
1
(CONS new (is!)
("construct") adtls new to lhe from of Iisl. without copying Iisl. and returns the resulting LIST.
1 References to list‘ are not affected.
[Evaluating (CONS .E .LIST> is equivalent to evaluating (.E !.LIST) (section 7.7) but is less
' Preferable to the compiler (Lebling. l97£I).]
i
H 7.6 - 7.6.l.2 Structured Objects
1 t



60 The MDL Programming Lingtligg
7.6.2. "Array" PRIHTYPEs [I]
VECTORs. UV[CTORs. and STRINGs [and BYTESes and TEHPLATEs] may he considered as ‘arrays’
(appendix t). It is easy to refer to the Nth element irrespective of how large N is. and it is
relatively difficult to add and delete elements. The following SUBR.s can he used only with an object
of PRIHTYPE VECTOR, UVECTOR, or STRING [or BYTES or TEMPLATE]. (ln this section array represents
in object of such a PRIHTYPE.)
Z62J.BACK[H
(BACK array fix)
This is the opposite Ill’ REST. lt evaluates to array. with fix elements put back onto its front end,
and changed to its PRIHTYPE. hx is optional. 1 by default. lf ﬁx is greater than the number of
elements which have been RESTcd off. an error occurs. Example:
<ssr zov <nesr 't[1 2 a 4] s>>s
![a!]
(BACK .zor 2>s
![2 3 4!]
<ssr s <nssr ‘Right ls might.‘ ts>>s
II
<8ACK .s 6>s
'mlght.'
le2z.roP[n
<10? array)
"8ACKs up all the way" -- that is, evaluates to array. with all the elements which have been RES'l’ed
off put barl onto it. and changed to its PRIHTYPE. Example:
(TOP .ZOP>$
![l 2 3 4!]
7.6.3. 'Vector' PRIﬂTYPEs
7.6.3.1. snow
(GROW vu end:!ix beg:l1x>
adcls/removes elements to/from either or both ends of vu, and returns the entire (TOPped) resultant
object. vu can be of PRIHTYPE VECTOR or UVECTOR. end specifies a lower bound for the number of
7.6.2 - 7.6.ll Structured Objects



B‘-'18
rrays‘
it ' ‘
abjece
esenu
t end.
oer of?
.ESTed
ultant
ber of
bjecta
L
l
l
i
L
-
1
i
1
l
1-he MD], I"rogratnn|i||g Language 6|
elem;-"ts tn be added to the ell of vtr. beg specifies the same for the beginning. A negative fix
wccifics removal of clcmcnts.
The nnnther of elements added to each respective end is end or beg increased to an integral multiple
qf x. where X is 32 for PRIHTYPE VECTOR and G4 for PRIMTYPE UVECTOR (1 produces 32 or 64: -l
produces 0)- The clcntcnts added will be LOSEs if vu is of PRIHTYPE VECTOR, and "empty" whatever~
they-are's it vu is nf PRTHTYVE UVECTOR. An "empty" object of PRIHTYPE WORD contains zero. An
-empty" object of any other PRIHTYPE has zero in its "value word’ (appendix l) and is not safe to
p|;y with: it should be replaced via PUT.
Note l|t.1l. if c-Ienients are added to the beginning of vu, previously-existing references to vu will
have to use TOP or BACK to get at the added elements. '
Caution: GROW is a vcry expensive operation: it rcguires a garbage collection (section 22.4) every
time it is used. It shnuld he reserved for very special circumstances. such as where the pattern of
shared elements is terribly important.
Example:
(SET A '![l])$
![l!]
(GROW .A 0
c>o--
:Q¢';
@QQ
@QQ
CQQ
QQQ
.-
oocv
coo“
coo
QQQ
@$Q
O00
@C)Q
QOQ
¢§@
QQQ
@Q§
¢Q§
QQQ
Q63
QQQ
h-IQ¢
C.
![ l ! ]
7.6.3.2. SORT
This SUBR will sort PRIMTYPEs VECTOR, UVECTOR and TUPLE (section 9.2). lt works most
ff. .
e tciently if the sort keys are of PRIHTYPE HORD, ATOM or STRING. However. the keys may be of
any TYPE, and SORT will still work. SORT acts on fixed-length records which consist of one or more
contiguous elements i|t tl ' '
te structure being sorted. One element in the record ls declared to be the
sort key. Also. any number of additional structures can be rearranged based on how the main
structure is sorted.
(SORT prod sl ll all s2 I2 s3 I3  sN IN)
Where:
Wed is either (see chapter 8 for information about predicates):
ll) TYPE FALSE, in which case the TYPEs of all the sort keys must be the same; they must be of
PRIHTYPE WORD, STRING or ATOM; and a radix-exchange sort is used: or
7.6.3.l - 7.6.3.2 Structured Objects



62 The MDT. Programming Language
(2) something applicable to two sort keys which returns TYPE FALSE if the first is not bigger
than the srrmtd. in whirlt case a shell sort is used. For example ,6? sorts numbers in ascending
order. .L? in descending order. Note: if your pred is buggy. the SORT may never terminate.
sl . . . sN arc the (PRIHTYPE) VECTORs. UVECTORs or TUPLEs being sorted. and sl contains the sort
keys:
I! . . . /N are the corresponding lengths of sort records (optional. one by default): and
off is the offset from start of record to sort key (optional. zero by default).
SORT returns the sorted sl as a value.
Note: the SUBR SORT calls the RSUBR (chapter l9) SORTX; if the RSUBR must be loaded. you may see
some output front the loader on your terminal.
Examples:
(SORT (> (SET A <IUVECTOR 500 '(RMlDOH))))$
![ . . . !]
sorts a UVECTOR of random integers.
(SET V [1 HONEY Z SHOH 3 READY 4 GODS
[...]
(SORT () .V 2 17$
[4 GO l HONEY 3 READY 2 SHOW]
(SORT ,L? .V Z)!
[4 GO 3 READY 2 SHOV l HONEY]
.VS
[4 GO 3 READY Z SHOV 1 HONEY]
(SORT () ![2 ll365B7]l0.V)S
![lZ34567B!]
.V$
[GO 4 READY 3 SliO\rI Z HONEY I]
The first snrl was based on the ItTOHs' PNAHEs. considering records to be two elements. The second
one sorted based on the FIXcs. The third interchanged pairs of elements of each of its structured
arguments.
7.6.3.2 Structured Objects
i
l
int; 4435'-
1 l
l
_€
r
l
I
t
1
\



uage
gger
alittg
$011
SC!
ind
red
Q18
The MDL Prograuiining Language 63
1.6.4. vsctotz (the mzmtvrml ill
Any MDL object may be an element of a PRIHTYPE VECTOR. A PRIHTYPE VECTOR takes two words
of ‘M-age more than an er|nivalent PRIHTYPE LIST, but takes it all in a contiguous chunk. whereas
a PRIHTYPE LIST may be physically spread out in storage (appendix 1). There are no SUBlLt or
|:5uBR; which operate only on PRIHTYPE VECTOR.
7.6.5. UVECTOR (the PRIMTYPE) [I]
The difference between PRlHTYPEs UVECTOR and VECTOR is that every element of a PRIHTYPE
UVECTOR must be of the same TYPE. A PRIHTYPE UVECTOR takes approximately half the storage of
1 PRIHTYPE VECTOR or PRIHTYPE LIST and. like a PRIHTYPE VECTOR. takes it in a contiguous chunk
(appendix ll.
[Notez due to an implementation restriction (appendix I). PRZHTYPE STRINGs. BYTESes. LOCDs
(chapter I2). and objects on the control slack (chapter 22) may n_ot be elements of PRIHTYPE
UVECTORs.]
The "same TYPE" restriction causes an equivalent restriction to apply to EVAL of the arguments to
either of the SUI3Rs UVECTOR or IUVECTOR. Note that attempting to say
![1 .A!]
will cause READ to produce an error, since you're attempting to put a FORM and a FIX Into the same
UVECTOR. On the other hand.
(UVECTOR 1 .A>
is legal. and will EVAL to the appropriate UVECTOR without error if .A EVAl.s to a TYPE FIX.
The following SU8Rs work on PRIHTYPE UVECTORs alone.
7.6.5.l. UYYPE [I]
<UTYl"E primfype-uvecl‘or>
(-""if°""l l)'PP') evaluates to the TYPE of every element in its argument. Example:
<UTYPE '![A B C])$
ATOH
7.6.4 - 7.6.5.1 Structured Objects



64 The MDI. Programming Language
7.6.5.2. cnutvrtt [t]
<CHUTYPE uwprintlype-uveclor type)
("change unifortn type") changes the UTYPE of uv to type. simultaneously changing the TYPE of all
elements of uv. and returns the new. changed, uv. This works only when the PRIHTYPE of the
eletncnts of u\' can remain the same through the whole procedure. (Exception: a uv of UTYPE LOSE
can be CttUTYt‘Ed to any Iype (legal in a UVECTOR of course): the resulting elements are ‘empty’. as
for GROW.)
CHUTYPE actually changes uv: hence Q references to that object will reflect the change. This is
quite different from CIITYPE.
Examples:
(SET LOST <1UVECTOR 2>)S
![il0SF *O00000000O00* ILOSE '000D00000000'!]
<UTYPE .LOST>$
LOSE
(CHUTYPE .LOST f0RH)$
![<> <)!]
.LOST
![<) <>!]
(CHUTYPE .LOST LIST)$
![l) ()!]
7.6.6. STRING (the PRIHTYPE) and CHARACTER [I]
The best mental image of a PRIHTYPE STRING is a PRIHTYPE UVECTOR of CHARACTER; - where
CHARACTER is the MDL TYPE for a single ASCII character. The representation of a CHARACTER, by
the Way. is
!\an_t'-ASCII-rltaracfer
That is. the elm-actors !\ (exclamation-point backslash) preceding a single ASCII character
represent the corresponding oltject of TYPE CHARACTER (PRIHTYPE HORD). (The characters !'
(exclamatirnt-point tlnnhlc-qttote) preceding a character are also acceptable for inputting I
CHARACTER, for historical reasons.)
The SUBR ISTRING will produce an error if you give it an argument that produces a non-
CHARACTER . STRING can take either CHARACTER.s or STRINGA.
There are no SUttRs which uniquely manipulate PRIHTYPE STRIN6s, but some are particularly useful
in connection with them:
7.6.5.2 - 7.5.6 Structured Objectt
>
At; _. ._r A
t
l
it
I
t
l
t
I
1
{I
t
1'
7.
ll
at
[I
ft
7.|
PI
ot
re
[S
7.1
LF
L1
FE?
7.6
UN
re|
[H
261
IISI
7.6
A
36
STI



uage
f all
the
LOSE
", as
is is
here
. by
tCl€l'
. ! '
g a
non-
eful
ieets
i
 - _....?-_...._
The MDL Programming Language 55
7.6.6.1. ASCII [ll
< ASC II !l.\'-0!-C/IR! acler)
If its argument is of TYPE FIX, ASCII evaluates to the CHARACTER with the 7-bit ASCII code of its
argument. Exaniple: (ASCII 65> evaluates to !\A.
If its argnntent is or TYPE CHARACTER, ASCII evaluates to the FIXed-point number which is its
;|-gun\ent's 7-bit ASCII code. Example: (ASCII !\Z) evaluates to 90.
[Actnally. a FIX can he CtlTYPEd to a CHARACTER (or vice versa) directly. but ASCII checks in the
former case that the FIX is within the permissible range.)
7.6.5.2. PARSE [I]
(P/\RSF sfrrrn; radix’:/hr)
PARSE applies tn its argument READ's algorithm for converting ASCII representations to MDL
objects and returns the E object created. The remainder of string. after the first object
represented. is ignored. r.=.di.\- (optional. ten by default) is used for convening any FIXes that occur.
[See also sections l5.7.2 and l7.l.3 for additional arguments]
7.6.6.3. LPARSII [I]
LPARSE ("list parse") is exactly like PARSE (above). except that it parses the entire string and returns a
LIST of :1 objects created. If given an empty STRING or one containing only separators. LPARSE
returns an empty LIST, whereas PARSE gets an error.
7.s.s.4. untmnsa [t1
(UN?/\RS[ any radix:!ix)
UNPARSE applies to its argument PRINT's algorithm for converting MDI. objects to ASCII
representations and returns a STRING which contains the CHARACTERs PRINT would have typed out.
[I-lowet-er. this STRING will gm contain atty of the gratuitous carriage-returns PRINT adds to
accomntntlnte a CHI\HNEL's finite line-width (section ll.2.8).] radix (optional, ten by default) is
used for cmtvertittg arty FIXes that occur.
7.5.7. B Y IE5
A (PRIHTYPE) BYTES is a string of uniformly-sized bytes. The bytes can be any size between I and
35 bits inclusive. A llYTES is similar in some ways to a UVECTOR of FIXes and in some ways to a
STRING of non-seven-bit bytes. The elements of a BYTES are always of TYPE FIX.
7.6.6.1 - 7.6.7 Structured Objects



66 Tlte MDL Programming Languagg
The SUBRs BYTES and IBYTES are similar to STRING and ISTRING, respectively. except that each of
the former takes a first argument giving tlte size of the bytes in the generated BYTES. BYTES take;
one reqttireti argument which is a FIX specifying a byte size and any number of PRIHTYPE HORD;
It relttrns an nlijc-ct of TYPE BYIES with that byte size containing the objects as elements. These
objects will be /\HDBed with the appropriate mask of l-bits to fit in the byte size. IBYTES takes two
required l'IXes and one optional argument. ll uses the first FIX to specify the byte size and the
second to specify the ntttnber of elements. The third argument is repeatedly evaluated to generate
FI)<es that hecntne elements of the BYTES (if it is omitted. bytes filled with zeros are generated). The
analog to UTYPE is BYTE-SIZE. Examples:
<BYT[$ 3 (+ 2 ?> 9 -l>$
93 (4 l 7)
(SET A 0>$
0
(IBYTES 3 9 ‘(SET A <0 .A 1»)!
.i3(l23456701)
<IBYTES 3 4)!»
'3(0000l t
(BYTE-SIZE <BY'l'ES l)>$
I
7.6.8. TEMPLATE
A TEMPLATE is siniilar to a PL/l "structure' of one level: the elements are packed together and
reduced in size to s:tvc storage space. while an auxiliary internal data structure describes the
packing fm-nt.1t and the eletnt'ttts' real TYPEs (appendix 1). The interpreter itself is not able to create
objects of PRIMHPE TEHPL/\1E (Lebling. I979): however. it can apply the standard built-in
Subroutines to them. with the same effects as with other 'arrays".
7.7. SEGllEllTs ll
Objects of TYPE Si GHHH (whose TYPEPRIH is LIST) look very much like FORMs, SEGMENTs. however.
undergo a ttnn-statidard evaluation designed to ease the construction of structured objects from
elements of other structured objects.
7.7.1. Reprewntatiott [l]
The rrpresetttntiott nt‘ an object of TYPE SEGMENT is the following:
‘< rum: arg-1 art-:-2 ... arg-N !)
7.6.7 - 7.7.l Structured Objects



{MIG 11,, MDL Vrngrantttting Language 67
ch “I where the second ! tcxclamatiott-point) is optional. and lune and arg-I through erg-N are any legal
‘aka constituents of a FORM (that is. anything). The pointed brackets can he implicit, as in the period
'°RD5\- and comma notation for LVAL and GVAL.
These,
“"°'* AllofthefnH0wingareSEGHENB:
d the
teratei !<3 .F0O> !.F0O !,roo
The
7.7.2. Evaluation [l]
A SEGMENT is r:v.-tlltatezl in exactly the saute manner as a FORM, with the following three exceptions:
(l) ll had hotter he done inside an EVAL of a structure: otherwise an error occurs. (See special
case of FORH\ in section 7.7.5.)
(2) lt had better EVAL to a structured object: otherwise an error occurs.
(ill What actually gets inserled into the structure being built are the eletnems of the structure
1 returned hy the FORM-like evaluation.
7.7.3. Examples [I]
<sst zov -![2 3 4]>s
r ![2 a 4!]
and t (SET ARF (B 3 4)>$
* \"= ta 3 4)
relte (.ARF !.ZOP)S
"14" V (ts 3 4) 2 3 4)
' ![!.ZOP !<aesr .ARF>!]$
trz a 4 a 4-1
! (SET S "STRUNG.">$
"STRUNG.'
(!.S)$
ever. (!\S !\T !\R !\U l\N !\G !\.)
from
(SET NIL ()>$
U
[!.NIL]$
[1
j¢¢ll \ 7.7.l - 7.7.3 Structured Objects



68 The MDL Programming Llﬂglllgg
7.7.4. Note nu Efficirttcy [I]
Most of the cases in which it is possible to use SEGHENB require EVAL to generate an entire neg
object. Naturally. this uses up both storage and time. However. there is one case which it 1;
possible tn hatuilo without copying. and EVAL uses it. When the structure being built is a PRIHTYPE‘
LIST, and the segtuettt value of a PRIHTYPE LIST is the last (rightmost) element being concatenateqj, ‘
that last PRIHTYPE LIST is not copied. This case is similar to CONS and is the principle reason why‘
PRIHTYPE LISTs have their structures more easily varied than PRIHTYPE VECTOR or UVECTOR. ‘H
Examples: ]
.ARl-"S ‘
(8 3 4)
This does not copy ARF :
(l 2 !.I\RF)$
(12 B 3 4)
Tits! do:
(l !.I\RF 2) ;'not ‘last olenent"$
(l B 3 4 Z)
[1 2 !.ARF] ;'not PRIHTYPE LIST'S
[1 2 B 3 4]
(1 2 !.ItRF !<REST '(l)>) ;'stl\l not last element“ '
(1 2 B 3 4) ‘
r
Note the following. which occurs because copying does wake place: ‘
(SET DOG (A !.ARF))S
(A B 3 4) I
(PUT .ARF 1 'BOUOH')$
('BOHOU" 3 4)
.0063
(A ‘8OUOV' 3 4)
(PUT .DOG 3 ‘VOOF‘>S
(A "BOHOU' ‘HOOF" 4)
.ARFS ‘
('BOUON‘ 'UO0F' 4)
Since ARF was not cnpicd. it was literally part of DOG. Hence. when an element of ARF was changed.
DOG t-.-as rltattgcd. Similarly. when an element of DOG which ARF shared was changed. ARF was
changed too.
7.7.4 Structured Objects
,.
 



‘Q
EH
I t
PE
=a.
hr
ged.
was
1'||e MDL Programming Language 69
1_7.5. SEGHENls in Foam [l]
whm a SEGMENT appears as an element of a FORM, the effect is approximately the same as if the
elements of [VAL of the SEGMENT were in the FORM. Example:
(SET A '![l 2 3 4])$
![l 2 3 4!]
(4 !.l\ 5)$
15
Note: the elements of the structure segment-evaluated in a FORM are _t1gt_ re-evaluated if the thing
being applifti is a SUBR. Thus if .A were (l Z <~ 3 4) 5), the above example would produce an
error: you ean‘t arid up FORMs.
You could perform the same suuunatiou of 5 and the eletnents of A by using
<EVl\L (CHIYPE (+ !.A 5) FORM»
(Note that [VAL must be explicitly called as a SUBR; if it were not so called. you would just get the
FORM <+ l Z 3 4 5> -- not its "value'.) However. the latter is more expensive both in time and in
storage: when you use the SEGMENT directly in the FORM, a new FORM is. in fact. Egenerated as it is
in the latter case. (The elements are put on "the control stack" with the other arguments.)
7.8. Self-refcrcltcittg Structures
It is possible for a structured object to "contain" itself. either as a subset or as an element. as an
element of a stnlclured element. etc. Such an object cannot be PRINTed. because recursion begins
and never terminates. Warning: if you try the examples in this section with a live MDL. be sure
you knew how to use ‘*5 (section 1.2) to save PRINT from endless agony. (Certain constructs with
ATOMs can give PRlNT similar trouble: see chapters I2 and I5.)
7.8.l. Self-subset
( P U TRES T head:primI ype-list Iaihprimiype-Iisf)
If head is a subset of rgil. that is. if (REST tail ﬁx) is the same object as (REST head 0) for some fix,
then both head and fail will he 'circt|lar' (and thus self-referencing) after the PUTREST. Example:
(SET HALTZ (I Z 3)>S
(I 2 3)
(PUTREST (REST .\lALTZ 2) .\iALTZ>$
(3lZ3lZ3lZ3lZ3...
acts 7.7.5 - 7.8.1 Structured Objects



70 The MDL Programming Linguagg
7.8.2. Self-clcnnmn
(PUT $I:5frucIured hr s2:srrucfured>
If sl is who '~:\mP nbjecr as $2. than it will 'conlain" itself (and thus be self-referencing) after thg
PUT. Examples:
(SET S (IIST 1 2 3)) ;'or VECTOR"$
(12 3)
(PUT .S 3 .S>$
(l7(I2(lZ(lZ...
(SET U ![![]])S
![Y[!]!1
(PUT .Ul .U>$
![![![![![![...
Test your reaction lime or your lermiu:l's bracket-maker. Amaze your friends.
7.82 Structured Objects
I
l



i
i
I
Y
1
i
l
The MDL Prngratntttittg Language 7|
Chapter 8- Truth
8.1. Trntlt \-'.1 |tlf$lu
MDL rt-pit'~<‘nt~ "Misc" with an nbjcct nf a particular TYPE: TYPE FALSE (unsurprisingly). TYPE
FALSE is strnctnrctl: its PRIHIYVE is LIST. Thus. you can give reasons or excuses by making them
clc|\|('t|t\ nf .1 FALSE. (Again. £VALtng a FALSE neither copies it nor EvAu its clctnents. so it is not
lI(‘Cl‘\\;1|:,' tn Quottj .1 FALSE appearing in a program.) Objccts of TYPE FALSE are represented in “I
tlotatiﬂn :
‘FALSE /1-;.'~0I~:!s—e/amen-‘s
The ctnpty FORM evalnatrs to the empty FALSE:
(>5
dl/NSF ()
Anything which is nnt FALSE. is. reasonably enough. true. In this dncument the “data type’ false-
or-.~m_t in lII(‘lR‘~)'lll.‘lCli(' variables tncans that thc only significant attribute of the object in that
contt~.\t is wlmtlmr its TYPE is FALSE or not.
s.2. Pr0(liC2_lQ_[[l
There are nnntt-rnns Mill. F/SLiBRs which can rt-turn a FALSE or a true. See appendix 2 to find
them alt. Must ictnrn either IFALSE () or the ATOM with PNAHE T. (The latter is for historical
l’l‘l50||s. n.1t||t~l)' I isp (Moon. 1974).) Smite predicates which are meaningful now are described next.
8.2.l. Arithmr-tic [I]
<0? //.t--or-//on!)
@Vilu:ltcs to T only if its argument is identically equal to O or 0.0.
8 - 8.2.1 Truth



72 The MDL Programming Language
<17 /ix-or-1'/oar)
evaluates to T only if its argnntent is identically equal to l or 1.0.
<67 n.-my-or-Iloal nt:/tx~ur-ﬂoat)
evaluates to T only if 1- is algebraically greater lltatt m. L=7 is the Boolean complement of G7; that
is. tt is T ntt|_V if rt is not algebraically greater thatt rn.
(L7 n.-In--nr-/IOAI ml-In:-or-flea!)
evaluates to T only if n is aI_qt~br:tically less than m. G=? is the Boolean complement of L?.
B-2/Z. Equality and Membership [l]
<=='l .--lam,» 92:."-1;‘)
evalttntes to T only if cl is the saute ob‘ect as e2 (appendix l). Two objects that look the same
when PRINT“! tttay not be ==?. Two FIXes of the same ‘value’ are “the same object"; so are two
FLOl\l.s nf ¢l.1_ct_|§ the same "\-alne‘. Empty objects of PRIHTYPE LIST (and no other structured
PRIHTYPE) are ==? if their lYFEs are the same. Example:
(==1 (SET X ‘RANDOM STRING‘) (TOP (REST .X 5>>>S
T
<==7 .X ‘RANDOM SlR1NG">S
IFALSE ()
N==? is the Boolean cntttplentcttt of ==?.
(=7 ¢l:an_\' e2:an_v>
evalnrttes to T if vi ntttl Q2 have the satne TYPE and arc structurally equal -- that is, they "look the
satne". their pritttrtl reptesettmtiotts are the satne. =7 is much slower than ==?. =7 should be used
only when its clt.'tt.\clert<>Iit‘\ are necessary: they are not in any cotnparisotts of unstructured objects.
--v
_--. :t|ttl : 7 .1l\\-ays rclttrtt the snnte value for FIXes. FLOATs. ATOHs. etc. (Mnemonically. ==? tests for
"more eqn.~¢lity"th.1n =1; in fart. it tests for actual physical identity.)
Example. illn~.tr.i|tttg nnn-copying of a SEGMENT in Direct Representation of a LIST:
(Ski A ‘(l 2 3)>S
l
l
1
(123)
<==7 .A ('.A))$
T
<==7 ,l\ (SET B <l.ISl l_A>>>$
8.2.1 - 8.2.2 Truth
i
it
L Lil
. A
ps-
-i
L s._.|
*—lll



**
1;
The MDL Prﬂgramiuing Language 73
IFALSF ( )
<=7 .!\ .8>$
T
N=? is the Rnnlt-:|u cmuplcmrut of =7.
<HEHUER Ob/cchany Slrurfurrd)
ruin down -::r</r.'~.'/~d from first tn last alt-tncnt. comparing each clement of slruclured with ob/ecl.
ll‘ it finds :t|| ('lt't||(‘nt of clrur/urvd which is =" to objecl. it returns <REST struclured i> (which is of
TYPE <r'Rttt1YPE :.'rur!u!r‘d>). where the (1-l)th eleutcnt of :1/uch./red is =7 to ob/‘err. That is. the
first (‘|<'||\r‘|\l nf what ll returns is the first clcmcut of 5fruCIurr:d that is =7 to Ob/L‘Cf.
If no clemt-ut of s.‘/t/rlurcd is =7 to ob/ccl. MEMBER returns IFALSE ().
The st-:|rch is tutvrc rffirimtt if <.'rurIured is uf PRIMTYPE VECTOR (Or UVECTOR, if possible) than if it
is of PRIMIYPF L ISI. As usual. if sl/urlurod is constant. it should be QUOTEd.
If O!)/crl and rilrurtured are of PRIHTYPE STRING [or BYTES]. MEMBER does a substring search.
Exalnplr-:
<l“lFHB['R "PAR!" "SUM OF PI\RTS">S
"PARTS"
(MEMO 0Lv;r‘rI.-any -.1»./rlt1.~vr1> ("int-inher quicl».") is exactly th: same as MEMBER. except that the
comparison test is ==? .
(STRCOHP -;I 52>
(“string cmnp:\ris0u") can hr given either two STRINGs or two I\TOMs as arguments. In the latter case
the l‘NAHE~ arr u~t-d. lt actually isn't a pl'('dtC3l(‘. since it can return three possible valuns: O if :1 is
=" tn 521 l if :1 sr\rl'~ alplialu-tically aftcr 92 and -l if :1 sorts alphabetically before s2.
Alpliabrticnll)-" nu>.1ns. in this case. according to tlu: numeric order of ASCII. with the standard
alpluabetizing rulcs.
[A predicatc suitahlc fnr an ascending SORT (which see) is (G? <STRCOHP .ARG1 .ARGZ> 0).]
8.2.3. lloulcrtu Opcratnrs [I]
(HOT 0;/air-c—or—any)
l'Valu2tes to T only if e evaluates to a FALSE, and to IFALSE (J otherwise.
(AND cl 02  cN>
8.2.2 - 8.2.3 Truth



74 The MDL Programming Language
AND is an l'StlllR . It (‘\'.1lttal('siIs argnntettts from first to last as they appear in the FORM. As soon
as one of them rt-nlttntos to a FALSE, it returns that FALSE, ignoring any remaining arguments. If
none of tltt-in rt-alttntc to FALSE. it returns EVAL of its last argument. <AND> returns T. AND? is the
SUBR cqnit-alt-nt Iﬂ AND, that is. all its argutnr.-nts are evaluated before any of them is tested.
(OR cl (‘Z  EN)
OR is .'\t| FSUIZR. lt rt-':tlnatcs its argttntcnls from first to last as they appear in the FORM. As soon
as one nf tltcnt ('\'alttalr‘\ tn a non-FALSE, OR returns that non-FALSE value. ignoring any remaining
argtttttcttts. lf this nz-vrr occurs. it rt-turns the last FALSE it saw. <0R> returns IFALSE (). OR? is
the SUBR ('quivalc||t tn OR.
82.4. Object Prnpcrties [I]
(TYPE? any I_tpe-I  Iype~N>
evaluates tn v'_t'p£"I 0t|l)' if <==? lyre»: (TYPE an;/>> is true. It is faster and gives more information
than ORtng trsts fnr !‘.‘|C|l TYPE . lf the test fails for all type-is. TYPE? returns {FALSE ().
</\F'Pl ICABLE .7 v>
evaluates tn T nltly if 0 is of a TYPE that can legally be applied to arguments in a FORM, that is. be
(EVAL of) tltc first Mctltrttl of a FORM being evaluated (appendix 3).
<M0Hl\D7 c)
evaluates tn ll’/‘tl SF () nnly if NTH and REST (with non-zero second argument) can be performed on
its argument witltont error. An unstructured or etnpty structured object will cause HONAD? to return
T.
<STRUCTURl-O" 0)
evaluates tn T only if e is a strttctttred object. lt is not the inverse of HONAD?, since each returns T
if its argnntcnt i\ an ctnpty structure.
<[HP"lY" r.!!ut'lu/'cr1>
t'v.\ln:tt‘(‘s tr» T only if its :trgn|nont_ which must be a structured object. has no elements.
(LENGTH? slrurfurvd fix)
cv:|In.1tc\ tn (LENGTH f>f/Il(,L,'7C'd> only if that is less than or equal to fix: otherwise. it evaluates 1°
0FALSF (). Mncmnnically. you ran think of the first two letters of LENGTH? as signifying the “It-*5 _
titan or cqttal to" scttsc nf the test. f‘
8.2.3 - 8.2.4 Truth f



Y---,
The MDL Prograunning Language 75
This SUBR was invented to use on lists. because MDL can determine their lengths only by stepping
along the list. counting the elements. lf a program needs to know only how the length compares
with a given number. LENGTH? will tell without necessarily stepping all the way to the end of the
list. in contrast in lENGTH.
[If ifruclured is a circular PRIHTYPE LIST, LENGYH1 will return a value. whereas LENGTH will execute
forever. To see if you can do (REST sfrucfured <+ I !ix>> without error. do the test (NOT (LENGTH?
gfrucfured I1x>).]
8.3. COND ll
The MDL Subrnutine which is tnosl used for varying evaluation depending on a truth value is the
FSUBR COHH ("cmiditional"l. A call to COND has this format:
(COMO clause-I:lrs!  clause-N:l1's!>
where N is at least one.
COND always returns the result of the last evaluation it performs. The following rules determine the
order of evaluations performed.
(I) Evaluate the first element of each clause (from first to last) until either a non-FALSE object
results or the clauses are exhausted.
(2) If a nrin-FALSE object is found in (I). immediately evaluate the remaining elements (if any)
of that clause and ignore any remaining clauses.
In other words. COND goes walking down its clauses. EVALing the first element of each clause, looking
for :1 non-FALSE result. As soon as it finds a non-FALSE, it forgets about all the other clauses and
evaluates. in order. the other elements of the current clause and returns the last thing it evaluates.
lf it can‘! find a non-FALSE. it returns the last FALSE it saw.
8.3.1. Examples [I]
(SET F '(l)>$
(1)
(COND ((EHPTY? .F> EH?) ((1? (LENGTH .F>> ONE))S
ONE
(SET F ()>$
()
<CON0 (<El“lPTY? .F> EH9) (<1? <LEN$TH .F)) ONE)>$
EHP
8.2.4 - 8.3.1 Truth



76
The MDL Programming Language
<SET F ‘(I 2 3)>$
(I 2 3)
(COND (<EHP1Y? .F) EHP) (<17 (LENGTH .F>) ONE)>$
IFALSE ()
<COND (<LENG‘l'H? .F 2) SHALL) (8IG)>$
BIG
(DEFINE FACT (N) ;'the standard recursive factorial’
(CORD (<0? J1) 1)
(ELSE <’* .N (FACT (- Jl 1)>>)>>S
FACT
(FACT 5>S
120
8.4. Shortcuts with Cottgtlionals
8.4.1. AND and OR as Short CONDs
Since AND and OR are FSUBRs. they can be used as miniature CONDS. A construct of the form
(AND prc-condilions acIion(s)>
Of
(OR pre-—vx<'Iu.¢ions ar!ian(s)>
will allow .4chan(s) to be evaluated only if all tlte pre-conditions are true or only if all the pra-
exclusions are fake. respectively. By nesting and using both AND and OR, fairly powerful constructs
can be made. Of ct-nrsc-. if achonfs) are ntore than one thing. you must be careful that none but the
last returns false or true. respectively. Watch out especially for TERPRI (chapter ll). Examples:
(AND <f\$-SIGNED? FLAG) .FLAG <FCN .AR6>>
applies FCN only if someone else has SET FLAG to true. (ASSIGNED? is true if its argument ATOM has
an LVAL .) No crrnr can occttr in the testing of FLAG because of the order of evaluation.
(AND <SET C (OPEN "READ' ‘A FILE'>> (LOAD .C> (CLOSE .C>>
effectively FLOADs the file (chapter ll) without the possibility of getting an error if the file cannot
be opened.
8.3.l - 8.4.l Truth
‘F
L



Y‘
The M Dl. l'rogr.1nuning Language 77
8.4.2. F.|nbt~ddt~d Llncnnditionals
One of thc l|l\€‘l(|\'illl;lg("n of COND is that there is no straightforward way to do things
unconditinn.1ll_y in ht-ttvccn tests. One way around this problem is t0 insert a dummy clause that
never .\ucc('t'tls. l)cc:\\|*-1' its only LIST clement is an AND that returns a FALSE for the test. Example:
(CORD (<07 .N) (F0 .N))
(<l7 .N> (Fl .N>)
(<AHD (SET N <" Z (FIX (I .N Z>)>)
;"Round .N down to even number.‘
<>>)
(<LEHGTll" .VEC .N) '[])
(Y (RESY .VEC (+ l .N))))
A \'ari:\Iint| is lﬂ lttitlt‘ tlm last AND argument into the test for the COHD clause. (That is. the third
and fourth clans:-~ Ill the uhnre 1'-xatnple can be combined.) Of course. you must be careful that no
other AND arqtttltt-tit (‘v:tlu.'ttcs to a FALSE; moat Subroutines do not return a FALSE without a very
gnud rrasnn fnr at. (A nntahlc C.\ct‘pti0|t is TERPRI (which sce).) Even safer is to use PROG (section
l0.l) iIl!~l(‘;1tlr\f ANTI.
Another v.1n.1tmn is tn inrrt-.1~c the nesting with a new COND after the unconditional partt At least
this mctln-<l t|ﬂ(‘S nm make the cndc apptar tn a human reader as though it does something other
than what it rr-ally rtnos. ’l"he ahnve example could be done this way:
(CORD (<0? .H) <F0 .N>)
((1? .N> (Fl .N>)
(T
(SET N (" 2 (FIX </ .N Z)>))
<COHU ((LENGTH? .VEC .N> '[])
(T <RE$T .VEC <+ l .N>>)>))
8.4.2 Truth



78 The MDL Programming Language
Chapter 9. Functions
This (‘|t.Iplr‘r rnultl ho n.1n|rtI "fnn and games with argttntent LISTs'. its purpose is to explain the
innrv rrnnplicntt-it tlitng-. nltirlt can hr done with FUNCTI0l':s. and this involves. basically. explaining
all the \‘ﬂllﬁlI\ ll\|('H\ nhich can ;tp|)('3l’ in the argument LIST of a FUNCTION. Topics are covered
in wh.-it 1‘ .~t|ipr--\ini.1trIy :tt| nrrlrr of incrcasing complexity. This order has little to do with the
order in \\lli(|l tnl f‘lI\ can Il(‘l\l5I“_\' appear in an argument LIST. so what an argument LIST "looks
like" (\\'t'l.'\l| ;_'t~ts r:\tlt('r |n\l in tltc shuffle. To alleviate this prubletn, section 9.9 is a sutntnary of
evcrytlting th.tt c.'t|t gr» into an argtttncnt LIST, in the correct order. If you find yourself getting
lost. plr.\st- tcfm tn that snnnnary.
9-_';l)['lL°i U1
MDL prnvith-s \-my cmtvmiicttt tncnns for allowing optional arguments. The STRING "OPTIONAL"
(or “OPT” -- l|t(')"t(‘ tnt.illy t~qtti\'alt-nt) in the argument LIST allows the specification of optional
:irgtun<-nts with \-alum tn hr auignctl by default. The syntax of the ‘OPTIONAL’ part of the
argutncnt LISI is as follows:
"Ol'lIOIlf\L" ,:J»I sf-2 . . . al—N
First. i|t(‘l£‘ is tht- Slltltlt; "Ol'T1Ot;I\L". Then there is any nttntber of either ATOHs or two¢elcment
LISTs. it|tt'tn|txt'd_ nttt: |>(‘|‘ t\ptton:tl.1rgntnct\l. The first eletnettt of each two-clctncnt LIST must be
an ATOM: this is thr~ tlntnniy \'ati.1hlc. The second clement is an arbitrary MDL expression. If there
are reqnirvit .1i;|iinrnt-._ tln-y tttltsl ctnnc bcfurc the "OPTIONAL".
\‘Vhen TV/tt, is lnmlttn; the v.1n.-thli-s of :4 FUNCTION and sees "OPTIONAL", the following happens:
ll’ .\ll ('\|W|H it .'nt;tmiv|i: \\;4'~ gtvrn in the position of an optional one. the explicit argument is
hnttntl tn tht- t'r\llt'\|itHl(llllg tltltnnty AIOM.
ll ||l('I'(‘ 1-» nri t-\pl|rit .1r;ntnt-nt and the ATOH stands alone. that is. it is not the first element of
.1 |\\'1\.I']t‘Il\I'lI| l l§;l_ that ATOH hccnnics "hound", but nu local value is assigned to it [see below].
.-\ lnt::tl \':tlue- ran be assigtivd tn it by using SET.
9 - 9.! Functions
_4



l
The MD]. Prograttttning Language 79
If there is no (‘\'p|i€il argument and the ATOH is the first element of a two-element LIST. the
M DI. t'\prt'\<in|| in the LIST with the ATOH is evaluated and bound to the ATOM.
[Utttil an ATOM is assigttt-d. any nttentpt to reference its LVAL will produce an error. The predicate
SUBRs [!OUllD"‘ and ASSIGIJCD’ can be nst-d to check for suclt situations. BOUND? returns T if its
argument l\ (llI((‘lI||)' lmnntl via an :irgnntent LIST or has ever been SET while not bound via an
nrgttntent l ISI . The lnttt-r Liml of binding is called "top-level binding". because it is done outside
all active argtt|nt~nt-l IST binding. ASSIGNED? will retttrn IFALSE () if its argument is either
tllt:|S\i§|tt‘tl Q5 nttlmnntl. liy the way. there are two predicates for global values similar to BOUND?
and ASSICIJFD’. It-1mrly t‘-BOUND? and GASSIGHEDT. Each rcturtts T only if its argument, which (as
itt BOUND? and l'\SSIGHED?) must he an ATOM, has a global value 'slot' (chapter 22) or a global value.
respectively.)
Example:
(DEFINE INC] (A "OPTIONAL" (N 1)) (SET .A <+ ..A .N)>>$
IHCI
(SET ll 0>$
0
(INCI B>!>
l
(INC! 8 5>$
6
Herc we defined annthcr (not qnitc working) incretnettt FUNCTION. It ttow takes an optional
argnntt-tit specifying ltnw tnnclt to increment tln: ATOM it is given. If ttot given. the increment is 1.
Now. l is :\ pretty simple MDL expression: there is no reason why the optional argument cannot be
cotttplicatl.-d -- for c.\atnplc. a call to a FUNCTION which reads a file on an I/O device.
9.2. TUPLEs
9.2.|. 'TUPt_E" and TUPLE (the TYPE) [I]
There are also times when yntt want to be able to have an arbitrary number of arguments. You can
always do this hy tlofining the FUNCTION as having a structure as its argument. with the arbitrary
number nf argtttitettts as eletnents of the structure. This can. however. lead to inelegant-looking
FORr1s and extra gartiagc tn be collected. The STRING "TUPLE‘ appearing in the argument LIST
allows ynn to avoid that. lt nntst follow explicit and optional dummy arguments (if there are any
of either) and ntust he fnllowed by an ATOM,
The effect of “TUI'LE" appearing in an argument LIST is the following: any arguments left in the
9.l - 9.2.l Functions
FFFFFFFFFFFFFFFFFPFFFFPF



8° The MDL Programming Language
FORM, after satisfyitig explicit and optional arguments. are EVALed and made sequential elements of
an nlyjcrl of TYPL and PRIHIYPE TUPLE. The YUPLE is then bound to the ATOM following 'TUPLE'
in the nrguntent LIST. If there were no arguments left by the time the "TUPLE' was reached. an
empty TUPIE is bound to the ATOM.
An 0l)_'|t-rl of TYPF TUPLE is exactly the satne as a VECTOR except that a TUPLE is ||ot held in
garbage-collrwlrtl storage. lt is mstond held with ATOM bindings in a control stack. This does not
affect tttatiipttlntinii of the TUPLE within the function generating it or any function called within
that nnt‘: it \'.‘llI he tr:-axed just like a VECTOR. Note. however. that a TUPLE ceases to exist when the
function whirl: grttcrntcd it returns. Returning a TUPLE as a value is a good way to generate an
error. (.»\ copy til‘ :\ lUl‘l.l: can easily he generated by segtrtent-evaluating the TUPLE into something:
that copy can he returned.) The predicate LEGAL? rettlrtts r'FALSE () if it is given a TUPLE
gcttcratrd by an APPLICABLE object which has already returned. and T if it is given a TUPLE which is
Still “good”.
Example:
(DKFINK NIHARG (N “TUPLE' T)
;'Get all but first argument into T.‘
(CORD (<==? 1 .N> 1)
;”If N is 1. return lst urg, 1.2., .N.
t.e., l. Note that <17 .N> would be
Lrue oven if .N were 1.0.‘
((L? (LENGTH .T> (SET N <- .N l>>>
.4FALsE ("DUI-1l"lY' ))
;"Chock to see if there is an Nth arg,
and make N a good lndux into T while
you're at tn.
lf there isn't an Nth arg, complain."
(ELSE <NlH .T .N))>)
NTHARG. nbnvz-. t:tl.t~s any ntttnbcr of arguments. its first argument must be of TYPE FIX. It
returns [\/Al of its Nth nrgtttttrttt. if it has an Nth argument. If it doesn't. it returns IFALSE
("DUMMY"). (The l'lSE is not absolutely necessary in the last clause. ll‘ the Nth argument is a
FALSE, the (ZOHD will rclllrtt that FALSE.) Exercise for the reader: NTHARG will generate an error if
its first argtttnrut is not FIX. Whcre and why? (How about (NTHARG 1.5 2 3> P) Fix it.
9.2.2. lUPl E (the SUBR) and IIUPLE
These SIIRRs arr the sntuo as VECTOR and IVKCTOR, except that they build ‘lUPLEs (that is. vectors on
the control st.1cl.\ Tl-ry can he ust-tl only at top level in an ‘OPTIONAL’ list 0r ‘AUX’ list (see
br:lo\v\. The ch.-at .1rl\':tut.1ge of lUF‘LE and ITUPLE ("implicit tuple") is in storage-management
efficioury. They product‘ no garbage. since they are flushed automatically upon function return.
9.2.1 ~ 9.2.2 Functions
 i
.-_
 
 _i
 ?
L



The l\lDl. Prograilmmig Language 81
Exa|nplc\:
(DEFINE F (A B "AUX" (C <ITUPLE l0 3>)) ...>
creates a l0-clcmclit YUPLC and SEE C to it.
(DEFINE H ("OP‘llONI\L" (A <I'l'UF'LE 10 '(I)>)
"AUX" (B <TUPLE !.A l 2 3>))
...>
Tliesr: are valid usc'~ nl‘ TUPLE and ITUPLE. However. the following is not a valid use of TUPLE,
because it is um called at lOp Icvcl of the "AUX":
<OEFIHl> HO (A [1 "AUX" (C (REST (TUPLE !.A>>)) ...>
However. the desired cffcct could be achieved by
(FIFFIHE OK (A 8 "AUX" (D <TUPLE !.A>) (C (REST .D>)) ...>
&3."AUX”[ﬂ
"AUX" (nr "EXTRA" -- they're tntally cquivalcutl are STRIHGs which. placed in an argument LIST,
st-rvc In cl}-|\:unic.-illy A]|fI(‘2lC temporary variables For thc use of a Function.
"AUX" muxx ;\ppr:\r in the :\rgnmcnt LIST after any infornuation about explicit arguments. It is
followed by !\TOMs nr two-clnncm LXSTs as if it were "OPTIONAL". ATOMs in the two-element LIST:
are bound lﬂ EVA! nf vhc second nlcmcnt in the LIST. Atoms not in such LIST.» are initially
lil_IaS§i!*ll_(‘tli Ilwy are 0.\pliri|l)'givt'|\'1|o" LVAL.
All bintling '~pl‘CiI'i(‘d in an argument LIST is done sequentially from first to last. so initialization
expressions for "AUX" (nr "OPll0HAL") can refer to objects which have just been bound. For
example. lhis \vnrl.\:
<ocrt~c AUXEX (“TUPLE" 1
‘AUX’ (A (LENGTH .r>) (B <- 2 .A>))
![.A .el>s
AUXEX
<AUX[X 1 2 -Foo->s
![a 0!]
9.2.2 - 9.3 Functions



B2 The MDL Programming Language
9.4. QUOT Fil__a_§g_n nit-Vi\_tl
If an AIOH in nu argument LIST which is to be bound to a required or optional argumcnt is
surrountlr-il by :1 rail tn QUOTE, that ATOM is bound to the nnevalnatrd argument. Example:
([lEf IHI O2 (K ‘B) (.A .B)>$
Q2
(Q? <0 12> <+ l 2>>$
(3 <+ l ?>)
it is nnt ol't¢-n .1|t|u~-pri.1te fnr :\ function to take its arguments unevaluated, because such a practice
IIIRLPS it it-\s Illlllillitll and il2Y(|(‘l' lo tnitintainz it and the programs that call it tend to need to know
lllnrc ahmit r-nth rillicr. and a change in its argtnnent structure would tend to require more changes
in tlic prrigrniin that call it. Anti, since few functions, in practice. do takr: unevaluatcd arguments.
users tend tn :\$'~llll|t that no functions do (except FSUBRs of course). and confusion inevitably
results.
9.5. "ARCS"
The indicalnr "ARCS" can .1p|t<~ar in an argument LIST with precisely thc same syntax as "TUPLE" .
Howevrer. "ARCS" cattu-\ the ATOM following it to be buund to a LIST of the remaining unevaluated
ZI'gl.llI1(‘lIl§.
"ARES" dries nm cause any copying to take place. lt simply gives you
(REST .tpp-‘Italian.-fornt fur)
with an :tpprnpri:\t<- ht. Thv ‘IYVE change to LIST is a result of the REST. Since the LIST shares
all its !'lt't|\('|lls with lhc original FORM, PUTs into the LIST will change the calling program.
however tlangcrnus that may bc.
Examples:
<l'1l'FlHF Q11 (N "ARCS" L) <.N .L>>$
Qll
(OIT 7 <+ 3 4) (LENGTH ,OALL> FOO)S
<LEN(slI| ,0/\LL>
(Off llll lUNCTl ("/’\RGS" ARGL-AND-BODY)
(CHIYPE .l\RGL—AND—BODY FUNCTION)>$
FL|HCll
<FUNCTl (A U) <~ .A .B>>S
v'l'llNCTION ((A 8) (0 .A .B))
9.-1 - 9.5 Functions
i
 ‘
‘F
T
T
T‘
T‘
‘F
‘F
7T1‘
 
1'
T‘
T
T‘
T‘
 
FF?‘
T‘
T‘



The MDI. Prngrrttntning Language 83
The last example is a pt-rfectly valid equivalent of the FSUBR FUNCTION.
9.6. "cmgg
The iI\diCIll\'ll’ "CALL" is an ultimate ‘ARES’. if it appears in an argument LIST. it must be
followed by an ATOM .1ml must be the only thing used to gather arguments. "CALL" causes the ATOM
which follows it to hec.o\nt- bound to the actual FORM that is being evaluated -- that is. you get the
"function c.1ll"it<elf. Since "CALL" binds to the FORM itself. and not a copy. PUTs into that FORM will
change the calling code.
"CALL" exists as a Catch-22 for argument manipulation. ll‘ you can‘: do it with "CALL". it can‘! be
done.
9.7. EV1‘lL_;|ttt.l_"§ll\_tll"_
Obtaining nne\'.1lnated argntnents. for e.\antple. via QUOTE and "ARIES", very often implies that you
wish to t'\':\l\|alt.' them al snme point. You can do this by explicitly calling EVAL, which is a SUBR.
Example:
(SET l' '(+ 12>)!»
<-- l 2>
<EVI\L .i'>$
3
EV/\L <‘.1t| t:\Lt- .1 \f't'nl|d mgument. of TYPE ENVIRONMENT (or others. see section 20.8). An
ENVIRONlll~.H1 t‘0n\i'~l\ basically of a state of ATOM bindings: it is the "world" mentioned in chapter 5.
Now. since btn<Iin;_' changes the ENVIRONMENT. if yon wish to use EVAL within a FUNCTION, you
pr0b.1bl_\' \\':|t|t in gr: lmhl of the rnvirontnr.-nt which existed before that FUHCTION's binding took
place. Tho inilicatnr "nlNl'l“. trhirh must, if it is used, he the first thing in an argument LIST,
provides this ittﬁ-|r||t.tti0n. ll binds the ATOM immediately following it to the ENVIRONMENT existing
"at call time" -- that is. just before any binding is done for its FUNCTION. Example:
(SE1 A 0)!»
0
(DEFINE WRONG (‘B ‘AUX’ (A 1)) <EVAL .B>>$
WRONG
(WRONG .A)$
.l
(DEFINE RIGHT ("BIND‘ E ‘B 'AUX" (A 1)) (EVAL .8 .E>>$
RIGHT
9.5 - 9.7 Functions



84 The MDL Programming Language
(RIC-lll .A>S
0
9.7.1. Lnrnl Valuc-\ veruts FNVlRONP1[HTs
SET. LVM , V/\ttIF_ BOUND". /\SS1LH[D". and UNASSIGN all take a final optional argument which
ha\ tint pr:-\-inn\|_v l\rt'|| nu-nttoneti: an ENVIRONMENT (or other TYPEs, see section 20.8). If this
argument is git-en. the SET or LVAL is done in the ENVIRONMENT specified. LVAL cannot be
abbrc\'i.1tt-dliy . (pt-riml) if it is given an explicit second argument.
Thi\ feature I\ _|uu \\|lI\' is neetlcd to cure the INC bug mentioned in chapter 5. A “correct” INC can
be definetl as frvllnwwz
(DEFINE IHC ("BIllD" OUTER ATH)
<S[l .ATM <¢ I <LVAL .ATH .OUTER>> .OUTER>>
9.8. AC1 1vn1_19_r:_,;rir\t:r~-4;-Act" AGAIN and tzstutm [t1
EVALt|:\linIl of a FMHCTION, after the argntneut LIST has been taken care of. normally consists of
EVALn.1tint_; each of the nbircts in the body tn the order given. and returning the value of the last
thing FVAI rd If _\-nn \\.1t|t tn vary this seqttettce, you need to know. at least. where the FUNCTION
begins. /\tI||.1ll'\'_ E\.':'\L nmnially h:t.~n't the foggiest idea of where its current FUNCTION began.
"When-'tl l Hart" |nt'nrni.1tir\n is bundled up \vith a TYPE called ACTIVATION. In 'n0rmal' FUNCTION
EVALuatinn. |'\C‘iI\J:'\TIOt:\ are not generated: one can be generated. and bound to an ATOM, in either
of the ttvn fnllnuing w:ty§2
(ll Put an ATOM ininu~rlia|el)' before the argument LIST. The ACTIVATION of the Function will
be lmnnd tn that ATOM.
(12) As the I.-i'~t thing tn the argument LIST, insert either of the STRING: “NAME” or "ACT" and
follow it with an ATOM. The ATOM will be bound to the ACTIVATION of the Function.
In this dncninrnt "Function" ((:a|7il3li1cd)\\'i|| designate anything that can generate an ACTIVATION;
besides TYPE ltlli(‘lION. IIIIS class includes the FSUBR5 PROG, BIND, and REPEAT, yet to be
discu>>ed.
Each ACTIVATION t('l'(‘t\ expliritly tn a particular evaluation of a Function. For example. if a
recursive FUNCTION geiu-rates an ACTIVATION, a new ACTIVATION referring explicitly to each
recursion step i\ gt‘|It‘|.‘l1('d nu every recursion.
Like TUPt [\_ /\C1[VATIONs are held in a control stack. Unlike TUPLES. there is Q2 wax to get a copy
9.7 - 9.8 Functions
Y



P’?-
The MDL Prngrantnting Language 85
of an ACTIVATION which can ttsefttlly he returned as a value. (This is a consequence of the fact that
ACTIVATIOHs refer to evaluations: when the evaluation is finished. the ACTIVATION no longer exists.)
ACTIvATIONs can be tested, like TUPLEs. by LEGAL? for legality. They are used by the SUBR.s AGAIN
and RETURN.
AGAIN can take one argument: an ACTIVATION. It means "start doing this again". where "this" is
specified by the ACTIVATION. Specifically. AGAIN causes EVAL to return to where it started working
on the hotly of the Fnnrtinn in the evaluation specified by the ACTIVATION. The evaluation is not
redone cotnplett=ly: in p.1rticnlar, no re-binding (of arguments. ‘AUX’ variables. etc.) is done.
RETURN can talc two arguments: an arbitrary expression and an ACTIVATION, in that order. It
causes the Fttttctintt l‘\'2|ll-'\Ti0lI wlmse ACTIVATION it is given to terminate and return EVAL of
RETURN‘s first .1rgnincnt. That is. RETURN means "quit doing this and return that’, where "this" is the
ACTIVATION -- its sccnttd argument -- and "that" is the expression — its first argument. Example:
(DEFINE HY¢ ('TUPLE' T "AUX' (H 0) ‘NAME’ NH)
<COND ((EHPTY? .T> (RETURN .N .NH))>
(SET H <0 .H <1 .T>)>
<SET T (REST .T>>
_ (AGAIN .NH>>$
HY-
<HY+ I 3 (LENGTH 'FOO'>)S
7
<MY+>S
O
Note: suppose an ACTIVATION of OIIC Function (call it Fl) is passed to another Function (call it F2) -
for example. via an appliration of F2 within Fl with Fl's ACTIVATION as an argument. If F2
RETURHs to Fl's ACTIVATION, F2 .1_--_q Fl terminate immediately. and Ll returns the RETURN‘s first
argument. This technique is suitable for error exits. AGAIN can clearly pull a similar trick. ln the
following t-sample. Fl c0tt|pt|l(": the sum of F2 applied to each of its arguments: F2 computes the
product of the t'lE|ttcnl$ of its structured argument. but it aborls if it finds an element that is not o
number.
(DEFINE Fl ACT ("TUPLE" T ‘AUX’ (Tl .T))
(COND ((NOT (EMPTY? .Tl>>
(PUT .Tl I (F2 (1 .Tl) .ACT)>
(SET Tl (REST .Tl>)
(AGAIN .ACT>)
(ELSE <4 l.T>)>)$
Fl
9.8 Functions



55 The MDL Programming Language
(DEFINE F2 (S A 'AUX' (S1 .S))
(REPEAT HY—ACT ((PRD 1))
<COND (<NOl' (EMPTY? .Sl>>
(CONT) (<NOT (TYPE? (1 .51) FIX FLOAT>>
(RETURN (FALSE ('NON—NUﬂBEI') .-A))
(ELSE (SET PRO (* .PRO (1 .S1>>>)>
<SET Si <REST .Sl>>)
(ELSE <RETURN .PRD>)>>>S
F2
(Fl '(1 Z) '(3 4)>S
14
<Fl ‘(T Z) ‘(3 l)>$
IFALSE (‘NON-NUHBEﬁ')
9.9. Argtttttettt List Sntutttar!
The following is a listing of all the various tokens which can appear in the argument LIST of a
FUNCTION, in the nrdcr in which they can occur. Short descriptions of their effects are included.
i of them are n|IliI')1Et_l -- that is. any of them (in any position) can be left out or included - but
the Order in wlticlt they appear must be that of this list. 'QUOTEd ATOM‘. ‘matching object’. and '2-
list" are defined below.
(t) ‘BIND’
must be followed by an ATOH. It binds that ATOM to the ENVIRONMENT which existed
when the FUNCTION was applied.
(2) ATOM: and QUO‘lFd ATOM; (arty number)
are required argutnents. QUOTEd ATOM: are bound to the matching object. A‘l'OH.s are
hound to EVAL of the matching object in the ENVIRONMENT existing when the FUNCTION
was applied.
(3) ‘OPTION/\l.“ or ‘OPT’ (they're equivalent)
is followed by any ttutttber of ATOHs. QUOTEd ATOl'ls. or 2-lists. These are optional
zrgntncuts. If a tttatchittg object exists. an ATOM - either standing alone or the first
clrtltcltl of a 2-list ~- is bound to EVAL of the object. performed in the ENVIRONMENT
e.\isting when the FUNCTION was applied. A QUOTEd ATOM - alone or in a 2-list - is
bottttd to the matching object itself. If no such object exists. ATOM: and QUOTEd ATOHs
are left unbound. and the first element of each 2-list is bound to EVAL of the
corrcspontling second element. (This EVAL is done in the new ENVIRONMENT of the
Function as it is being constructed.)
9.8 - 9.9 Functions
1"‘
l
1 l'l
Fl
I



r-
The MDL l"rr\gr.\|ntniug Language 87
(4) "ARGS" (ant! not "TlIPl,b"l
nuts: hr fnllnwcd by an ATOM. The ATOM is bound to a LIST of al the remaining
:trgn|nt~uts. ll|Ik‘\'@ﬂ_Jl_l!‘ﬂ. (If lhcrc are no more arguments. the LIST is empty.) This
LIST is :iclu.1Ily :\ REST of the FORM applying the FUNCTION. lf “ARES” appears in the
.1rguin|.-nl LIST, "TUPLE" should not appear.
(4) "TUPLE" lnnrl nﬂ "/\R(;S")
ntnsl he fnllmvecl by an ATOM. The ATOM is bound to a TUPLE ("VECTOR on the control
~t.1cl."l nf all the retunining argnntents. evaluated in the environment existing when the
t'l|tlt‘.llO!l was applit-tl. (If no arguments rctnain. the TUPLE is empty.) if "TUPLE'
.-ipprnrs i|| the argument LIST. "ARES" should not appear.
(5) "AUX" rtr "FXTRA" ttlit-)"tt* rqilivaletttl
1-. fﬂllnttml hy any nltlnber of ATOl1s or ‘Z-lists. These are auxiliary variables. bound
m\-.1_\- from lltc p|'t'\'inns t-nvirnnmeut for the use of this Function. /\TOr1s are bound in
thv t'tlvIROtll1£ll1 of the Fnnclinn. but they are unassigned: the first elentent of each 2-
list is lmth hmtnd and assigned to EVAL of the corresponding second element. (This
L'V!\L is tlﬂllf‘ in the new ENVIRONMENT of the Function as it is being constructed.)
(6) "NAHF" or "AC1" (tlivy'rt' t'quiv.1leul)
must he fnllmvcd by an ATOM. The ATOM is bound to the ACTIVATION of the current
evaluation oi’ the Function.
ALSO -- in pl.“-1' nf sections (2) (3) §\Ld (4). you can have
<2-3-4) "cnll "
which tnuu hr follow:-tl by an ATOM. The ATOM is bound to the FORM which caused
.-ippltcatmn of this FUNCHON.
The special Icrtns nu-d nlmve lnenn this:
"OUOTEd ATOM" -_ :1 two-t-lcturitt FORM whose first clement is the ATOM QUOTE, and whose second
element is any ATOM. (Can he typed »- and will be PRINTcd -- as 'al0m.)
"Matching “hit-ct" -- that ch-mcnt of .1 FORM whose position in the FORM matches the position of a
required nr npltﬁnnl .-trguincnl in an argunicnt LIST.
"2-list" -- .1 two-nlcmoiil LIST wlinse first element is an ATOM (or QUOTEd ATOM; see below) and whose
secnntl C|('llIl'lll ran he anything but a SEGMLNT. EVAL of the second element is assigned to a new
binding of the first clrincnt (tho ATOM) as the "value by default" in "OPTIONAL" or the "initial value“
in "AUX". In thc case of "OP! IOHAL", the first clement of a 2-list can be it OUOTEd ATOM; in this
case. an :\rquiut-ut winch is \l|ppli(‘t| is not EVI\Led. but if it is not supplied the second eienient of
the LIST is CVf~Lt‘d and assigtled to the ATOM.
9.9 Functions



88 The MDL Programming Language
0.10. :\r~:-LL11]
Occasionally tlu-to is a valid reason for the first element of a FORM not to be an ATOM. For example.
the nb_jm~t tn he applivtl In argtnnents may be chosen at run titne. or it may depend On the
argutncnts in snnir way. While EVAL is perfectly happy in this case to EVALuate the first element
and go on frnnt thmr. the <‘mnpilt~r (Lebling. I979) can generate more efficient code if it kI\0Ws
whether the rt"-ull of the e\-:\ln:|tion will (ll always he of TYPE FIX. (Z) Always be an applicable non-
FIX nhjcct that cvaluau-s all its atgtiuietits, or (3) neither. The easiest way to tell the compiler if (l)
or ('2) is trnc is tn use the AYOH NTII (st‘(‘ti0n 7.l.2) or PUT (section 7.l.4) in case (l) or APPLY in case (2)
H5 "W fir" l‘|!'HH‘I" "T Illt‘ |0Rl‘1- tNt\'l'1€ﬂ\l‘(llca|t compile into in-line code, but case ('2) compiles
into n fully nu-diatt-tl call intn the interpreter.)
(APPLY 0/)/elf alg-I ... .tr_-3-N)
evnltlnles oh/<-cl antl :t|l the R'E'IS and then applies the former to all the latter. An error occurs if
ob/ecl 1-valnntt-s to smut-thing not applicable. or to an FSUBR, or to a FUNCTION (or user Subroutine --
chapter til) with "ARCS" or ‘CALL’ or QUOTEd arguments.
Example:
(APPLY <Nlll .ANALYZERS
(LENGTH (HEN!) (TYPE .ARB> .ARGTYPES))>
.ARG>
calls a function tn nnalyrc ./\RG. Which function is called depends on the TYPE of the argument:
this represents the itlt-a 0|’ a dispatch table.
9.11. ctosutzg
(CLOSURE Iunrlton al  aN>
where /uttcftﬂn is .1 HINCTION, and a.‘ through aN are any number of ATOMs. returns an object of
TYPE CLOSURE . This can bt: applied like any other function. but. whenever it is applied. the ATOHs
given in the call tn CLOSURE are fit bnnud to the VALUEs they had when the CLOSURE was
gent-ratoil_ tht-n the Itmtho/1 is applied as normal. This is a "poor man's t'unarg".
A CLOSURE is useful when a FUNCTION tnust have state information remembered between calls to it.
vspccially in thctc tun cases: when the LVALs of external state ATOMs might be compromised by other
programs, or when lnnrt: than one distinct sequence of calls are active concurrently. Example of the
latter: e.1rl| 0l)_jt'ct nl’ .1 slrucluretl HEVIYPE might have an associated CLOSURE that coughs up one
clement at :\ time. r(>|nt'|||ht'rtttg between calls how far it got. Often only one ATOM will be included
in the ClOStlR£, with :1 value in the CLOSURE that is a structure containing all the relevant
information.
9.l0 - 9.ll Functions
!_
 
t
 
 
 m
L
 
L
 @
 $



The MD]. Prngrattttttittg; Language 39
Chapter 10. Looping
t0.|. PRoc_.1mt mm.-tr [:1
PROG and RE FEAT arr almost ntvntical FSU8Rs which make it possible to vary the order of EVALuation
arbitrarily -- that is. to have "_iutups". The syntax of FROG ("program") is
(FROG .1cI:.4.'om .1u.\:/ir-I bédy)
whore
ncl i\ an nption.1II\T0H, which is bound to the ACTXVATION of the PROG.
au\- i\ a LIST \\|ti<‘lt lnnlts ex.-ictly like that part of 2 FUNCTION} argument LIST which follows
an "AUX", and srrvi-> rwnctly the same purpose. It is not optional. If you need no temporary
varinhles nr "ACT", make it ().
bod; is .1 nnn-zero nntnbt-r of arbitrary MDL expressions.
The syntax of REPE/\t is identical. except that. of course. REPEAT is the first element of the FORH,
not PROG.
l0.l.l. B:4'-it‘ EV/\ltt.1tinn [l]
Upon vltlrrittg .1 FROG, an I\CTtVAH'Otd is altvays generated. If there is an ATOM itt the right place.
the /\(ZTlV/\i1ON i~ aim lmninl to that AYOM. The variables in the aux (if any) are then bound as
indicrttvrl in the 2'./~ All of the ('\prt.'\$io|ts in bod)/are then EVALuated in their order oi‘ occurrence.
If nothing t|ntr\\\':\ttl happens. you lent-'0 the PROG upon evaluating the last expression in body.
returning the \-nine nf that |_1\| (‘Xp|’('5§i()||_
PROG thus provides .1 \v:ty tn package together a group of things you wish to do. in a somewhat more
limited way lltatt can he tlnnc with ;i FUNCYION. But PR06s are generally used for their other
properties.
l0 - l0.l.l Looping
L
I
I
I
I
I
I
I
I
I»
I
I
I
I
I‘
I
I
I
II‘



90 The MDL Programming Language
REPEAT acts in nll ways exactly like a PROG whose last expression is (AGAIN). The only way to leave
a REPEAT is to explicitly use RETURN (or G0 with a TAG - section l0.4).
l0.l.‘Z. AG/\iN and Rl TURN in FROG and REPEAT [I]
‘within a FROG nr R['l"EI\T, you always have a defined ACTIVATION, whether you bind it to an ATOH
or not. [In fart the iutcrprrtcr binds it l0 the ATOM LPROG\ !—INTERRUPTS (‘last PROG"). The FSUBR
BIND is irlentiral tn PROG except that BIND does not bind that ATOH. so that AGAIN and RETURN with
no ACT IVAIION argument will not refer to it. This feature could be useful within HACROs.]
if AGAIN is nsml with no argnnu-nts. it uses the ACTIVATION of the closest surrounding PROS or
REPEAT tyithin the \'_l‘l[l'f_IL(ill_ll(;iﬂ (an error occurs if there is none) and re-starts the FROG or
REPEAT tvithnnt rt-binding the aux variables. just the way it works in 3 FUNCTION. With an
argtttncnt. it can nf cnttrst: rc-start any Function (FROG or REPEAT or FUNCTION) within which it is
emhedrlrd :tl rtttt time.
As with AGAIN. if RETURN is given no ACTIVATION argument. it uses the ACTIVATION of the closest
snrronntlim; FROG or REPEAT within the current function and causes that PROG or REPEAT to
terminate and rrtnrn RElURN's first argument. lf RETURN is given Q arguments. it causes the
closest 2-nrrmmtling FROG or REPEAT to return the ATOM T. Also like AGAIN, it can. with an
ACT IVATIOH argument, terminate any Function within which it is embedded at run time.
lO.l.3. EN2Ill|)iP‘\ [I]
Examples rvf thr ttsc nf FROG are difficult to find. since it is almost never necessary. and it slows
down the intrrprrtcr (chapter ‘2-l). PROG can be useful as a point of return from the middle of a
cotnptttatinn. nr inside ;| COHIJ (which see). but we won't exemplify these uses. Instead. what follows
is an caainplc of a typically poor use of PROS which has been observed among Lisp (Moon. I974)
pr0gra|\\tn('|\ using MDL. Tltnt. thr same thing is done using REPEAT. In both cases. the example
FUNCTION just adds up all its arguments and returns the sum. (The SUBR GO ls discussed in section
l0.4.)
;“L15n style‘
(DEFINE HY‘ ("'lUPl£" TUP)
(FROG (SUM)
(SET SUH D)
L9 <COND (<EHPTY? .TUP) (RETURN .SUH>)>
(SET SUM <4- .SUP'l <1 .TUP>>)
(SET TU? (REST .TUP)>
(GO LP>))
l0.l.l - l0.l.3 Looping
I
|'l'I'I'|'l'|'I'l'l'I'|'l'|'l'lI'l'l'l'|'|'|'l'



F’-
The MDL l‘r0gr:unnting Language 91
;--not style"
<0:rmc mu ("TUPLE“ tum
<REPEAT ((sur1 0))
<corto t<sm>tv1 .tut>> <RE'l’URN .sun>)>
<set sun <¢ .sut1 <1 .TUP>>
<sn tuv (REST .TUP>>>>
Of course. neither nf the above is optimal MDL code for this problem. since HY+ can be written
using SEGMENT £‘\'altt;\li0tI as
(l)l:l- INF HYQ ("1UPLE" TU?) (0 |.TUP)>
There arc. nf t-muse. lots of problems which can't be handled so simply. and lots of uses for REPEAT.
I02. MAPF nntl llAf&§§sics ll
MAPF ("unzip l'ir\t"l :inr1 t1/\PR("tnap rut") are two SUl3Rs which take care of at majority of cases which
require Iﬂttpx nvt-r tlata. The hnsic idea is the following:
Suppose you l\.'\\'(‘ .1 LIST (nr nthcr structure) of data. and you want to apply a particular function
to each rt:-tnr-uv That l'~ exactly what MAPF docs: you give it the function and the structure. and it
applies the t'nnt-ttrm to each clt-nu.-nt of the structure. starting with the first.
On Ill!’-I'\lll('|' hand, utppmc ynn \\'.1||l tn change each element of a structurc according to a
partit-ut:\r .tlgnrnlttu. This can ho tllntt‘ only with great pain using MAPF, since you don't have easy
:tccc\\ In tho '~tt_ut|ur§ iusitlc the function: you have only the structure's elements. MAPR solves the
prnhlt-in h_\ applying :1 function to RESH of a structure: first to <RE5T structure O>, then to
<RESt n’-':,r.'t/*/‘ t>_ rtr. Thus. the function can change tlu: structure by changing its argument.
for cxatnplc. h_\ .1 <I'UI .-'_-;u/--rn.‘ l r.c~=cI1=.'n5>. lt can even PU‘! a new clement farther down the
structure, which uill he set-u by the function on subsequent applications.
Nmv \|||>|>n~(-_ in ittltlittntt tn :tppl_\'tng .1 function to a structurc. you want to record the results -- the
vnlut-s re-tutnt-tl It)‘ the l't|nrImn -- lll another structure. Both HAPF and HAPR can do this: they both
take an adtltttnttitl functirin as an argument. and. when the looping is over. apply the additional
fuuctinn tn ;_lt the tcutlts, and than rcturn the result of that application. Thus. if the additional
function is ,t IST. }t\u gr! a IIST of the previous results: if it is ,VECTOR, you get 2 VECTOR of
results: etc.
Finally. it inn;ht he the casr that you really want to loop a function over more than one structure
sittttiltaiivnitsly Fnr instance. consider crt-ating a LIST whose elements are the clement-by-element
stun of the t‘r\ttlt'||t\ of two other LlSTs. Both MAPF and P-APR allow this: you can. in fact. give each
of tlii-in nny nntuhct of structures full of arguments for your looping function.
lO.l.3 ~ lO.2 Looping



T
92 The MDL Progralntning Language
This \\':\s all tucutu-nu-it hcc..1ttsc MAPF and HAPR appear to be complex when seen baldly. due to the
fact that thr :ir_quturnt ilrscriptions must take into account the general case. Simpler. degenerate
cases are u~ttall)' the nnc-s ll$PL|.
t0.2.t.t~1Am [1]
(HIAPT Ivrtaff /cup! 51 52  5N>
where (nftttr arguuicnt evaluation)
/tlmll ii, -mnrtlitug .1p|>licablt~ that evaluates all its arguments. or a FALSE;
IO!Jp-' |\ ~niiu~tliiu§_; npplicnhlr tn N argutnents that evaluates all its arguments: and
:1 lltrrungh  arc \trncturnl objects (any TYPE)
does the fhllnwitnjt
(ll Fir\t. it applies loop! tn N argttturuts: the first element of each of the structures. Then it
RF S1-. rarli nt thr urtu-ti|rc<..1vt¢ltlnc<the application again. looping until any of the structures
runs nut nr ('ll"|l|PlIl!~. F.-irh nf thr values rcturncd by loop! is recorded itt a TUPLE .
I12) 'l'hr~n it ;\[\!\|l(‘\ .’r!t.)/I tn all Ilu: rt-corded values simultaneously. and returns the result of that
appltcatimi ll t..-~,=n i\ a rm SE. the rccortlcd values are "thrown away’ (actually never recorded
in Iht- rH'\l plaivl .1nil tho HAPF returns only the last value returned by Ioopf. If any of the si
sitrttrtttttw |- vrtttpl}. an that /OOp~' is never invoked. fmall is applied to tug arguments; if final! is a
FALSL . r-mt-r |clttrlI$ ﬂFALSE ().
t0.2.2. r1/wt: [1]
(H/\PR t'lV7,1// loop! .'-I "-2  s/V)
acts just like H/\l>F, but. instead nf applying loop! to NTHs of the structures -- that is, <NTH si 1),
<NTH :1 2), etc. -- it applies it to RESTs of the structures -- that is. <REST SI 0), (RES? si 1), etc.
l0.2.3. EX3Iltp|(‘\ [I]
Make the (‘|Pl|lF|l|~\\'I\e \t|nt of two LISTs:
<HAPF _llSl .* ‘(l 2 3 4) ‘(l0 ll 12 l3)>S
( ll 13 l5 17)
t0.2 - 10.2.3 Looping
5-
' al-
' ' - er
Z
_I'
I
l
in i l



The M Dl. l’rn|_.;r:nnn|iug Langltagv 93
Change 2 U\Il CTOR to contain dnublc its values:
<ser uv --[5 5 7 a 91>;
-[5 0 7 a 9-1
<nAvR <>
vruuctton ttt) (PUT .L 1 <- <1 .L> 2>>)
.uv>s
e(1a-1
.uvs
-[to 12 ta 16 tat]
Create :\ STRING ftom CllI\RACT[Rs:
(H/\l‘F .SlRIHG I '["|‘10DELING" "DEVELOPMENT" "LIBRARY“])$
"MDL"
Sum the s||||3|('s of the c-lcnu-uts of a UVECTOR:
<l“If\l‘l' ,0 ‘FUNCTION ((N) (" .N .N)) '![3 4]>$
7,
J
A par.1lk~l:\v~i;;t\|nc-nt FUHCI ION (Nnte that the arguments to HAPF are of different lcngths.):
<DYFlHF PSCT ('lUPLE' TU?)
<ﬂAPF <)
.SET
.TUP
(REST .TUP (I (LENGTH .TUP> Z>>>>S
PSET
<PSET A B C I 2 3)$
J
.A$
l
.05
2
‘CS
3
Note: it is t~:;\_\' tn Fnt[_'(‘| that //rut’! mugt evaluate its arguments. which precludes the use of an
FSUBR. lt i~|>r|m.1nly for this reaum that the SUBRs AND? and OR? were invented, As an example.
the predtcntc =’ untltl h.1\'t' bvrn defined this way:
10.2.3 Looping
F
F
F
Ft
F
F
F



94 The MDL Programming Language
(DEFINE =7 (A B)
<COND (<HONAD? .A) (==? .A .B>)
(<AND (NOT <HONAD7 .B)>
<==? (TYPE .A> (TYPE .B>)
(==? (LENGTH .A> (LENGTH .8>>>
(HAPF ,AND? ,=? .A .B))>)
[By the way. Iln: following shows how to construct a value that has the same TYPE as an argument.
(DEFINE MAP-NOT (S)
(CON!) ((Hl'MO <PRll"lTYPE .5) '![LIST VECTOR UVECTOR STRING])
(CHTYPE <HI\PF ,(PRIﬂTYPE .S> .NOT .5)
(TYPE .S)))>)
It works ltornttw the l\TOt1< that name the common STRUCTURED PRIl1TYPEs (LIST, VECTOR.
UVECTOR and STRING) have as GVI\Ls the corresponding SUBR.s to build objects of those TYPEs.]
1113- M $5.9-,1. 5./\ F‘F.~t~1.I.<i.*&PL1
lD.3.l_ Hl\l’Rl-, l
MAPRET it .1 SUBR that cnablrs lltc loop! being nscd in a MAPR or HAPF (and lexically within it. that is.
not $(‘|)J\I'.'l|(‘(| frmn it hy a fnnetion call) to rctttrn from zero to any number of values as opposed to
just one. For c.\a|nplt-_ .\ttp|"ln.\F a HM‘? of the following form is used:
<MAl‘l' .LIST (FUNCTION (E) ...> ...)
Now snppow that the pmgrnnnncr wattts to add no elements to the final LIST on sutne calls to the
FUNCTION and ntltl ntany nn other calls to the FUNCTION. To accomplish this. the FUNCTION simply
calls MAPRCI with the (‘lr|ttt‘ttl\ it wants added to the LIST. More generally. HAPRET causes its
argument- tn hr ntltlrti tn the final TUPLE of argnntcnts to which the final! will be applied.
Warning: HAPRET is gttarntttced to wort». only if it is called from an explicit FUNCTION which is the
sv.-contl nrgntncnt tn a MAN’ or HAPR. ln other words. the second argument to HAPF or HAPR must be
IFUNCTION (. . . ) nr (FUNCTION . . .> if HAPRET is to be used.
Example: the fnllmving returns a LIST of all the ATOM itt an OBLIST (chapter I5):
(DEFINE ATOHS (Oil)
(MAPF . LIST
(FUNCTION (BKT) <HAPRET !.BKT>>
.OB>>
t0.2.3 - l0.3.l Looping
Y
t,._
HHHHHHHHHHHHHHHHHHHHHHHH



Y
__
II
Tlie MDI, Prngramniing Language 95
lQ32.NAPSTOP
HAPSTOP is the samc as HAPREL l"\C(‘])( tliai, after adding its arguments. if any to the final TUPLE,
it forces the .’l|)|)|i£-'llif‘l|l of fi'n.=// to occur. wlietlier or not the structured objects have run out Of
elcntcnts. I-I.\ain|ilc:tlic fnllnwin co ‘ l f‘ '
g PICS t l(' irat tcii (or all) elements of its argument into a LIST:
(DEFINE F1RSl~l[N (SIRUC "AUX" (I 10))
(HAPF ,LISl
(FUNCTION (E)
(COMO (<0? <SET I <- .1 l>)> (HAPSTOP .E>))
.E>
.STRUC)>
l0.3.3. M/\PLl;‘I\VE
H/\PL[I\Vl' is .'\l\.'l|ﬁ!ﬂIl\ in REHJRN. cxrcpt that it works m (lexically within) MAPF or MAPR instead of
PROG nr Rt» l‘l Al _ li fliislii-s the acemmilatcd TUPLE of results and returns its argument (optional. T
by dcf.1iilt).1s the vnhic nf ilic H/\I‘F or HAPR. (lt finds the MAPF/R that should return in the current
binding of the ATOH LP1/\l‘\ !-IIHKRRUPTS ("last tnap").) Example: the following finds and returns
the first nmi-rcrn (‘|(‘l\I(‘lll of its argnnieiit. or IFALSE () if there is none:
(DEFINE FIRST-ND (STRUC)
<HAl'F (>
(FUNCTION (X)
(CON!) ((N==? .X O) (H/XPLEAVE .X>)>)
.$TRUC))
lO.3.-I. Only two argmiicnts
If HAP!‘ nr HAPR is git-rii niily twn argmiiciits. the itcratioii function loop! is applied to no arguments
h '
eac tune. :mil i|ii- limping cnntmncs indefinitely until a HAPLEAVE or HAPSTOP is invoked.
EX-'llIIp|l‘2 the fnllmvm; returns :i LIST of the integers from one less than its argument to zero.
(DEFINE LNUH (N)
<!'l/\Pi' .1 IST
(FUNCTION ()
(COM) ((07 (SET N <- .N l>>) <HAPSTOP 0))
(ELSE .N))))>
One prmciplr iisv nl' this fmm of MAPF/R involves processing input characters. iti cases where you
ilnn't ‘\||l"l\\' l ' - ' ’ ' '
mu mrmy iliai.1rti~ts arc going to arrive. The example below demonstrates this. using
SUBRs which are llH'Il’(‘ fully cxiilamcd in cliapicr ll. Another example can be found in chapter 13.
l0.3.?_ - 10.3.4 Looping



T‘
96 The MDL Programming Language
Exalttplvz tho l'nlIn\\-ing FUNCTION rrnds characttrs from tit: current input channel until an $ (ESC)
is read. and than rrtnrtts wltnt was rend as one STRING. (The SUBR READCHR reads one character from
the input chattnt-l and rctttrns it. NEXTCHR returns the next CHARACTER which READCHR will rzturn -
chaptcr H.)
(DEFINE RDSIR ()
(NAPF ,STRING
(FUNCTION () <COND ((NOT (==7 <NEXTCHR) (ASCII 27>))
(READCHR))
(T
(HAPSTOP)))>))$
RDSIR
(FROG () (RE/\DCllR> ;"Fiush the ESC ending this input.‘
(RDSlR))S
/\l1Cl23<+ 3 4>$"ABCl23(+ 3 4)‘
l0.3.5. STACKFORH
I The TSLIRH 51/RCKI ORH is archaic. due to improvements in the implementation of MAPF/R. and it
should not hr ttscd in new programs.
<S1!\CKFORH /un€Ii0r1 arg pred)
is exactly r-quivalrttt tn
(MAN /gtrt(.'IQIt
<TUHCllON () (CORD (prcd erg) (T (HAPSTOP>)>)>
In fact .\i/'\ l'l-'/R i\ tttﬂrt‘ powerful, became HAPRET. HAPSTOP, attd HAPLEAVE provide flexibility not
availnhlr wttlt STACKFORH.
10.4. GO .'\_tnl VTILG
G0 is. |)rn\'i\|t"\i tn .\lUl. fnr pt'ﬂ|>i? wlm can't rccovzr from a youthful experience with Basic. Fortran.
PLII. cu: 'l'hr Sllttm arovinttxly tltsrrillcd in this cha ter are tnuch more tasteful for makin cod.
I . P
clean. "~trttcttt|rt|" |un-:;r.1|ns. GO just bnllixcs things.
G0 is :1 SUBR nlttch Rllnws you to brrak the nortnal order of evaluation and re-start just before any
top-lcvrl t‘\|tr(‘\\itIt| tn a FROG nr REPEAT. it can take two TYPE; of arguments: ATOM or TAG.
10.3.4 - 10.4 Looping



an
The M Dl. l’rm_'tantttttttg Langttnge 97
Given :|t| t‘\iOll, (-0 ~.t-:trrht-s the body nf tho ittnttcdiately surrouttding PROS or REPEAT within the
current Flttwtt-~t|. \l.tttitt[§ :\l't(-1 nil». fnr an occurrence of that ATOM at the lop level of body. (This
5(‘IH'(|t is l‘|fl'(ll\'(‘i_\t‘ .1 Htjt-10.) ll‘ it tll-it-sn't find thc ATOH, an error occurs. If it does. evaluation is
restltncd .11 thv l'\|\Il"~'~|f‘II| fnllnwing thr ATOM.
The SUBR TAT. X_'(‘Ht'l.‘llL“v and |('l\Il’ll§ objects of TYPE TAG. This SUBR takes one argument: an ATOM
whirl: wrtnltl liu .1 lvqal :tti;lttttt‘ttl for a G0. An object of TYPE TAG contains sufficicnt information
to .1llo\\- \‘ﬂt| tn GO in any IfI|\-|t‘\‘(‘| pmitinn in a FROG or REPEAT front within any function called
inside tltt" Punt; ﬂt PKPF/\l. GO with :1 TAG is v:t_qut'ly like AGAIN with an ACTIVATION; it allows you
to "go lmtl“ in thv tniilillv of any FROG or REPEAT which called you. Also like ACTIVATIOPB. TAGs
into .1 FROG rvr RFPITAT r.\|t no lnngcr hr uscd after the PROG or REPEAT has returned. LEGAL? can be
used to wr if .1 lt\G iw still valid.
10.5. Lﬂﬁ|\|‘llg'V\_"(‘l uts R t*ctg.\i_Qt1
Since any |HH:_'r.1ttt in .\ll)l. can be callctl recursively. chmnpions of "pure Lisp” (Moon. I974) or
snntvsnrh ni.~ty ln- tvntptml Iﬂ int|ili~tm~nt any rcpctitivc algorithm using recursion. The advantage
of tlic lnnpini; tr-vlmiqttz-s (|P\(‘l'iiI(‘I| in this clinptcr ovrr recursion is th:|t the overhead of calls is
(‘|iIllllIf\l(‘(i. llvm-t-\ vi. :\ lnng prngrant (say. bigger than half a printed page) may be more difficult
to write itcr.u|\‘clv than rccutsivcly and hence more difficult to maintain. A program whose:
repetition is cnnttnllml h_v .1 sttuctnrcd object (for example. "\vall»;ing a tree" to visit each tnonad in
the ol)J'('vl) often shnttld ttsc looping for covering one "level" of the structure and recursion to change
"levels".
l0/1 - l0.5 Looping



98 The MDL Programming Language
Chapter 11. Input/Output
The MDL -nteiprrter ran transmit inl'nrmatinn between an object in MDL and an external device
in three wa_\-\. ||t\t0ri(‘§Il|)'. the first way was to convert an object into a string of characters. or
vice versa. The tran-|‘nr|nation is nt-arly one-tn-one (although some MDL objects, for example
TUPLE\. ctlttnrvt ho input in this way) and is similar in style to Fortran's formatted IIO. It is what
READ and PRINI (lo, and it is the normal ntethod for terminal I/O.
The '-l‘Cn||tl way is. used fnr the contents of MDL objccts rather than the objects themselves. Here
an tings nf nnmhris nr characters within an object is transmitted, similar in style to Fortran's
tlttforlltaltetl l/O.
The thirtl \va\‘ is tn tlllltp an nbjcct in a clever format so that it can be reproduced exactly when
input the nr-\-t time. Exact reproduction means that any sharing between structures or self-
referenec is |:rt‘\rr\'('dt only the garbage collector itself can do l/O in this way.
ll.lt CQtt\'t-rsim|__l/Q
All convctsinn-I/O suntts in Mill, take an optional argument which directs their attention to a
specific l/O cli;inm~l. This section will describe 5UBRs without their optional arguments. In this
situatinu. they all it-for tu zi particular channel by default, initially the terminal running the MDL.
Wlieti given an nptinnal attgutuent. that argument follnws any arguments indicated here. Some of
these SlIl‘lR\ alsn have atlditinnal optional arguments. relevant to conversion. discussion of which will
be deferred until later.
ll.l.l. Input
All of the fnllnuitigg input Subroutines. when directed at a terminal. hang until S (ESC) is typed and
allow normal use of rubnul. “D. “L and "@.
ll - ll.t.l tnputIOutput
“T



“,-
T||e Mltl l’rnt;r.1|ntning Language 99
ll,l.l.l. Rl All
<RFhD)
This rt~tn|'tt'~ the rnttrr MDl nh_|t~ct whose character representation is next in the input streatnl
Succc_\si\'v <R| rttv>~ |'t‘lt|r|| sncrt-ssive nbjt-cts. This is precisely the SUBR READ tnentioned in chapter
24 See ntsn '~t'(‘||IIll'~ ll.3t l5.7.l. and l7.|.3 for optional argttlneltts.
Il.l.l.?.. Rf/\FH"llR
(RFAUCHR)
("read rh:t|-.1rtt-r") rctnrns the ne>tt CHARACTER in the input stream. Successive <READCHR>s return
s||(;<;cs.sive (‘MAR/\C YER!-.
ll.l.l.3. Hf Xl(‘.lll~t
<HEX‘lCHR>
("next ch.1r.1ctcr"l rt-turns the CHARACTER which READCHR will return the next time READCHR is called.
Multiple <HE>ttCHR >s. with no inpttt operations between them. all return the same thing.
ll.l.‘Z, Ottt|)ltl
lf an nbjt-ct tn he nntpnt rvqttircs (or can tolerate) separators within it (for example. between the
elements in a structured object or after the TYPE ttante in "I notation"), these conversion-output
SU8Rs will use a r.1rri:tgv-rmttrtt/line-feed separator to prevent overflowing a line. Overflow is
detected in advance from elements of the CHANNEL in use (section ll.2.8).
ll.l.2.l. PRINT
(PRINT alty)
This nutpuls. in otdcr.
(l) :1 (‘.'\rri:|§gt‘-reltlrll lint--feed,
(2) the charactt-r representational’ EVAL of its argument (PRINY is a SUBR). and
(3) a space
and then returns EVAL nf its argument. This is precisely the SUBR PRINT mentioned in chapter 2.
ll.l.2.'Z. PRINl
<r~n1ut RH} >
Outputs just llte representation of. and returns. EVAL of any.
ll.l.l.l - ll.|.2.2 Input/Output



I00 The MDL Programming Language
ll.l.2.3. PR lHC
<r-ntuc .=~_\»>
("print cl|.1r.1ct¢-rs") acts exactly like PRINI . except that
(ll if its nrgtuncnt is :1 STRING or a CHARACTER, it suppresses the surrounding "s or initial !\
I‘cs|1t'cti\'vl)': nr.
(‘ll if its .1r|_;mm~nt is an ATOM, it suppresses any \s or OBLIST trailers (chapter 15) which would
nllnt-r\~'is(' he necessary.
H‘ I‘RlN\‘.'s :1rgntnrnt is a structure containing STRINGs. CHARACTERs. or ATO¢1s,lh: service mentioned
will be tlmm for all nf them. Ditto for the ATOM uscd to natnc the TYPE in “I notation".
“IlA2v44 HIRPR1
(T[Rl'RI>
(“tertnitmtc printing") outputs a carriage-rcturn line-feed and then returns IFALSE ()!
lLl.‘Z.5, CRLI
<CRLT>
(“carriage-rvttirtt |inr'-ford") nulputs a carriagcvrclurn linc>ft:r:d and then returns T.
ll.l.2.6. FLATSIZC
(Fl/\TSl1E any rnav;/1:! rad»-':/tr)
dOt:s not -‘l(‘llI.'\“\' rnnsr any nntpnt to nccnr and docs nut take a CHANNEL argument. Instead. it
compart-s ~>.=~ with thr number of characters PRIM would take to print any. If max is less than the
ntttnber of clmtartrrs ttcmlrd (including the case where any is self-rcferetlcingl. FLATSIZE returns
IFALSE (); nl||\‘l\vi\l'. ll rrxurns the number of characters needed to PRINI any. radix (optional. ten
by dcfaultl IS usrtl fnr convcrting any FIXes that occur.
This SUBR is L-<p<>ci.1lly useful nu cnttjttttctiott with (section ll.2.8) those eletnents of a CHANNEL
which spccify the number of charactcrs per output line and the current position on an output line.
ll.l.2.3 - ll.l.2.6 lnputIOutput
l
Lllltllll L
 
Lilli L
 
Lil
ll



The MDL l"rngr:nn|ning Language lﬂl
H2. CHI\l¢!l'[>'_£_(l‘l_|§_‘T_\lF_f_§)
I/O clmnnvls arc rt)'n.~nnic:\lly assigned in MDL. and are represented by an object of TYPE CHANNEL.
which is of l‘RIMIYl‘E_ VECTOR. The format of a CHANNEL will be explained later. in section
ll.2.8. First. lmw tn generate and use them.
ll-2.l. OPEN
<OPCN mode /iIe—spec>
or
<Ol"(N mode manta.-I name? dowce d1r>
OPEN is .-t $.t|BR whiih creates and returns a CHANNEL. All its arguments must be of TYPE STRING,
and .'_\_l_I_ arc nptimml. The preceding statement is false when the device is ‘INT’ or “NET”; see
sectinns ll Tl nnil ll.l0. lf the attempted opening of an operating-system l/O channel fails. OPEN
returns -l'I\lSF ('r~-'<OI':s"H>;! /'/B-Spﬁtrifrirlg slalus:/ix), where the reason and the sfafus are
supplied by the operating systent. and the hie-spec is the standard name of the file (after any name
transfnrnnitinns by the operating system) that MDL was trying ta open.
The clmii-0 nf ~»c>.1i- is nsnally iletorininerl by which SUBRs will be used on the CHANNEL, and whether
or not the dr-. Mr is .1 terminal. The following table tells which SUBR.s can be used with which modes.
where OK imlicatcs an allowed use:
"READ" "PRINT" "Rl:AU8" "PRINTS" tnode/SUBR§
“PRINTO"
OK OK READ READCHR NEXTCHR READSTRING FILECOPY FILE-LENGTH
LOAD
OK OK‘ PRINT PRINl PRINC IMAGE CRLF TERPRI FILECOPY
PRINTSTRING BUFOUT NETS RENAME
OK READB GC-READ
OK PRINTB GC-DUHP
OK OK OK ACCESS
OK OK OK OK RESET
OK OK ECHOPATR
OK TTVECNO TYI
1' PRINTing (or l‘RINling) an RSUBR (chapter I9) on a ‘PRINTS’ or "PRINl’O" CHANNEL has special
effects.
"PRlNT8" ilifft-rs frmn "PRINTO" in that the latter mode is used to update I "DSK“ file without
copying it. "RI~lI\l‘lB" atnl "PRINT8" are not used with terminals. "READ" is the mode used by
default.
ll.‘Z - ll.2.l Input/Output



I02 The MDL Programming Language
The nc-\| nnr to fnur argttinettu to OPEN specify the file involved. If only one STRING is used. it
can rmtmtn the rntirc qtceificatiott. according to standard operating-system syntax. Otherwise. the
string(.s) are interpreted 21$ follows;
Marni‘! is the l'ir\t filo n.1|nz~. that part to the left of the space (in the ITS version) or period (in the
Tc-nex .-and '|'r\p\~20 versions). The nante used by default is <VALUE NIH). if any. otherwise
" INPUI " .
/1.1/m-2 5-. the scrnlttl filo natnc. that part tn the right of the space (ITS) or period (Tenex and Tops-
20). The ||:\ntt' t|\t't| hy tlrfanlt i~ <\l»'tLU[ HM?>. if any. otherwise ">“ (ITS) or ‘HUD’ and highest
version ntttnher (Tcncx) or generation nnntL\er (Tops<2O).
dewze ie the ttt~\‘i<c u.1tt|e. The n:tutt' used by default is (VALUE DEV), if any. otherwise "DSK'.
I (Devin-w almttt which M DI has nn aprcial knowh-dge are assumed to behave like "D574"-)
d/r is the t||\l.-tlir(‘(‘l\'Il')' natne. The n:unl: used by default is (VALUE SNM>, if any. Otherwise the
"workittg-tlirrctnry" natnc as defined by the operating systcnt.
E.XIllIpl95i
<0P£N "PRINT " "TPL :" > f1|lr.‘ns ;t c0|l\'€rsiO||-nulpul CHANNEL to the TPL device.
(OPEN "PRIHI " "lH_ll1HY" "NAMES" "TPL"> does the same.
(OPEN "l'RlNl" "IV! "> opens A CHANNEL to the file D5K:TPL > (ITS version) Or DSK:TPL.HUD
(Tenex nml Tnp\-"J0 versinnsl.
<OPEH "RF_/\[)" "I 00" ">" "D551" "GUEST"> opens a conversion-input CHANNEL to the given file.
(OPEN "RlAD" “GUEST;FOO" > docs the same in the ITS version.
ll.2.‘Z. OF‘FH—NR
OPEN—NR l\ the '~.'\I||l' as OPEN. except that the date and time of last reference of the opened file are
not cliattgctl.
|l.‘Z.3. CH/\NHEL (the SUBR)
CHAHNFL is r.1llrtlv>.-truly like OPFN. hut it always returns an unopened CHANNEL. which can later be
opened hy RESLI (bttlowl Jun a> if it had once been open.
ll.2.l - ll.2.3 Input/Output



The MD]. l'rﬁgr:ttttttti|tg Laugttzlgr [D3
ll_'Z.4. l'Ill’~l XISIS?
FILE-[,Xl$tb? test- for tltt- t-xistt-nce of :1 file without creating a CHANNEL. which occupies about a
|\|||\tlr(‘tl nmcliinc \\t\I'l|\ of storage. lt takes file-name argttntents just like OPEN (but tto made
.-trgtttnrntl :tttrl rrlttttts ritltcr I or FTALSE (reason.-string status:/ix). where the reason and the status
are al||)p|it'd by the operating system. The date and titnc of lzsl reference of the file are not
cltangt-d.
ll.'Z.5. CLOSE
<ClOSE <‘h,=mwI>
clﬂscs (‘.",¥","!‘/ .1t|tl rt‘1t|rtt\ ll.'\ .1rr;nincnt_ with its "state" changed to "closed". If channel is for output.
all littfl'ctuJ otttptt! is tvtittcn tntt first. No hartn is done if channel is already CLOSEd.
ll.'Z.G. CHf\Nl IST
<C|lAHl.ISl>
returns .1 ltST wltmo r-Ir-tnettts are all the currently open CHl'\NNELs. The first two elements are
uutally . IHCHAH and .OUTCHAN (sec below). A CHANNEL not referenced by anything except
(Cl-lANl KS1 > will lit‘ CLOSE! tlnring gatbage collection.
|l.2.7. IN(‘l|/\N.1t\tl OUTCHAN
The t‘|\.1l|ttt'l tt\t'tl hy rlrfattll for tnpnt $Ll8Rs is the local value of the ATOM INCHAN. The channel
used by tit-f.1nlt fnr rvttlptll Stt8Rt is the local value of the ATOM OUTCHAN.
You t‘:t|t dirt-ct l/() tn .1 CH/\NNl'L hy SCTting INCIIAN or OUTCHAN (remembering their old values
sntm-wltt-rt-l. Hr l)_\‘ qi\'||t_q Hut‘ SIINR you wish to use an argument of TYPE CHANNEL. (These actually
have the saint‘ efft-rt, ltr't".1|t\r R[I'\[Jbil1tls INCHAN to an explicit argument. and PRINT binds OUTCHAN
sit1tilatl_y 'l‘ltu- tltc CHANHljl living t|\(‘tl is available for READ macros (section l7.l) and PRINTTYPEs
(section G.-I,-ll)
By tho \\.1)', .1 ,>_-nntt trit-L fur |>l:t_ytng with INCHAN and OUTCHAN within a function is to use the ATOM:
Ittcllmt .~tntl Ottttltml as "AUX" \'ﬂl'it'\b|('$. ru-bitttling their local values to the CHANNEL you want.
“'12:-tt you |('.1\'t'. of cutttxt-_ the nltl lV»‘\l,s arc restored (which is the whole point) Thf ATOH5 ""45! bf
declarotl SPH‘. lf\l (cltnptcr ltl) for this trick to compile correctly.
INCH/\N and OUTCHAN also have global values. initially the CHANNELs directed at the terminal running
MDL. lttlttally. tNt‘lll\l't'<- .-tint Otll'CllAN's local and global values arc the satnc.
ll.2.4 - ll.2.7 Inpul/Output



I04 The MDL Programming Language
ll.'Z_8. Cnnlttttls of CHANNEL‘
The contents of an object of TYPE CHRNNEL are referred to by the I/O SUBKs each time such a SUBR
is usrtl. ll‘ you t'||:tng1' the coutcuts of a CHANNEL (for example. with PUT). the next use of that
CHANNLL will be rhauged appropriately. Some elements of CHANNELs, however. should be played with
seldom, if ct-er. and nuly at your peril. These are marked below with an e (asterisk). Caveat user.
Tltrre rntlmtt .1 mhlc nr thr rmttents of a CHANNEL, the TYPE of each element. and an interpretation.
The format used is the following:
E/£!n('I|l—FIL/In/39!; It/pa mlerprelaflon
tt.-z.a.1. Ol|I|)lll ctt/ttmtts
The contents of .1 Clt/\NllEL used for output are as follows:
-rest sows.
a°§'§"'T""i'.:i‘.77-'9-"
LIST trntisrript rl|.1unt‘l{s) (sec below)
\':|ru-s de\'|ce-ilepetttlettl tnforntation
FIX ch.1||||t‘l number (ITS) or _|FN (Teuex and Tops-20). 0 for internal or closed
SIR INC ntrulc
STRING l'ir\t filr name argtttm.-tit
~ SH! IHG wcnnd file name argument
STRING tlt'\'it*<‘ name argument
STRING dirt-rtnry uantc argument
SIR IHG rt*:tl l‘ir\t file name
STRING rt"-1| \t-cnntl file natne
0 9: STRING rc.1l tlcvicc natne
elO: STRING rral tlircctnry natnv:
ell: FIX \':trinn\ status hits
->12: FIX PDP-I0 instruction used to do one I/O operation
I3: F IX uumhcr of characters per Iitte of output
I4: FIX rttrrcut rharartcr pnsition on a line
I5: FIX number of lines per page
I6: FIX rttrrcnl line number on a page
I7: FIX atrrss pointer fnr file-oriented devices
I8: FIX ratlix for FIX conv:-rsinn
I9: FIX sink for an internal CHANNEL
N.B.: The clcuu-nts of a CHANNEL below number l are usually invisible but are obtainable via (NTH
<TOP (l1.Irvw~I> ht->, fnr snlnc ﬂ|"l|)l'(\pfIﬂIl' /ix.
The trnu-cript-rliaum~l\ slot has lhis meaning: if this slot contains a LIST of CHANNEIJ. then
anything iuput nr output on thr original CHANNEL is output on these CHANNELs. Caution: do not use
a CHANNFL as its nwu transcript channel: you probably won't live to tell about it.
11.2.8 - l|.2.8.l Input/Output



The M Dl. l’rn_qra|n|ning Languagc 105
I |.2.8.2. I nput C|t!\HHELs
Thv C0l|t('|tI\ of vlm ('i(‘tlIt‘|\l§ up in ulltttbvr l2 of .1 CHANNEL used for input are the same as that for
output. Thv |<-|n:nning t-Iclnenls are as follows ((s2nie) indicates that the use is the same as that for
nutputl:
I3: \':\rtt‘< nh_|r-rt r\':tl|l.'ll('t| wht-it cnd uf file is reaclivd
1 l-1: F IX nnr "look-:\h('ad" clmractvr. ttscd by READ
'15: FIX PDI’-l0 instruction v.\ccut(~d waiting for input
I6: l IST rluruc nf lntffcrs for input front 2 tcrminal
I7: I 1) :u"r('\s pmmer for filv-micntr-d devices (same)
I8: F17 r:ul|\ for FIX conversion tsame)
I9: STRING lnilfrr [nr input nr sottrcc for internal CHANNEL I
11.3. if tt_t_i_-_ﬂ_I_~l"ilr  ﬂit t | n(*"
As menlimtul nhm:-. an (‘\|)|l(‘lX l‘.lif\l.‘r-‘it, I3 tlw first optional argument of all SUBRs uscd for
¢n|t\-¢~r-inn I,'() The wcntutl nptiminl Mgninent for coltversion-ingttt SUBRs is an “end-of-fiic
routine" -- vlmt |\. -mtncvliing for the inptll SUBR to EVAL and rt-turn. if it reaches the end of the file
it is vczuling »\ 1_\|vir.1l rml-nf-filr argumvnt is a OUOTEd FORM which applies a function of your;
The \'.1ltu- of lln- .1rgi||nunt n>v:l la)‘ uh.-fault is 2 nail to ERROR. Note: the CHANNEL has been CLOSEd
by the timr this .\rgun\¢'nt is eralttattrtl.
K-hampli-; tin‘ frvllnuing IIIHCTIOH counts the occurrences of a charactcr in 2 file. according to its
argtttttcltn. Tiw filv unnirs. dz-\-ire. and director)‘ are optional. with the usual names uscd by default.
<[l[FIk'F COtlHl~CllAR
(t‘.l|f\F! "iUF‘LE." FILE “l\UX" (EH1 O) (CHN (OPEN "READ" !.F1LE>))
<COl-‘U (‘CHM ;"If CHR ts FALSE, bad OPEN: return the FALSE
so result can be tested by another FUNCTION.‘
(REPEAT ()
(AND <==° .CHAR <READCHR .CHN ‘(RETURN>>)
(SE1 CNT <+ 1 .CNT>>>>
;"unr,\l EOF. keep reading and testing a character at a time.‘
.CNT ;"‘l'hen return the count.")>>
ll.2.8.2 > ll.3 lnputlOutput



I
l06 The MDL Programming Language
ll.4. ltungctl I/O
ll.4.l. Input
ll.4.l.l. REI\(lB
<RfI\[‘Ifl ht/l!r!.'tl\'(.'rI0I'0!-nfo/P515‘ channel e0l:any>
The r/t,---,-~<~/ lt|t|\l lw n|I(‘|t tn "R!/\Dn" tnnde. READB will read as many 36-bit binary words as
|1(-¢(~§~.,1r)- tn till tlu- .'Vt."/I‘! (\\lm\(~ UYYVE utusl be of PRIHTYPE WORD]. unless it hits the ettd of file.
RFArtn l(‘||lII|\ lltr lIlllllill‘l' nr \\'OId\ actually road. as a FIXcd-point nuntbcr. This will normally be
the lrutgtlt nl tltr' l*."!/rr. uutt--.-. tltr ctul nl’ file was read. in which case it will be less. and only the
begittttiut; nf /~ 3"‘! will lt.1\*elteen ftll('d (SUBSTRUC tnay help). An attempt to READS again. ﬂﬂtf
burrv.» is um l'tllt-tlr will evaluate tltc end-of-file routine eo/. which is optional. a call to ERROR by
default.
ll.4.l.2. RF/\l)STkl ING
(RF/HJSIRING lull/(-I;-flrtrtfj (It.-tnrtzl gfap:/tx—Or—sIrl!1g ea!>
is Ilw SYRII-'6 -1t\=\I't;_' In RIMIB. where bu!/Cr and ea-' are as in READS, and channel is any input
CHANHIL (.Il:tiltm| by tlctnult) 1'-lop lclls \V|I(‘Il to stop inputting: if a FXX, read this many
CHAR/\Ctl'R<1l'|ll lip .'_w’!t-.'|1_y' tlcl’.-iultlz if 3! STRING. stop reading if any CHARACTER in this STRING is
read (<lnu't tttrltttlc this CHf\llACTER in final STRING).
ll.~l.2. Output
ll.-1.2.1. PRINTB
<PRlNll'l In,-!lrr:u\'z‘tIor—or-sforage channel)
This call \\'rtk-\ tht- cutirc rntttcttts of the ouller into the specified channel open in "PRINTB' or
"PRINTO" tttmlv ll t'('lttrtI\ buffer.
tt.-1.2.7.. F‘R‘lNlSlRlHG
<mzttttsttztuc buffer,-s:.’rlng rlumnel Ccurtl.-Itx)
is atlalttgﬂtts to READSTRING. lt mttpttts bu//cf on channel, either the whole thing or the first count
cltaractvrs-. and it-turns tltc tttttttbcr of characters output.
ll.4 - H44-Q-2 Input/Output
'
I I
I j '
I
'
I I  
I



Y
The MUL Prngrattttttittg Language I07
ll.4.2.3l IMAGE;
(IMAGE In’ (hanneI>
is a rnlhcr '~pt'cinl-|:t|r|m\e SLIBR. When any COIlV€f5i0ll—0\llplll routine outputs an ASCII control
charactcr (will: spt-rial o.\ct-plinus likc c:tt'l'i5lgt~t’¢lt|l'll6. line-feeds. ctc.). it actually outputs two
charnctvrs: " [(‘tI(‘IlH|rI(‘\). follntvctl by the upper-cast: character which has been control-shifted.
IMAGE, rm lhr rvllwr lmtttl. nltvnys outputs the real thing: that ASCII character whose ASCII 7-bit
code is /-.-. ll i~ _t;u.-tratttet-d uol to give any gratuitous line-feeds or such. channel is optional.
.OUlC|l/\N II_\‘ tit-Inuit. and its slnts for current character position (number I4) and current line
nutnbcr (lﬁl arr tmt upd:ttt~d. IMAGE returns Ih.
ll.5. Dtttupmly I/_Q
|l.5.l. Output: GC-l‘lUHF'
<GC—Lllll‘1I’ nrw prrrtllr.-r/twine/~or-/.1/se)
tittlltps .m_\ nu ,~.>.'/:r.'- in :1 rlcvcr formal so that GC-READ (below) can reproduce any exactly, including
sharittg. .».:t t'.'t|ttt"l li\-:~ mt tltc rnlttrnl slack. nor can it be of PRIHTYPE PROCESS or LOCO or ASOC
(\vlti(.|t >00?  is telururtu as a value.
IT PF/"//.‘ is .1 c|mr:r:t,t_ it unnt he npcu in "PRlNTB" or "PRINTO" mode. If pr/nib is a FALSE,
GC-Dtlm‘ inumtl mturus .1 tl\/[CTOR (of UIYPE PRIMTYPE WORD) that contains what it would have
Otllpttl mt :t (‘.H/tl-’l.‘LL. 'l'hi.<- UVECYOR can be PRINTBed anywhr.-rc you desire. but. if it is changed i_|1
.-tuv w.L\l. G6-HEMI \\v'lII unl be able tn input it. Probably the only reason to get it is to check its
length lit-l'nrr nutput.
Except for the tniutnlure garbage collection required. GC-DUMP is about twice as fast as PRINT, but
the anmnnt of external slrtragc ttscd is two or thrcc tintes as much.
ll.5.2. Input: GC-RF_I\D
<GC—R['RD rt‘.-n-lb:."lmnrtcI £0/zany)
returns mic 0h_j('¢‘t frnm the cIi.=r-ma/_ which must be open in "READS" mode. The file must have been
produced by GC-l'llll'1P. ear is nptioual. GC-READ is about ten limes faster than READ.
ll.4/2.3 - ll.5.2 lnput/Output



I08 The MDL Programming Language
ll.6. SAVE I-“lrs
I
The entire state of |\‘ll"ll. can hr s.1vctl.-nvay in a file for later restoration: this is done with the SUBR.s
SAVE ant! RESIORE . This is a very diffvreut fnrnt of l/O from any mentioned up to now: the file
uscd rnutnins :ttt .-trtual image of your MDL address space and is ttot. in general. "legible" to other
MDL rnutiucs Rl’$t0Rl tug a SAVE filo is tttttclt fastcr than re-READing the objects it contains.
Sincc a S/\VF t'ilt- tlut-s not contain all extant MDL objects. only the impure and PURIFYed (section
22.0.22] nttrs. :\ rh.1nt;t~ tn thc iutrrprrtt-r has thc rcsult of tuakittg all previous SAVE files unusable.
Tn prt*\'rnt r‘rr0t\ ftnttt arising frmu this. the interpreter has a rclease ntttnbt.-r. which is incrctncntcd
whenovrr rh.1u5;t-s air itt\l:tllt-cl. The (‘ttrrcttl rch.-ase number is printed out on initially starting up
thc prr\;;r.-nu and is .1\-.1tl:thk- as thr GVAL nf the ATOM HUDDLE. This release nutnbcr is written out
as tho rm)‘ rll'~| pail nf cnch SAUET file. if RESTORE attempts to re-load a SAVE file whose release
uunthvr is not tht' \.'ttttr~ as lltr t|tl('rpl't‘l(‘|’ living used. an crror is produced. lf desired. the release
ttuntbt-r nt’ .1 S/Wt’ file can he nhtaiued by doing a READ of that file. Only that initial READ will
work: tho rcst of the filo is not ASCH.
!l.6.l. SAVE
<Sl\VE /l'E'5pC'€:G'FIHS gc?:!a/$8-Or—any>
or
(SAVE r1A!118] nanm? dl‘\/ICE dir gc?:!aIse-0r—arty>
saves lltr entire state of your MDL away in the file specified by its arguments. and then returns
"SAVED". »\ll SYRIHG .tr_gtttttt*uts art‘ optional. with "l“lUDDLE", "SAVE", "DSK". and (VALUE SNH>
used by rlrtnutt gr " is nptinttal attd. it’ supplicd and of TYPE FALSE. causes no garbage collection to
occur hcfnrc S/Wt tug. (FSAVE is an alias for SAVE that may be seen in old programs.)
lf. after it-staring. RESTORL finds that (VALUE SHH> is the ttull STRING (“'l. it will ask the operating
systz-in for tltr ttrttttt‘ of tho "ts-nrltiug directory" and call SNAHE with the result. This mechanism is
handy for "puhli<~" SAVE filt-s. whirl: should not point the user at a particular disk directory.
In the l'l‘S vrrsinn. the (ilr is actually written with the natnc _HUDS_ > and renamed to the
argunionttsi nttly \\'|I(‘II complctc. tn prevent losing a previous SAVE file if a crash occurs. In the
TenI:.\ and Trips-‘Z0 I-'('l'\lDIlS. version/generation numbers provide the same safety.
Example:
ll.$- ll.6.l InputlOutput
.-



I
The MDL l"rngr:\uttuiug Language I09
(DEFINE SAVE-IT ('OVTIONAL'
(FILE '("PUBLIC' ‘SAVE' 'DSK' 'GUEST'))
“AUX” (SNH "))
(SETUP)
<COND (<=? “SAVEO‘ (SAVE !.FILE>> ;'See below.‘
(CLEANUP)
"Savod.')
(T
(CRLF)
CPRINC
<CRLF>
(START
‘Amazing program at. your ser'vlca.">
-RUNNING))>>
ll.5.2. RESTORE
< RESIORI. Ii/o-<pc-c >
or
<RF.Sl0RL !1.1In£‘/ name? device dlr)
replaces tltc rntitc current stair nf ynur MDL with that SAVI-Id it\ the file specified. All arguments
are nptinnal. with the wunc values usctl by default as by SAVE.
RESTORE (‘t\l1\pl('I(‘|)‘ replacr-\ the contents of the MDL. including the state of execution existing
when the S/\Vf_ was dr-no and the state nf all open I/O CHi\NHELs. If a file which was open when the
SAVF was ttnnr tlnvs nnt exist when the RESTORE is done. a message to that effect will appear on the
terminal
A RESIORE never returns (unless it gets an error): it causes a SAVE douc some time ago to return
again (this titnc with the value "P.ESTORCD"), cveu if the SAVE was done in the midst of running a
program. In the latter crust‘. the program will continue its execution upon RESTOREation.
11.7. Ogtyr I/(_)_>l_7_ttiictint\_§_
ll.7.l. LOAD
<LOAD input‘.-ch.mneI /o0k>up>
eventually returns "DONE" . First. however, it READs and EVALJ every MDL object in the file pointed
ll.6.t - ll.7.1 Input/Output
FWFFFFFFPFWFFFWFFF



no The MDL Programming Language
to by mpul. and then CLOSFs input. Any occurrences oi" rubout. “Q, “D, “L, etc., in the file are
given no \p('(‘i3| n|c.1ning: they are simply ATOM constituents.
/colt-up is nptinnal. used In specify a LIST of OBLISTs for the READ. .08LIST is used by default
(chapter l5).
ll.7.2- FLOAD
(FLO/\D Ii/e»spec /O¢|\—up)
or
(FLOR!) name] rtamvé‘ device dtr look-up)
("file Inna") nets jn.-it liL¢- LOAD, net-pt that it takes arguments (with values used by default) like
OPEN, OPI, Ns the CHANHLL ttst-If far reading. attd CLOSE: the CHANNEL when done. lcok—up is optional.
as in LOAD. ll’ the OPEN fails. an rrrrir occurs, giving the reascn for failure.
llt7.3- $HI\llE
<SNAl1l" -:1,”-¢;> ("~.y\tt~tn tunic". .1 hangover from lTS) is identical itt effect with <SETG SNH string),
that is. it r:\tt\r-x 1/rm; to lmcnnu: the air argttntent used by default by all SUBRs which want file
specifirntintts (in the absettre of a local value for SNH) . SNAME returns its argument.
<SNAME> i~. idrtttirnl in cffccl with <GVAL SNH>, lltat is. it returns the current dir used by default.
ll.7.4. ACCESS
(ACCESS rh.>n/ml n.\<>
returns 1/1.»:/-1-I. nrtcr ttt:\Lit|g tlic next character or binary word (depending on the mode of channel,
which '~il4'7ll|Ii llﬂl hr "PRlNl“) which will be inpnt from or output to channel the (hx~l)st one from
the beginning nf the file_ (.'1,1rtrtr.' tnnst be open to a randomly accessible device ("DSK‘. 'USR‘,
etc.). A /I\' of 0 position; (hanrtsl at the beginning of the file.
ll.7.5. FILE-LENGlH
<l'ILE-LENGTH rnpufzclmnnel)
returns a FIX. the length of the file Open on inpul. This information is supplied by the operating
tt.7.t - ll.7.5 lnputI0utput
l



The Ml)l. Prngratnntintg Language lll
sysltnt. nntl it may not be :\vail.1l.\le. for example. with the "NET" device (section ll.l0). If inpufs
motlc is "R[Ar)"_ the length is in characters (rounded up to a multiple of five): if "READS", in
binary tvnrtl.-.. lf ACCESS is applied to inpu! and this length or more. then the next input operation
will ti’:-tact the end of file.
||_7.6. F II ECOPY
< F l L [COPY t!|pul:('1<IIY-'78! oulpuhhannol)
Qnpibk rlt.1t."ttlt‘r\ ft-run /n;-ll! tn Oulpuf until the end of file on input (thus closing inpuf) and returns
the nntnbt-i of ('ll~'lIil(‘|('I'.$ ctlpicd. Both argttmcttts are optional. with .INCHAN and .OUTCHAN used by
(1;-f.1n|t. T(‘$|1t't;li\'('l_\'. The operation is essentially a READSTRING - PRINTSTRIHG loop. Neither
tjt|Attrtt.L ncctl he frrsltly OP[Ncd. and Oufpul need not be immediately CLOSEd. Restriction: internally
a <Ftl.k-tt~ttGItl tHptlf> is done. which must succeed: thus FILECOPY might lose if input is a "NET"
CHANNEL.
ll.7.7. RESFI
(RESET rh.m/teI>
returns t!-.-/--~e-'. .'tl'\t‘t "test-tting" it. Resetting a CHANNEL is lil.e OPENing it afresh. with only the file-
namo ~lnts |)|'t'\er\'t'tl For an input CIMHHEL. this means emptying all input buffers and. if it is a
CttAHHEL tn :4 filo tlning an ACCESS to 0 on it. For an output CHANNEL. this means returning to the
beginning of the file -- which implies. if the mode is not "PRIHTO". destroying any output done to
it so fat. ll’ the opening fails (for cxantple. if the tnode slot of channel says input. and if the file
spccifivtl in its real-natne slots does not exist). RESET (like OPEN) returns IFALSE (re~as0n.'si'!ir1g file-
spr.'c:slrm;; sf.-rlu-2::/t») .
ll.7.8. BUFOU1
<llUT0lll ou!puf:<I»=vme/>
causes all inlvrnal i\ll.)L lmfft-rs for Oulpuf to be written ottt and returns its argument. This is
helpful if the npciztting systnn or MDL is flaky and you want to attempt to minimize your losses.
The output may he patltlctl with up tn four extra spaces. if aurpuI's mode is “PRINT” .
ll.7.9. RENAME
RENAME is for renanting anti deleting files. lt takes three kinds of arguments:
(al two file nntncs. in rithcr singlu~ or nn|lti~STRING format. separated by the ATOM TO,
(bl one filc natnv in either format. or
tl.7.5 - tt.7.9 tnput/Output



II2 The -\tt)L Programming Language
(ct 1. CHI\Itttt‘L :tntt a I'ttt- ttatttr itt either format (only in the ITS version).
Ontittr-tt -tlt‘-||.1tttt‘pJtrl\ tt\t- tt.e santc valucs by default as dues OPEN. If the operation is successful.
RENAML tcttittts I, ﬂIltt'r\vist' vi AISE ('r:as0n.~sfnn_-1 slalus.-hx).
In case tat the file <;it-cifiott by the first argument is rettattted to the second argument. For example:
<R$l.I\r1l “FL--'1 J" TO "ill\R"> ;"RenamQ FOO 3 to BAR >.'
ltt cast‘ tut the '~tnt_'le file ttaute ~.pcriI'it-s a file to be deleted. For example:
(RI;HI\tl[ ‘FOO TOO DSK:HI\RRY;'> ;'De'Iete file FOO FOO from
HARRY’; directory.‘
Itt caw tr) Iltt' t‘|tI\t:ttt‘t tttttst he open tn either "I"R!HT" ur "PR‘INTB‘ mode. and a rett;.|tle while open
for tt-rttittq l\ attt-ntptctl The rc;tI>ttantr: slots in the CHANNEL are updated to reflect any successful
change.
I L8. Tt-rttttit_.1_l__C|tfilitilflt
M DL h:~tt.-ttt~~. |iIt- :ht~ ITS \/rr\i0t| m‘ the test cditc-r T1-co with respect to typing itt carriage-return.
in th:tt t. .ttttn|tt.<ttt.tll)- nttttt .1 Itnc-feed. Itt order to type in a Iotte carriage~return. a carriage-return
f0||t)\\-rt: Ivy tt rttltttttl utttst he typrtt. Also PRINT, PRIH1 and PRINC do not automatically add a litte-
feetl \\‘|ll‘II a r:lt|i.1',_'('-r(‘tt|rtt ts mttpttt. This enables overstriking on a terminal that lacks
b;\cL'~|).'tttt|-\ r.1|>.tt-ility. It a|\t'1 tttrntts that what goes on a terminal and what goes in a file are
more likely tn lnnl. the .~:ttttt.-.
In the ITQ \'t"|sirt|t. .\Il)I_'\ primary zcrittinal (‘ttllptll channel (usually ,OUTCHAN) is normally not in
"di5pl.1)'" |\|0tir- (‘\(t‘|\I \vltt"tt r'Rt:tCittt; :t $lRINGt Thus errors will rarely occur when a user is
typit._\ itt tt~\: tntttnttttttg \ii\pi:t)<IIlf\t|(' cntttrol codes.
Itt the IT‘; trtstntt, Mlit. c.-tn start up tt-tthottt a tcrtnmat. give control of the tertttittal away to an
ittferinr npt-t.ttttt;;-.~)-strttt |ttr-t-ct- nr get it hack while running. Doing a RESET on citlter of the
tcrtttittal clttttttlrls t.tttst's .\tl)I. tn find out if it now has the tertttinal: if it does, the terminal is
t'00|I(‘t|tt| and the tI|tt(‘ttl tttcru stzt‘ and device parattteters are updated. lf it doestft have the
tt-rtnitt.1l_ an i|tlt'tIt.'ti fl.-tg t~ wt. cattttttg otttpttt to the tvrtninal to be ignored and attempted input
Irom tltc |ertt.ttt;t| tn ttt:tk- tht~ ttpt-rr...tt;-sy.stett't process go to sleep.
In the . . 42 tr. vtt, thv. .11.‘ ~»-tut‘ |)\t.tii2ftlit'$ associated with pseudo-tertttinals ("STY" and ‘ST/1"
dt.-\'i<‘:'s). ll the Fttfttttttt git-rtt tn Rt ft‘tCttR l$ open in "READ' tnodc to a pseudo-terminal. and if no
ittpttt ;\ .'t\ ..-1.ttih-. tit .-it(.ttt-2 ..:tttns . , IYPL rIX. It’ the CHANNEL given to READSTRIHG is open in
"READ" mt-tic tn .1 |t~t-nttn-t-tt.titt.tt, tr;.tling .~-~-'» stops if and whett no more characters are available,
that is. \\-hen RC/tlttttit tvttuttt rcturt. -I.
.|.7.ft - II.8 Input/Output
 
Ill
I
Ill
 
ll
 
I'll“ I'I'l'Il II'll1'l'lI'lI



I
The M DI. Ptnqtatttttttttg Language H3
t|vs.t. ECIIOPAIR
<tcttov/\tR /¢-,,wm1/-m.-<t1.mn¢/ lcrmln-1I<OuI:rha!'meI)
rl‘!ul'|t§ ll\ fitst at;i:|.u-nl. nftrr nmkntg the two CHANNEL‘. "know about each other" so that rubout,
~51, ~n .-mi "I nn 1 '/vtl!t,II~HI \Vl" cans!‘ the appropriate output on Ierminal-out.
H.832. l'Tvl'\‘|t0
< T IVE CHO !rrr,..n.1l-utpuhrliarvnel prod)
turns the t-cltnltt-.; nf nprd rlurartcrs on cltarvrlel off or on. according to whether or not pred is of
lYPi. Hit M . .tt|tl tt‘|ttt||\ r/t.-mu-/. It is ust-fnl itt cottjtttiction with TYI (below) for a program that
wants tn tin \ l|.1r:trtt-I input and erltoing itt its own fashion.
ll.8.3. 'lYl
< lYl .'t'.'ni.-/nu"I/1[\t1I:(’7dIlr!L‘l>
rctnrns mm (ll/ti!I\(‘.ll it from c/:3/‘"1" (npttrnt.-1L .INCHAH by default) when it is typcd. rather than
after 3 tlL$(;t l\ i}'|Y('(|, .t$ is the raw with READCHR. The folluwing example echo: input characters
as their A §\"lI \‘.1lu\-~_ until :t carltagc-tclttrtt is typed:
\ RFPEA1 ((l O0 <llYFCHO .INCH/\N <>>))
<l‘\l¢'O <::" I3 <Y‘RlHC (ASCII <TYI .INCHAN)>>>
(RETURN (‘ITYECHO .INCHAN T>)>)
ll.9. lltI4'| ital (.l|Lll.Vi_ll
lf tho .1-;\  \i)l'l tt'n~tl in an OPEN is "INT", .1 CHANNEL is created which does not refer to any I/O
tlcvicv utttsttlr .\ll)l.. in this \'.'t~.t'. the tnnde tnnst be "READ" or "PRINT", and there is another
argutnent. \\'|ll( It lI||l'~l hr :1 fnnclintt.
Fﬂr .1 "HI AD" Cllt'\lll;tL, the fnnctinn untst take no :trt_.{ttn\ents. \Vlt¢-ttcver a CHARACTER is desired
front this tilirt-’ll.'l l , the fttnctmn null be applied tn no argutncnts and must return :1 CHARACTER.
This will tutu! ﬁllt(‘ pm t.1l1 tn RFADCHR using this Cll»'tNHEL. and several titncs per call to READ. In
the ITS \ ('i'\|('\ll_\|ll'rlllI\’liﬂll\‘flll\il1lI3mtJ1 in "end-of-file" has been reached by returning <CHTYPE
'777777000OO3" Fll/\R/'\Cll R> (-1 in left half. control~C itt right). which is the standard ITS EIld-Of-
file sigttnl In the 'i't'nt*x and Tops-'.'!0 \--.-rsiunsi the function should return either that or <CHTYPE
"77777700(>03?- <‘l|t’\RA(ll R> (-l .-tnd rnntrol~Zl. the latter being their standard cttd~ctf-file signal.
ll.8.l - IL9 Input/Output
__ I
I L
L
L
k



ll-I The MDL Programming Language
For :t "PR tu t " (‘ll/\HNll , the function tttnst take one argument. which will be a CHARACTER. It can
dispose of its rtrgntnettt tn any way it pleases. The value returned by the function is ignored.
Example: -'O|'l'u “l-RlNT' '1NT:“ ,FCN> opens an internal output CHANNEL with .FCN as its
cliaracter-gnlihlr-r.
ll.l0. 'r|l('>"iil I“ Det ice: the .'\Rl"A Network
Tlte "Ht. I" IiI‘\ lC(‘ t~ tlilfrtrnt III many ways from conventional devices. In the ITS version. it is
the only ti(~\ ice lirurles "lNl" that rlnes tint take all strings as its arguments to OPEN, attd it must
take an Illitillilllllll nlttiﬁlml argument to specify the byte size of the socket. The format of a call to
open a tt('tt\-rt|L vtclt-I is
VON N /-:o.t'e:::Irm;: /oca/-sorkul:/ix Iorvign—sockef.-(ix 'NET' foreign-hostzlix byte-size:/ix)
where:
nan-11‘ is the tltrttle nt’ lite desired CHANNCL. This must be either "READ". ‘PRINT’, "READB‘ or
"i'R1.l|lB" .
/OCI/*'It7-'F.¢-‘-' is the lneal \ocLCt nntnbcr. ll‘ it is -l. the operating system will generate a unique
lntwtl snvlrtt nttmlmr. ll’ it is t|rtl_ in the Tettex attd Tops-20 versions. the socket number is
"f0t'L-rt-|.1ti\'t~".
:¢n-/_~;/t -.10.,-r is the fnrc-igtt socket number. If it is -l, this is an OPEN for "Iistening'.
ran-1; "u<.‘ i~ the fr-tcigti hmt ntntther. ll’ it is an OPEN for listening. this argument is ignored.
l;t.'t - _-,~ i- thr rtptir>n.~tl ltylr: sire. For "READ" or ‘PRINT’ this tttust be either 7 (used by
dt-l'.tnlt> ﬁr ti. For “Rt ADS" or "PRINTS", it can be any integer from I to 36 (used by default).
lit the 'l'(‘|tt‘\ .ttnl 'l'i-[is-?0 \'t~r\intts. OPEN can instead be given a STRING argument of the form
"NE I; . . .". Zn thi\ \.\\l'iilf‘i(I\'i\|\1'I(Ll‘l nmnber can be “directory-relative".
LiLe titty r-tlnt 0|‘! ll. ('li|H'[ .1 CllAiIIlEL nr a FALSE is returned. Once open. .1 network CHANNEL can
be us:-tl ltl».r any nth:-r CttItrtl:FL, v\rept that FILE-LENGTH, ACCESS. RENAHE. et<:.. cannot be done.
The ":it__ttntr~ttt“ l.i~t<nnntr_ srrmtti-nattte. .1ntl tlirectnry-name slats in the CHANNEL are used for local
socket. fmt-iqn -r-tit-t. .tnd f"l\‘l‘:lll hmt (.1~ .\pecil'ied in the call to OPEN). respectively. The
currr.s|>rttnttit; "it-.tl" \Ittls are ttsrtl -otttt'\\lt:tt differently. lf a channel is 0PENed with local socket
—l. lItt' "it-.tl" ftt~l-tt.'\tttt' 5|-H wiil contain the unique sncLet ttttntber generated by the operating
systt.-ttt lt‘ .1 |l'~ll‘IlllIt: smrlrl is OW tint, the foreign socket and host numbers of the answering host
are slonrl .tt thr "it-.tI" set--ttd-ttatnr Jud ditectory-ttattte slots of the CHANNEL when the Request For
Coltttertirttt is rccrtird.
t|.9 - tt.to input/Output



Y
t Th!‘ !\H)l l‘rn|;r.'tt||t\|||it; l.;\t|gtta_Q(‘ H5
_-\n |lIl('lI\l|tl ((‘lkl]Il\'f '1!) t‘.ttt lit: asanciatcd with 2 "NET"-device CHANNEL, so that 2 program will
know lhrtl ll|t' Cll/\Hl‘1l'L hm or ttctds tlnta. according to its mode.
There .1|~n t-\|~i wvt-|.1l -pt-ci.1l-pnrpo>c SUBRs for the ‘NET’ device. These are described next.
ll t0.t_ tn t.xt;.tt
(Hl_1Si1'\|[ I'z'!:- in A-.:rh.|/1/151)
(Pllttlts .\ ll\,Ii( tot: of ll|l(‘l' iIXt-s The first is the state of the connection. tltc >ccond is a code
\|l('(Ir\'It|'_ uh-. .- (lIllllL'(li|'lll \\.1\ clmvd, and the last i> the number of bits available on the
\'n|tt|<'\l|I-It tm input The tiionttitig of the state and close codes are installation-dcpr.-m:lcnt and so
arr tttvt tttrltttlrtl |l('I'f‘.
ll 10'), Li tm'.1l
t :41 |r\t‘t" >"‘/'~u(‘\/I’-.'(/7,wrtVY(">
.wc<-pt~ .\ 1--nun Iirvn ltl .1 \ncl4'l that i~ (tpctt for listening and returns its argument. lt will return a
FALSE tl ||l1‘(IIllIlt‘('|lllll is Ill tht‘ wrong state.
ll.l0.3 NLI,‘-.
<r;; tS  >:.»<>// _~.=/mt--'>
|’(‘lttr|t\ its .u__|tint~nt. ..tt--t (1-icim; any systctwbttffcrcd IICXWOFL output to be sent. lTS normally
tlm-s this 4'\ "I \ li.\1l' wt ltllll .’\llY\V.I‘, Tcncx and Top:-20 du not do it unlc:-s and until NETS is called.
Hl_TS is \|lll||-ll In Illll out rm hr-nn.1| CHI\NN[Ls. except that even opcrntitlg-systettt buffers are
(‘tIlp|It'tl tit)“
ll.l0 - ll l0.3 Input/Output
L



i
||5 The MDL Programming Language
Chapter 12. Local’-ives
Tlmre ix Ill .\ll>l tt l".-t-il|t‘\ for nlitaiuing and working directly with objects which roughly
COf!('\|\|‘lI\ll to "]>r\i||tm~" in .\\st‘|nl1l)' langnagc or "lvals' in BCPL or PAL. In NIDL. these are
grin.-ritnll\' lnrmu :t'~ ln_c_1_tt:-t-\ (Frmu "loratiott') and arc of several TYPEs. as mentioned below.
l.nc:tt|\ t-\ t~\t\t tn pt:-\ ulo r~l'I'i<|cut lnealts for altering structures: direct replacement as opposed to
rt--c0|>_viu;_'.
I_o\—.1v|\~r~\ :tl\\.1}'\ |t'l'r"| to r‘Ir‘|t\t'||I\ in xttncturcs. lt is not possible to obtain a locativc to something
(for c-\.1m|>lt~. ;t|| I-|OI1i\\-huh |\ lllll pztrl of any structure. lt is pussihle to obtain a locative to any
(‘l(‘lll(‘ttl Ill ;\tt_\- \lt||tlt||t‘t| t\lt|t"\‘l Ill MDL ~- oven to associations (chapter I3) and to the values of
I'\TOMs_ Htuctttt |ll\:'~ \\l|l(‘lI alt‘ ltnntmlly 'l|idd<‘||".
In tho fr\ll4>\\ tug. the r">lt_jt-(t 0r\'\||1)ilIglltt' structttred position to WlllClI you have obtained a locativc
will he rt-ft-in-ti tn ,1- nit» nl-Jrct pttlllltll I3 by the localive.
l2.l. ()l§l:‘t|It|Ll_t' ln¢::|t|\-cs
l'Z.l.l. LlOt’
-‘l LO(‘ ﬂu!“ 1-n'>
rclttrtn .1 I--t.ttt\<< llYl‘l LOC[|_ "lr>c.1tt\-0 to iD0ttt|l‘i(-I") to the LVAL of atom in cnv. If atom is not
botttttl in  an t‘I’lIIl uccuts c"\' lﬁ nplin||:tl_ with the current ENVIRONMENT used by default. The
loratn-t~ it-tut.t<~<l I-\ I IOL‘ |\ lilr'|l’('_l|7tl£‘Ll pi (uturc Lg-biltdittgs of atom. That is. IN (sec below) of
that |r\r.1li\t- \\'Ill tvtutu tlw saint" thing t-\':-tt if atom is re-hound to something cl>c: SETLOC (see
b('lh\\l will .<tft-ct <-||l\ that p.1!l|t<\l.1l' himlmg of a.'Om.
Sinrv lltllll|lI‘__\ .||.- l~(‘|ll mt .1 \t.|rl tn-.1 Lt). any nltcnlpt to use a locative to an LVAL which has
lJ(~cnnt(- uttlmuutl will ft-tch up .1“ (t'fl7l'. (lt hr:-.1l.1_‘|u>t like a TUPLE . . . .) LEGAL? can. ottcc again
he ltscd tn wt» if .1 LOU» |~ Vﬂllll (iautiou: (SET A <Ll_OC A>> creates a self-reference and can make
PRINT vt~r\ llll|\.||vp)'.
l2 - l2.l.l Localives
Ii



T
i
I
I The MUL Prnu__'r.tt|t|||ing La||§|t:t§;t- ll7
1
‘ |2.t.-z. r-tor
j <(;t_o<: ,.r<~,., ;v4'(1>
t returns .1 lrv\~.1l|\‘c (IYPY t0(‘.D) tn the GVAL of Mom, If atom has ltn GVAL slnt. an error occurs, unless
Bred (npliutlnll is L1i\'t'n .'\ttd ttﬂl FALSE , in which case a slot is created (chapter 22). Caution: (SETG
A <GLO('. I\>> crcatt-~ :t so.-ll‘-rcfcrcncc and can tnakc PRINT very unhappy.
l2,l.3. AT
</\t -.:,.',.-rm,-.1 /\/.‘.'I\"U!-Off,’-Cl) |
rctttrn'~ .\ lrvt.'ttt\‘t~ tn the .'-uh I.~k~ntcnt in zzrrutfured. N Ls optional. l by default. The exact TYPE of
lht‘ lnr.1:i\'r tvturni it t|\'“pr‘||t|\ on thc PRIHTYPE of strucluredt LOCL for LIST. LOCV for VECTOR. LOCU
fur UV! (“IOi<i_ IOFS lnr SIRIHG, [OCH fur IZYTES, LOCT for TEMPLATE, and LOCA for TUPLE. If N is
|_;rc.1tt-r llI.1tt <1 ['tt'(.Hl -..'.»i»:lurz~n‘> or less than l, or an OFFSET with a Pattern that docsn‘t match I
5!/uc/m¢~.:. an mt--| nctttrs The lncativc is unaffected by applications of REST. BACK, TOP, GROW,
etc. tn -:!/uri'u/- ..',
l'Z.l.-L GCYIH .ttttl f.L1L
<(.»l.l|-'| iltmfa/t\' :!td|r,4fz).':-Iny ur.'IaulI:any>
rctttrtts :i lnrittn 1- t'TYf'F l0CI\S) tn the association of -Iem under Indicator. (See chapter I3 for
infnrnmtimi Jllllilll axstn i;itirms,) lf no such association exists, GEYPL returns EVAL of dc/au/I. default
I5 Opliﬂttal. -u itl Si () hy in-fault
GETPL l’!Il'll‘\l\f\llK|\ tn CFTPR01‘ atnmtgst the association machinery. There also exists GETL, which
cnrre-\pn|ttl\ tn (J1 _ ivturniug cithcr :i LOCA5 or a locative to the indicatorth clement of a structured
in-m. LET! i~ HL9 I\i if ilcm is :2 structure and indicator is a FIX or OFFSET, and like GETPL if not. I
12.2. toc/u lVi 3
Thia SURF: IS :1 piimcatc that it-Ils whether or not its argument is a locative. It is cheaper than
("ENC <PRlHlYP| .=-_- > '![l_OCD LOCI  1).
t2.l.2 - 12.2 Locativcs
NW WT? FWWFTF N
 
 
 



H8 The MDL Programming Language
l‘Z_IL llsmii r}_r.}t_ irrg
The following two SUGRs provide thc nu-ans for working with locatives. They are independent of
the .-pz-cific TYPF or thr locativc. Thc notation Iocative indicates anything which could he returned
by LLOC, BLOC, AI, GEIPL or GEIL.
l2.3.l. IN
(IN lornln-0)
returns the nhjmt In which lorahve points. The only way you can got an error using IN is when
/i_zr.1!n-1: plrillls All an i_Vf\L which h.1- bt.'i;ntnc unbound Fronran ATOH. This is the same as the
pl'0Ltk'||\ in ti-1'1-|cn<ing TUPLEs as tnetttioned in section 9.2. and it can be avoided by first testing
(LEGAL? Io(d>.
Example:
<S[T A l>S
1
(IN (LLOC I\))S
I
12.3.2. ssnoc
<SElLOC Iuraltve any)
r€Htr||\ AH)’, after h:\\-ing made any the contents of that position in a structure pointed to by
/O(8Il\'E. Thr atntrtutc itscll is not nthcrwisc disturbed. An error occurs if Iocahve is to a non-
LEGAL? l.VI\L 0| if you try In put an object of lhc wrong TYPE inlo 3 PRIHIYPE UVECTOR. STRING,
BYTES, ﬂr ICMPIIUL.
Example:
<55! /\ (t 2 3)>s
(1 2 3)
<S[ILOC <At .A z> HI>S
ut
./\s
(1 HI 3)
l2.3 - I2!-.2 Localives
T’
‘I



T
The MDL Prﬂgranuuuing; Languagv.‘ H9
1-) 4. Nntc nu Lnr.=\l|\'1'S
You may I-.1\1: nnrircd Ihnr |0<‘.'\Yi\'(‘s arc. strictly spraking. unnecessary: you can do everylhing
lncalivm-~ .1111-\\ by .'\|)|)rﬂpriRl(‘ use of. for example. SET, LVAL. PUT, NTH, etc. What locatives
provide ix gnu:-|:\lil_v.
Basically. lmw ynu 1-ln.1incd :\ lm-alive is irrrlcvaur to SETLOC and IN; thus the same program can
play \\il|| (.\/Al ~. lvnu. nbjvcls in c.\plicil structures. elc.. without being bothered by what fuucliun
n shnuhl uw I" (In an. This is p.-|rlicul.1rly rruc wilh respect lo Iocatives to LVAL5: the fact lhal lhey
are inri<~|vr\ulcul hf changes in bimlillg can save a I0! of fooling around with EVAL and
ENVIROHI*HINTs.
l2.4 Localives



120 The MDL Programming Language
3
Chapter 13. Association (Properties)
There is an ".1<\nri.1tivc" tlata storage and rctricval system cntbcddcd in MDL which allows the ‘
construction nf data structures with arbitrary selectors. lt is used via the SUBR.s describtd in this
chapter.
t
l
l3.l. A$:f£;ll‘i\'('iS_l_Ql':l_Q§ 7
I3.l.l. PUIPROP
<PUl'l"ROP :.’em:m1)- rndrcalvrmny vaIue:any>
("put property") rvttttns tlcm. having associated value with item under the indicator indicalor.
l3.l.2. Put
(PUT :Iem.-.m_\- /rxiil-1/or:a/ty va/us.-any)
I is identical tn PIIIPROP, cs-rcpt that. if Item is strttctttrrd and indicator is of TYPE FIX or OFFSET, it
does <SEltOC </\t 1.’,-m I!7\1l('.ilOf> \'.‘-'uc>. In other words. an elcmz-at with an integral selector is
storcd in lhv strnrtnrc itu-ll‘. instcad of in association space. PUT (like AT) will get an error if
Iﬂd/CATO! is nnt nf rnngc: PUIPROP will not.
l3.l.3. R(‘|nrwin_q /\\\ng‘i;l|iflllS
If PUTF‘ROF‘ i\ nu-tl \\_itlmnt its v.=.'t;v~ argnntrnt. it removes any association existing between its llem
argnntrnt ntttl its -/=.-:'.;.~.'or nrgntnottt. ll‘ an association did exist. using PUTPROP in this way returns
the v.1/t.>1.= which \\‘.1s nssnciatul. ll’ no association existed. it returns IFALSE ().
PUT, with nrgtttttvttts which refer to association. can be used in the same way.
I3 - l3.t.3 Association (Properties)



Y
I
v
The MDI l'rn;|.-tnttnittg Lnngnagr l2l
1; civlivr ,.w~-» nr 1!‘-‘f'c.v-‘Or rt‘:\sc to exist (that is. no one was pointing to them, so they were garbage-~
(§ﬂ“(‘(‘lI’ll), and nn Ir\r.'|Ii\'('s tn the assntialinll exist, then the association between thcnt ceases to exist
(is gnrltnqt--rr-Ilt'cl\-all.
_1v_ \ﬂ\‘l_Z\ll\:L‘ l{vlriI.'_t':1I
13 ) As
l3.2.l. Gt 1 PROP
(GE TPROP I/9!II.'¢7!7_l’ ntdvtalonany exp:any)
("get prnp:-my") rt-lttrtts the v.-I;/e associated with dam undr.-r Indicator. if any. If there is no such
:|ss0ci.1tinu.(_CIPROF‘ uclnins CV/\L of Exp (that is. exp gels EV/\Led both at call time and later).
evp is nptinnnl. If um given. GFTPROP rctnrns IFALSE () if it cannot return a valuc.
Note: Ilcm .\nd II1\':'rc.=I0! in GETPROP mnsl be the same MDL objects used to establish the association:
that is. (lwy tnnsl hr ==? to the objects used by PUTPROP or PUT.
l3.2.2. GET
<Ghl ifnnz.-.an_\» indrca-‘or.-arty e~xp:.|ny>
is the i||\'(‘r\t‘ of PUT, using NTII or GETPROP depending on the test outlined in section l3.l.2- exp is
optinnal nml nwd as in GFTPROP.
13.3. Exa|np_lrs__ql_‘_i\snciatinn
<SET L ‘(l Z 3 4)>S
(l 7 3 4)
(PU! .1. FOO ‘L is a llS£.">$
(l Z 3 4)
<GCT .L FOO)$
‘I is -1list.'
<f'UlPl{OP .l 3 '![4]>$
(l 2 3 ll)
<GETl‘ROP .L 3>S
![4!]
(GET .L 3)S
3
l3.|.3 - l3.5 Association (Properties)
I:
I



—.§
|27_ The MDL Programming Language
(SET N 0>$
0
<PUT .N .L ‘list. on a zero'>$
0
(GET .N ‘(l 2 3 4)>$
rI'I\LSE ()
The Inst cxantplr failed because READ generated a new LIST - not the one which is L‘: LVAL.
However.
<G!'l O .l>S
‘list. on a zero‘
works In-cattsr <==" .N O) is true.
To assnriztte something with the Nth p_nii1i_nn in a structure. as opposed to its Nth element. associate
it with <RtTST Slruflurc N-1>, as in the following:
(Pill <RkSl .L 2) PERCENT D.3>$
(3 4)
<G[‘l <2 .L> l"ERCEHT>S
Il'l\lSf ()
(GL1 (R125! .l. 2) PERCENY>$
0.3000000O
Re|ncmh<-r r.nntu|rnt.s?
<SET Pl ‘![A B C ;"t.h\rt.l element,‘ D E]>$
'[I\ B C D E']
<t;Fl <Rl!\1 .H Z) COHH[NT)$
“tnirrl clcmc~nt“
The ' in thc <SFT H  > i> to kc:-p [VAL from generating a new UVECTOR (“Direct
lh'prr-\r~||I:\Iirnt"'l. tvliich unnltl nﬂt Imve the rontntcnl on it (and which would be a nccdlcss
duplic:\|v). .\ "twp-Ion-I“ cmntncnl -- one attached to the entire object returned by READ -- is PUT on
the Cllftfllifl Ill nu". sincc there i'~ no p0siti0lt itt any structure for it. If no top-lrvel comment
rO||n\\'\ tl|(' ol-1rt~t_ RIM! irnmvrs the v-1luc(<l"UT C/YaI‘1!‘lE/ COMHENT>): so anybody that wants to set a
lnp-level rmnnn-ut nmu lnnl. for it after each READ. .
If you nt-<-tl In l|:t\-0 a snnctmc with selectors in more than one dimension (for example. a sparse
matrix that i|ﬂl"5 nnt dz-~r|\-z~ in be linmrircd). av-nciatiotts can be cascaded to achieve lhc desired
result. ln 1-TH-ct .'\|\ r-\tr:t level of :4s~ocia|ion maps two indicators into one. For example. to
associate \-.=-'.;r \\itlt /.‘cm nntlt-r md:c.v.‘o,--1 and md1c.=.‘or>2 simultaneously:
<!‘UH‘ROP m.1-rnlor-I md:caIor~2 T)
l3.3 Association (Properties)
ll
I
L
L
L
L
L
1
1



I
' The M DI, Prngi:u|1|||i||_Q Language [23
t (l‘ll‘|PROP item (CYTPL lrld/calor-1 vndicglor-2) value)
t
|3_.;_ F§ﬂ!lIiIlil\g .-\ \<nr|.1_I_iQ1i:
.»\-sm‘i.1tinn~ HIV-l\(‘l| lay PLII and PUTVROP) are chained together in 2 doubly-linked list. internal to
MI)! ‘l I-<~ mdri nf .'\\<ﬂri5\li4'IlI$ in the chain is their order of crcatinn. newest first. Tlicrc are
\('\'l"lJ| .\lIIH‘< fm r-\.nnining the rltntn nf associations. ASSOCIATIONS returns the first association
in tliv cli.i|n,:-1 -I Al St () if there mo nnnr.-. HEX! takes an association as an argument and returns
thr nt'\t :\#-rn ti\1l"ll in ll|t' cli.1in.nr vFALSE () if the-re are no more. ITEH, INDICATOR and AVALUE
all t.1I>z~ an .1'~\ﬁti:t|intt :|\ an argninrnt and return the itctn. indicator and value. rcspcctivciy.
A\$OCi:l1il'1t|\ PIIIII n\:
FASQL (ilcm rHc1'!(¢=IO! value)
(sic: only mm SJ. F\:nnpIz-: thr following gallicra all the existing associations into a LIST.
<f‘ROG ((!\ (f\SSOCI»\TIOHS>))
(COM: (<HOI .!\> ‘())
(1 (.A !<HI'\PF ,LIST
<FUHCTION () (COMO ((SEI A (NEXT .A>> .A)
(T (HAPS1'OP>)>>>))>>
- 13.3 - 13.4 Association (Properties)
.'



I24 The MDL Programming Language
Chapter 14. Data-type Declarations
In M DI . it is |\ﬂs'~iltlt‘ to tlerlart: the pertttisailtle range of "types" andlnr structures that an A‘tOt1's
values ﬁr :1 l'ttnrtinn's nrgtttttrttts or taltte tttay have. This is dotte using a special TYPE, the DECL
("tle<"laiatin||"t. A DECL is nl‘ PRIMTYPE LIST but has a complicated internal structure. DECL_s are
used by tltt‘ inn-vptctrr m find TYPE errors in function calling and by the cotnpiler to generate more
efficient cmlc-_
There art" twrt Litttls nf lJECLs. The first kind of DECL is the most common. lt is called the ATOM
DCCL and is ttsrtl innu rnttttttnttl)‘ to specify the type/structurr: of the LVAl.s of the ATOMs in the
argtttttent l lSl nf .1 lLIN(IllON or .-tux LISY of a PROG or REPEAT‘ This DECL has the form:
"l]CCl (.rfor-writ‘-11:! Pnllvrn . . .)
where the pairing tvf rt l {ST nt‘ /\l0H\ and a "l":tttt-rtt” can he repeated indefinitely. This declares the
A1OMs in .1 /t->.' tn he nf the type/'~ttttclttre s|)(‘CtfiEd itt the following Pa!/crn. The special ATOH
VALUF. if ll 31>|)(':\t\. tk~rl:trcs the trmlt of at FUNCTION call or PROG or REPEAT evaluation lo satisfy
the Pnttmn spt‘tii'it*tl. .-\tt AIOH DFCL is ttsefttl in only one place: itntnediately following the
argutnent LIST of .1 FUNCTION, PROG or REPE/\l. lt nortnally includes ATOM: itt the argument LIST
and ATOil\ nlmw LV»'\Ls are ollt£'r\vt$€ used itt the Ftntction body.
The serrttttl linil nf hi tit is ritrcly won by the Casual MDL user. except in appendix 2. lt is called
the RSUBR (tEfl . It is ll‘>l'(l tn specify the typt-lstrncturr of the arguments and result of an RSUBR or
RSUUR-FHTRY (chapter l‘Ill. ll is uf the followlttg fotttt:
-'lll Cl ("V/'\l lll " P,v.’Ir_-rrt Pa/fern . . .)
where thr STRING "VAI UC" p|'(‘C(‘d('s the specification of the typelstructure of the value of the call to
the RSUHR, zttttl the t't‘l|t:tittitt§; PA.'ferrts specify the argttntcnxs to the RSUBR in order. The full
specificntiriit i-I the RSUBI-t ttt Cl will he given in section l4.9. The RSUBR DECL is useful in only
nttepl.1v:e::ts ;ttt elvtttent nf an RSUBR or RSUBR-ENTRY.
I4 Data-type Declarations
.1



The M DL l"rngram|ning Language l2S
. II('|'Il$
, t4| Pei
‘ The simplest possible Pattern is to say that a value is exactly some other object. by giving that
object. Otl0Tl'd. Fm‘ example. to declare that a variable is a particular ATOM:
FDECL ((X) 'T)
declares that .X is always the ATOH T. When variables are DECLed as 'heing" some other object in
1 this way. the tr-st nsr-tl is =7, and not ==?. The distinction is usually not important. since ATOHS.
which are mnst vnmntnnly used in this cnnstruction. are ==? to each other if =7 anyway.
It is mnrc rmnninn to want to specify that a value must be of a given TYPE. This is done with the
silllplesl nnn-spr'cil'ic Pattern. a TYPE name. For example.
.-'DECl_ ((X) FIX (Y) FLOAT)
declares .X tn be nf TYl‘£ l IX, and .Y of TYPE FLOAT. In addition to the names of all of the built-
in and created TYl"Es. such as FIX. FLOAT and LIST, a few ‘compound’ type names are allowed:
AHY allnws any lYl‘l" .
STRUCTURED allvws any structured TYPE, such as LIST. VECTOR, FALSE. CHANNEL. etc.
(-‘ip|\('tltli.\ 3).
LOCI\l1\/F allows any lm::\li\'e TYPE, such as are returned by LLOC. BLOC. AT, and so on
(chapter I12).
I\l'PLlC/\lll l allmvs any applicable TYPE. such as FUNCTION, SUBR. FIX (l). etc. (appendix 3).
Any t|X|tt't ATO2-l can be used to stand for a more complex construct. if an association is
Pslnlriisltﬁil mi that ATOI-1 and the ATOM OECL. A common example is to (PUT NUMBER DECL
‘(OR I 1)! t>|_0/\1>> (see ht-low). so that NUMBER can be used as a "compound type name".
The single TYP£ n.-unc can he generalized slightly. allowing anything of a given PRXHTYPE. using
the fnllnwiug cnnstturtinn:
HTECL ((X) <PRlHTYPE WORD) (Y) <PRXﬂTYPE LIST>)
This cnnsnmtimi rﬂnsisls nf a twrv-clement FORM. where the first element is the ATOM PRIMTYPE,
and the secﬁtitl the name of .1 pfillIlll\‘(' type.
The next step is tn specify the elcmcnts of :4 structure. This is done in the simplest way as follows:
< zfruclu/vtv‘.-!_t';:c Pallcrn Palfcrn . . .>
l4.l Data-type Declarations



m
I26 The MDL Programming lgnguage
where their ix :1 one-tn-one correspondence between the Pallerns and the elements of the structurn
For exatuplzw
IDECL ((X) (VECTOR FIX FLO!\T>)
declares .X tn hr .1 Vl'CtOR having :1 least two elctnents. the first of which is a FIX and the second a
FLOAT . ll is r~l't<~n rmtvcnictit tu allow additional elements. so that only the elements being used in
the lornl nc-ighlmrlmnd of the DECL need to be declared. To disallow additional elements. a SEGMENT
is used instcail of .1 FORM (the "excl-rd" brackets make it lock more emphatic). For example:
FDECL ((X) '<VFClOR FIX FLOl\T>)
declares .X tn be .1 VICTOR having exactly two elements. the first of which is a FIX and the second a
FLOAT . Nnm that the P.>l/mm given l'r_\r elctncnts can be any legal Pattern:
FDECL ((X) (VECTOR <VECTOR FIX FLOAT)) (Y) <<PRTHTYPE LIST) LTST>)
declares ‘X tn he a VICTOR rntttaining another VECTOR of at least two elements, and .Y to be Of
PRIHTYPE LlSt_ cnntaining a LIST. ln the case of a BYTES. the individual elements cannot be
declared (they innst he FIX:-s anyway). only the size and number of the bytes:
t'l)l:CL ((8) <[lYTES 7 3))
declares .0 to hr a BYIES with BYTE—SIZE 7 and at least three elements.
It is ‘)n\§l'l|(‘ tn my that sotnr: nntnbcr of elements of a structure satisfy a given Pattern (or
seqtn.-ncc of Patterns). This is called an "N‘l’H construction‘.
f nun>L>vr:I1v Pallern Pallern .. . ]
states that the '~L'l]llk'II(‘l' of Pnlfcrns which is REST of the VECTOR is repeated the number of times
given. I-‘or c.\a|nplc:
-Dktil ((X) <\J[ClOR [3 FIX] FLOAT) (Y) (LIST [3 FIX FLOAT]>)
.X is dcrl.-urtl tn (nttlaiil thicc flXcs and a FLOAT, perhaps followed by other elements. .Y is
declared to |t'|)t‘.1t the scqttvttcc l'lX—l'LOA‘l' thrcc times Note that there may be more repetitions of
the sequcttce in .Y (hut unl in .X'l: the DECL specifies only the first six elements.
For ind<~l'initc r('pt'tiliﬂtt. the same construction is used. but. instead of the number of repetitions of
the S{‘l‘|ll(‘ll(‘C nl' Pnttrrns. tho ATOM RLST is given. This allows any number of repetitions. from zero
on up. Fnr example:
~DECl_ ((X) (VECTOR [REST FIX]> (Y) (LIST [3 FIX] [REST FIX])
l-l.l Data-type Declarations
1
_
m



The MDL i'|ug|.1nttninj_' l..1n§_;t|:|ge I27
1 ,\ "RLSI (II|l\llll( an-n" (.11! ront.-iin rut)‘ nnnthcr nf Patterns. just like an Nlll construction:
.1 i'lILCl ((X) (VICTOR [REST FIX FLOAY LIST]))
(|(‘C|-'\l('\ that .X is .1 Vt CIOR \\'|ll'Il‘ill tho sc-qnrnrc l‘lX—FLOAT-L151 rrpcats indcfinitcly. It docs not
dcclatv th.it 'ILl_'lll'.lll .X> is an ere-n multiple of three: the VECTOR can cud at any point.
,\ \'.'\Ii.1lil'\ll nn nt st is OPT (nr OPTIONAL]. which is similar to REST except that the construction is
5CZ\l\lll‘li 4'\llt'(‘ :tt nmst uistrml nf intlcfinitvly. and further undeclared elctncnts can follow. For
rxatnplu:
-mrt <(x) <vrcton [om rtx]>)
ilz~cl.1ru-. that .X I\ ll VECIOR nhicli I\ ctnpty nr wlmsc first element is a FIX. Only a REST
cnnstrnrtir-n can frvllnn-.1n "OPT construction“.
Nnto that lht~ ltl isl ('Il|'\llll(‘|ll'\ll lllll\l .\l\\-:\y.\ ht‘ thr Inst clement of the structure declaration. since it
gives a l'.\t:i-i n lt\| thv l\‘\l of thc strnctnn;-_ Thns. the REST construction is diffcrcnt from all others
in that it I-.1- .1|\tt||lttn|lrt\|.1lt_qt‘. Nn ninttvr hmv tnany times the Pattern it gives is RESTcd off of
the \|Ill('|lIl(', tlir it-in.-iinali-r nl' the strnclnrr still has that l’:tttcrn.
This (‘\|l.lll\l‘~ li\('[)ﬁ\\il1|l' unglc l’.1ttcrttstli:\tr.1t\bt- given in a declaratimt. However. there is also
:1 cmiipmmil i'.'\ll1‘lIl t|l‘| in<-it. It allows spccificatinn of several possible Patterns for one value:
(OR /‘-'.'.'c.'.~t I-'.tHrrn  >
Any nnii-cmnprnnnt l‘.1tt<~rn ran he included as one of the clcnicnts of the compound Pattern.
Finally. (‘|\Il\|Hu||ttl i'.‘llIK‘ll|'~ r.1tt hr u\t*(l as l‘;itierns for rlcnicnts of structures. and so on.
"LILCL (()I) (OR YIX FLO/\T>
(Y) (OR FIX <UVYCTOR [REST (OR FIX FLOAT>])>)
The OR 1.tIll\|l\l\'\t"Ill r.-in he t~\tt-mleil tn any level of ridiculousness. but the higher the level of
complt'\tty nntl crmipnitttilt-dttcss tlu: la-s\ likely the coinpiltr will find the DECL useful.
At the higlmsi it'\'('|. any l‘.1ttcrn at top |?\'(‘| in an/\lOl1 DECL can be enclosed in the construction
< -;wvi,=/It.-.~fo/it F’.=i‘!errt )
n-liich v.'.\.|>lnttl_y |i\'\ Luvs tht~ spu-i.1l:y of the I\lOl-Ks) in the preceding LIST. spec/ally can be either
SPECIAL r-t IYIJSPLCI/\l . Spu~t:tlty is lIll|)(tl'l.llll only when the program is to be contpilcd. The word
coincs frmn the inniinl <.t:irl.. which is called "special" in Lisp (Moon. 1974) because the garbage
collvrtnr finils nh_|m~is r\|t it :\n<l inmlifics their internal |)(\it\!Ct's when storage is compacted. (An
internal stnrl. is nst-il \\'itliin the nttvrprctcr and is not accessible to programs ~ section 22.l.) In
14.1 Data-type Declarations



l28 The MDL Programming Liltguigg
an llll(‘l'|)It'l(‘(| ptn;;|.1tn all lrn~:tl v;tluc.s are initially SPECIAL. because all bindings are pnt on the
control '~t.t\'l thtll soc SPICIAI ~|‘1ODl' bclnw). \\'ltcn thc program is compiled. only values declared
Sl‘[Clf\l (ttltirlt may m may not lm thr dcclamtintt nscd by default) rcntain in hittdings on the
rnntrrtl -tnrl.. .\ll rttltt'r.\ are tnlcn cmr of sitnply hy slnrittg objects on the control stack: the A‘lOHs
ilI\'O|\‘f‘l| .'ttt' nnt nrz-tit-tl .tntl mc tml crvatcd on loading. So. a program that SETs an ATOM‘: local
value fnt .1|tr-tlmr pm;;r.1tn tn pic}. up nttut tlcclarc that ATOM tn be SPECIAL. ll‘ it dnt'sn't. the ATOM‘;
bitttling will go .1“-.1ytltt|ing rmn|tiling_ and the prngrant that ttccds to re-fcr to the ATOM will vilhcr
get .1 ttn-\'.1lttt‘ t-rrttr Ht rcfcr tn an virnncotts binding. Usually only I\TOHs which have lltc opposite
sp(‘Cl:\|l_\' ttnm that 4-f the rntrcnt SPECIAL-MODE are explicitly drclared. The usual SPECIAL-MODE is
UNSPl'ClI\t . w I) ptrnll) only SPECIAL tlcclnratiotts use lltis construction:
FDECL ((/\Cl) <$F'€CIl\L /\CTIVI\TlON))
vxpliritl) rlrrlmrn. Nil I0 ht‘ SPl'C1l\L.
Most tv-vll-\\'|ittt~|t. tnr-tlnl.tt prngr.t|n\ get .\ll their inforntntintt from their argtttttcttts and from
GV/\l_s. .-tntl tl|tt'~ tlu-y t.1u~|)' ll\C Sl"l'C‘ll\L I\YOH~. cxccpl perhaps for ACTIVAll'Olls and the ATOM;
\vhn'~t' IV/\l\ t‘\H)l ||\r~\ l|_\' tlrfnttlt: IFICIYAH. OUlCill\|'i, OBLIST, DEV, SNH, HHI, NHZ. OUTCHAN is
:1 spa-i;tl trtw-: tht- rntttpilt-r |lunl;.s that .\ll rnttverrtinit-otttpttt SUBR§ arr: callvd with an cxplicil
Clllttltlll argtntu-tit. nlu-tltur on nnt the |>rn;;r.1tt| lacing compiled thinks so. For txatnplz-. <CRLF> is
\'<tttt|>iIv~-I .‘l\ ttn-n,;h it \\-rrc <CRtt' .OI.|TCt|AH>. Sn you may use (or ace) the binding (OUTCHAN
.OUl(Ill;‘~N) in an ;t|t_'t|ttt¢‘lll I lSl_ Itnwrvcr mltl that may appcar. bccausc that -- cottplcd with the
ttsttnl ltlJSI'l ('1/\l_ <l(~ti.tt':tttntt by default -- |t\;\Ll‘5 only one rrfcrence to the current binding of
0Ul'CllAH.1tuI .~tnHs thv rcutlt in a slﬁl on thc stat‘-it for use within the Function.
I4-2. I:I.\:t_tttplt:
-'lIlCL ((0) (OR Vl-CTOR CltI\NllFl.>)
dcclarrs .0 to lm cithtt :1 VECTOR or a CHANNEL.
IDECL ((l" Q R S) (PRIHTVPE LIST))
dvclnrcs .F‘. .0, .R, nntl .5 all In be of PRIHTYPE LIST.
illElTL ((l-) (iOl§N [3 I\NY]>)
declares .F tn hr a FORM t\~hn\o length is at least thrce. containing objects of any old TYPE.
'i7ECl ((LL) ((F'RlllTYF’E lIST> [4 (LIST [REST FIX])]))
d(~<:l.1r<~~ .tt to hr nf I'Rll'tTYl"£ LIST, and I0 have at least four elentents. each of which are LIST: of
ttttsporifirrl It-n_q|h (|m\\il|l)- 1-ntpt_v) cntttnittittg F1Xcs.
l~1.l - 14.2 Data-type Declarations
I
I
5
2
t



I
H
The MIH I'|1~__'|n\un|i||;_I I :\n§;u:\f1r‘ I29
~1|||l (\'V\-') <\ll I IOR I IX I\IOl1 ClIf\Rl\CT[R>)
dﬂ-|;"(~. ,\/\/ m lw 4 ‘ll'('10|‘l \\iIl| at lvnsl lhrvr clcnu;-ms. Those elemrnls are. in order. of TYPE FIX.
ATOM, .'\lI|| |'|lf-|'1|'\| II fl.
\|\(|l ((|ll) 'llS1 IUOH [RPS] I'lO!\1]>)
drrI:\|r~\ Ill I|\ hr .\ 1 rm \\||u'~r nun vlcmrnl is an ATOM and the r('\l of whosc clcunems are FLOAM.
1| 3|“-\ \;\\ \ \h.1l .l ll i'~ AI |(‘.1‘~\ nnr r'l:~|ur-ul lnuq.
.|..'¢~\ (iTOn)<llS1[R[ST '1r1x1>)
lll‘r|I|I1'\ _| un \n |--- .1 l lﬂl “I--uw ﬂ1h|~|Iﬂ$ilirIllI‘i| (‘lr‘|\|l-\||l\ are the ATOM T and wlmse even-positioned
\ elvum-nr- aw I I‘:-\
~H/\|‘l{ ->
z|ll!u'l\ﬁH (X)
~1-111 ((x) <V[C10R [1 FIX]))
“I'll! .X I 0))
.100)
<h-\~1.u(~ ‘>4 1-~ I--» ;| VI VIOR wuumining .1| |v.1\I mu‘ I IX. Tl-v nmro rcuriclive [REST F1X]wr-uldlnke
<~\rr~~-\<- <|u'\| m-_ lllnv I-v rhr iuumprrlrr. hcramc \l|r- RFS1 of who VECTOR would be checked on
cnrh |lI‘|.\\|v\n -n 1|---(1/\|-H. In ||,i~ <.1\<- lmvh Irl Cls nrr rqunlly pnwbfflll. l|('<‘iHl\(‘ chock-Jug vhc first
<‘|r‘n|~ nu ul .»lX1l-- lti \1~ nl .1 \n|n1nrr r‘\r|\1||.\l|)'1ht‘(‘l.\ all Ihr cl:-nnrnls. Alsn. wince Ihr FUNCYION
. "‘fl"‘ ""1\ \" '1" Iii“ "1l'IH-‘Ill HI .‘i. \Iu'~ i~ ax |||||rl|cl:~cl::r.1lirv|| ;u!he Qmupilrr can cffrclivrly Inc.
i (If Il|i~ v|- 1|‘?-1 .11“.-\~ -K-|||.|m\ uuly |']Xr\, iv \lmuhl ho a uvxcrorz imu-ad. for \pi\r(' cfficizmcy.
Tlu-u .1 llfl 3| I l\:| |-I ~| \\m||.! |n.1l.(' (hr i|m~||ncu-r rhrck only lhc UIYPE. If Ihe FIXcs covcr I
wnall Ilﬁll-III‘-_;Al|\ 1- |.u|\;n-. (In-u a UYH S might ht‘ oven l1<'Her,wiIh 2 DECL OT <i3YTES rl O>-)
¥
i \l\lI IHI F/U“! (H)
-l'k| (U1) <llH.\|‘l('1l\l |IX))
<lOIHI (<07 .H> l) (ilbi. (" .N (FACT (- .N l>)>)>>
d¢~rl.1m~ .N m hr ur 1\'|'I I IX :\n|| IINSPFCIAI . Thiv sprcially rlcclaralirm cnsurcs lhal. independent
' of SH r lI\| ~nn|-1 |l\||i||!; rrnlupllinq. .u grn (‘mn||ilrd mm a fan cnmrobslack rm.-fcrcucc.
(FROG ((l (0))
'lII\'l ((l V/Hlll) (llIl$f'[CII\L (LIST [RKST FIX]>)
(H) <llH.\|‘IC1I\l llX>)
(CONN (<07 J4) <RLTURH .L>))
(SIT L ((+ .N (I .L)) !.L))
<SlI N <~ .N l>>>
i 14.2 Data-type Declarations
F
IFIIIIFFIIIIFIIIIIF
I



I30 The MDL Programming Languagg
The :|lIr\\ v (|(‘\‘|£l|l‘\ L and H I" be UNSPECI/IL. says lhal .N is 2 FIX, and says that .L. along with
the valur r(‘l||rl|(-1|. Ia :| LIST nf any lvnglln compnscd cnlircly of FIXes.
I-8.3.  S!-_||>|;1__\v
This -rrIin|| gin-'~
type-spvrifivrs are
dccl :-=
detlprs ::=
atlist ::=
Pattern ::=
Dal =
unit =
scruc =
bstruc : =
elts =
opt ::=
:|n.1-i-{INF prmluclinns for the MDL DECL aynlax. In the following table MDL
(li\li||g||i-Iu-cl H1 H115 way.
‘IIFCI (dvclnrs)
(-1LI1sL) pattern I dcclprs dcclprs
J'O"| I alcm ntlist
I;-‘H. I <UHSPECIAL oat.) I (SPECIAL pat.)
unut. I (OR unit.  unit)
hpe I <|‘|'!Il'iTYf’E I_»p¢-> I alum I ‘any
I ANY I STRUCTURED I LOCATXVE I APPLICABLE
<str'nc c1Ls> I <<OR struc  str~uc> cits)
!<sLruc c‘lLs> I I<<OR shruc  st.ruc> cits)
<bsI.ruc /Ix) I <bsLruc /IX hx>
!(b.<.t.r||c fIX /nr)
-=lruc.’urcd-Iypc I <PRI|1TYPE structured-!ypc>
BYIF5 I (PRIHTYPC HYTCS)
uaL I |2.|I. elts
I [In pat  p-17.]
I [hv rant  p.1L]eIts
[o|>!. pat  nah] I [RESI pal.  pat]
[opt pat. ... paL] [RES1 pat.  pat]
OPT I OPTIONAL
I4-‘Z - 14.3
Data-lypc Declarations



i
l
\
The M DI. Frrvgrallltning Langttage l3l
|.; -I C-nml HEN s
There .-are \0Ill[' llll("> nf thumb cnncerning "good" DECLs. A "good' DECL is one that is minimally
,,ff|_-|i<,i\~e tn the D[CL~v:lie\-Lilig mechanism and the compiler. but that gives the maximum amount
of m|‘nrm.1rmn. It is simple m state what gives offense to the compiler and DECL~ch|:cking
|nech:\ni~.m: cntniplt-xity. For example. n latge compound DECL like:
r-DECL ((X) (OR FIX LIST UVECTOR F/\LSE>)
is a DFCL lI|:\t the t|"lll\|IiIt‘r will find tntnlly ttseless. It might as well be ANY. The more involved
the OR, the Iv“ i|ilmm.wiiun the (‘Ol1l[)l|l'l' will find useful in it. For example. if the function takes
<0R LIST \/l C‘lOR t1ufCT0R>. lll.‘tyll(‘ ymi shnnld really say STRUCTURED. Also. a very general DECL
inrlirntrs .\ \‘(‘l_\ y<l‘Ill“l.'li p|ngiam_ uhirh is not likely to be efficient when compiled (of course there
is a tratle-oil ht-tel N.n|n\\-ing the DPCi to one PRIHTYPE gives a great gain in compiled efficiency.
to one TYPF still tnme.
.-\nm|ii~r Rllllitliﬁtl tn hr .1\~niilrd is thr nnlinnry large DECL. even if it is perfectly straightforward.
if you h:\\i- ttt‘.'1lt’(| .1 \llll\‘lIllP \\-hich has a very .\pt‘cifit: DECL and is used all over your code. it
might he il('lil'K .\'~ .1 tll"»ITYPE (sec bi.-lowl. The zidvaniagc of a NEHTYPE over a large explicit DECL is
tn-ofnlil liiru, the entire structure must he clieckcd only when it is created. that is. CllTYPEd from
its PRIMIYPI . »\\ .1 fnll ﬁt CL. it i\ checked completely on entering each function and on each
reztssignim-nt of ATOI-l\ Di-_Cl_ed to he it. Second, the amount of storage saved in the DECL: of
FUNCTlOll~ nml m Htl is I.1rge.n0t tn mention the effort of typing in and keeping up to date several
inst:\nre\ of tlm full DLCLV
14.5. Ql£h_.1l in cg
l4.5.lt GDECI antl ll/\NIFEST
There are nvn \va)'\ to tleelnre GVl\Ls for the DECL-checking mechanism. These are through the
FSUBR GDECL("§lul1:tl tleelarntiott") and the SUBR MANIFEST.
(GUI Cl .wlom<;lIr:l P/n‘|‘£'!n . . .)
GDECL allows the l_Y|7L'/§lI'lll‘Itl((’ of global values to be declared in much the same way as local
values. F.x:unple:
<GDECL (X) FIX (Y) <LIST FlX>>
declares _ X to be a FIX. and ,Y to be a LIST containing at least one FIX.
<l1l\llIFEST dIOm alom ...>
. l4.-I ~ l4.5.l Data-type Declarations
I,



I32 The MDL Programming Language
HANIFEST |:tLt-s as nrgtttnents ATOM: whose GVI\Ls are declared to be constants. It ls used most
commonly tn intlirntr that certain AT0l'ls are the names of offsets in structures. For example:
<SElG X l>
(HANIFEST X)
allows the rmnpih-r to rnufitlt-utly opt-n-compile applications of X (getting the first element of a
structnrrl. Ltmu-in; that ,X will nut change. Any sort of object can be a HANIFEST value: if it does
not get ('l|I|ll.'d\l\'d in the compiled cndr. it is included in the RSUBR's ‘reference vector". for fast
access. llnwcvcr. .15 a _qcnrr.1l rule. structured objects should not be made HANIFEST: the SETG will
.sttr\'i\'r in the rﬂtnpilrtl version (for the use of new uncompilcd programs). but uses of GVAL will
instead refer tn :1 ttistinq rnpy of thr object in each RSUBR that does a GVAL. A structured object
should ittstrnd be G(IECLt'd.
An attempt In SF It} a MI\Hll'l ST AIOP1 will cause an error. unless either:
(ll the l\lOl-l was |»re\'im|\l)' glnlrally unassigned:
(2) thr old value is ==? tn the new value: or
(3) .REDCr me i-. not FALSE.
l4.5.2. HAIJIFEST? and UNHANIFEST
(H/\HlFESl7 Jlbnt)
returns T if -=10/It is HANIFEST, IFALSE () otherwise.
<Lll‘<lllI\NlFiSl alum .1Iom .. .)
removes the t~tA|tIt‘[Sl' of the global value of each of its arguments so that the value can be changed.
l4.5.3. GBOUND7
<Gl'lO\llll'l7 .=Iclm>
(‘globally bnu||d?"l returns T if A/O-'-‘I has a global value slot (that ls. if it has ever been SE\'Ged.
HANIFEST, GDECt<‘tl. nr GlOCed (chapter l2l with a true second argument). IFALSE () Otherwise.
l*l.5.l - l4.5.3 Data-type Declarations
i
t



The MU]. l'rngr.1n||ning l.:\ngnage I33
| I-L6. Nl l_-£(l‘l' H21!)
I
I
. HEHTYPI1 gin-- the |nn;|.1|nnn:r :\nntht-'r way tn DECL objects. The third (and optional) argument of
i N[uTYt‘l is .1 OlIOIl'tl |'.1ttcrn. H givrn. it will be saved as the value of an association (chapter I3)
using thr nmnr of tI|t' rtrutvrc as the Il(‘lII and the ATOM DECL as the indicator. and it will be used to
rlmck any r\h_]0ct that is ahottl to he ClllYPEd to the NEVTYPE. For r.-xatnple:
l <Hl'\~lTYl‘l' C()l“1I‘LCX-NUHIIER VECTOR '<(PRIMTYPE VECTOR> FLOAT FLOAT>>
crcntz-s .1 llt'\\ IYI'l . \\'ll|| its fi|.\t twn clctncnts declared to be FLOl\ls. H‘ later someone types:
| ~00:-wt I x-nut-min r t .0 2]
an crrnr \\'l|l u~~nlt (the sm-nntl (-lvtncnt is not a FLOI\l). The Pattern can be replaced by doing
.1noth<~r Xtl',HTYl‘L tn: the same TYP[, nr by putting a new value i|| the association. Further
vxanlplrsz
<H£\.'l‘1'l’E I00 LIST '<(PRIl-ZTYPL LIST) FIX FLOAT [REST Al'OH]>>
Cnttsrs l'OOst1\ cﬂ|\l'.1i|\ a FIX and a FLOAT and any number of ATOMs.
(lllil-"lYl‘l'. BAR LIST)
<SIl A ~l3/\R (ll'lI\R () l lt2 GRITCll)>
<HI_\Jl‘(l‘F BAR LlSl ‘<<l"RIl1TYPE LIST) BAR [REST FIX FLOAT A'lOH]>>
This is .‘\|| t‘\.'\tn|ult- nf .1 in-ursivcly l'l£‘CLcd TYPE. Nntc that (l .A> docs not satisfy the DECL,
becausv.- ll ts ('t|tpl)'. but it was CHTYPFd before the DECL was associated with BAR. Now. even
<CHI\‘l‘[ <1 .A> <TYPE <1 .A>)> will cause an error.
In ('.'u'lt nt" llirsr‘ <~\;nn|~lv~, the <<l"Rll1TYl‘l' . ..> ...> construction was used, in order to permit
CHTYl‘Eing nu I-l|_|<-ct intrv itself. See uhal happens otherwise:
<Hl\-lTYl"l' OOPS l!ST ‘(LIST ATOH FLOAT)>$
OOPS
(SET ll <CHTYPE (E 2.71628) O0PS>>$
"OOPS (E 2.71628)
Now <ClllYl‘l .f\ OOPS) \\ill r.-utsr an vrror. Unfortunately. you must
<Clll'Yl"[ <CllTYl"[ ./\ LIST) OOPS>S
I/OOPS (IT 7.71878)
14.6 Data-type Declarations
L



I3-I The MDL Programtning Language
l-8.7. Cotrtlnlljttg {IHIL (_Il\qcLi_|§g
Therr arr '~l‘\'f‘l'.1i Stinks and rsuutu in MDL that are used to control and interact with the DECL-
cliecldttg tttecltattistn.
I-l.7.l. D|'Cl.—Clll'CK
This vllllll‘ t-r-tuplv.\ rltt‘t‘l.ittg tut-chauiatu can get itt the way during debugging. As a result, the
tnnst cntntnnuly turd l‘I[CL-nrirntcd SUBR is DECL-CHECK. ll is used to enable and disable the entire
OECI-clterling tttrrltanisnt.
<DECl -CHECK !.aIce>0r-<m_v>
If its single mgntnt-nt is unu-FI\l_SF_ DECL checking is turttcd on: if it is FALSE, DECL checking ls
turned nil’. The |nt-rimts state is returned as a value. ll‘ no argument is given. DECL-CHECK returns
the cttttrnt slntt‘. lu an initial MDL OECL checking is on.
\\'l|en t1l’t‘| rlwrl int; is ntt. the UFCL nl' an ATOM is checked each time it is SET, the arguments and
results nf t-.1ll\ tn FlIllCl']OlJ\, RSUP.Rs. and RSUBR-ENTRYs are checked. and the values returned by
FROG and RFPFAT are cltt‘cl.t~tl The saute is done for SETGs and. in particular. attempts to change
MANIFFST glnhztl \'r\Ittt'\. |\ttrn|pt.s In CIITYPE an object t0 2 NEHTYPE (if tilt NEVTYPE has (ht
Oplinllnl DI till are also ch:-cltctl. \\'ht'n DECL clteckittg is off. none of these checks is performed.
l4.7.2. SP! (T II\l -CHLCK and SPIICIAL-MODE
(SPEC IIKL-CHECK false-or-any)
Cﬂlllrnls tvlmtltc-r m unt $l‘fClI\t rhccl_iug is pt-rl'nrmed at rttn time by the interpreter. It is initially
off. F.1ilnn- tn tlvclnre an I\10H to he SPECIAL when it should be will produce buggy compiled code.
(SPFCIAL -HODC R;-eu.=Il_\':alom)
sets tltr tleclnrntintt usetl by tlt-fault (fur /\l0Ms not declared either way) attd returns the previous such
dcclar:ttinn_ nr the cttrt’t*|tt such declaration if no argument is givent The initial declaration used by
default is UHSPECIAI .
l4.7.3. GET-DECL and PUT-DECL
GET-DECL illltl l‘Ul—IIl rt are ttsed tn cxatttitte and change the current DECL (of either the global or
the lornl value) of an ATOH.
<G[1 —l)l'('.l 10rd)
l¢l.7 - l-1.7.3 Data-type Declarations
1
\
i
i
rs
FFFFFFFFFFFFFFFFFFFFFFFF



The Ml)l l‘rng|.1nt|ni||§_' Language 135
‘ returns lltt‘ M (‘l l'.1ui~rn (if any. ntlncrwist‘ IFALSE ()) associated with the global or local value slot
‘ Qf an I\l0ll. For (‘X5lIllp|(':
<l‘ROG (x)
_ mrct ((x) (OR rtx rtoan)
I
I (GET-DECL <LLOC x>>
. . . >
would mlutn (OI! FIX l"LOI\l> as tlic result of tlw application of GEl—DECL. Note that because of
tlir inc r\l' LLOF. tur GLOC. for global values) the ATOM bring emnittcd must be bound: otherwise you
{ will gm an mini! This can Inc gotten around by tcsting first with BOUND? (or GBOUND?. or by giving
' Gl OC R <t'('n|nl :zr_gn|ur‘nl which is nnt IALSH.
If ah!‘ \ln| living (‘\.1ll|lll('l| is the global slot and the value is HANIFEST. then the ATOM HANIFEST is
rctnrnr-il. If tht‘ \'.‘l|llI‘ hrim; t'.\att|it\t‘(l is nm DC€Lr:d. iFALSE ()ia returned.
<PUT-DFILL lnrd -*".|IIcrn>
tn.-tlms 1*.»/I. ~11 hr tlm ﬁt Cl for tlic vnlnc and returns lord. If (DECL-CHECK) is trnc. the current value
must '~.1li\l'_\‘ llm nu-\\' Patlvrn. PU!-DECL is normally turd in dcbugging. lo changc the DECL Of an
nb'0ct In (\ - (I ' ' ‘
J t ll'\\|7II|l tn rhatugﬂs tn the program. Note that ll l5 not legal lo PUT-DECL a "Pattern" of
P-tANIl"l'Sl (ll '-r/\LS[ ().
l-6.7.-8. DECL?
(IIICL7 .0/at P,alI¢‘r/I)
sp£'CiI'i\‘;\l|)' ch:-rl.\ -7I1_t against Pallcrn. For example:
(DFCL7 '[l P 3] ‘(Vi-ICYOR [REST FIX]))$
‘I
<D[CL" ‘[1 2.0 3.0] ‘(VECTOR [REST FIX]>)S
-4|/\lS[ ()
l-1.3. OFF Sl"_l
An OFF$El i\ r‘\\vttli:||l\' .1 l'lX with .1 Pattrrn attached. considered as an APPLICABLE rather than I
nntnhcr. /\ OFFS l - ' ‘
n F nllrms a prngratn tn specify Hie type Of structure lhal |ts FIX applies lo.
O7FSl:l'~. ||k- l>l=‘l= ~ if nu-d pl'l'1p('r|_V -- can ntaltc debugging considerably easier: they will
€‘\'£-ntnztlly .1l'~u lmlp tlir rmnpiler generate nmre cfficicltt code.
l-1.7.3 - l4.8 Data-type Declarations
\
?
L



I36 The MDL Programming Language
‘ The Stllitt OFFSFI t.1l.t-s twn .-trgutm-nts. .1 FIX and a Pattern. and returns an object of TYPE and
l"RIN‘lYI't OI l'S[“| . An OFFSII, like :1 FIX. may be given as an argument to NTH or PUT and may be
rtpplietl tn ;t|'g|||nt‘|tl\_ The only tliffctettce is that the STRUCTUREO argument must match the
Pattern er\n1:|in<~|t tn the OH Skl. or an etror will result. Thus:
(Sill) F00 (OFFSET l ‘(CHANNEL FIX>>)$
‘/kOll'Sll 1 '<C|l!\l|N[L TIX)>
(FOO ,lll('HI\N>$
1
(FOO <ROOT>>S
"l'Rl!OR*
ARG-l-IROHG-IYPE
Nlll
IISIFNIIIG-Al—l[Vl'L 2 PROCESS I
Note: \\ht‘t| the cmnpilt-r gets nrmmd to understanding 0FFSETs. ll will not do the right thing with
them nnlns they are NAHIFCST. Since there's no good reason not to HANIFEST them. this isn't a
problelni
The SUllR INIIEX. gin-It an OFFSET, returns its FIX:
<1?-'lI[X ,fOO)S
I
GE T-D[Ct hf an Of FSET tctnrns the assnriated Pattern: PUT—DECL of an OFFSET and 2 Pattern returns
a new 0l'l'S| I with the same INDEX as the argnnteut, but with a new Pattern:
(LET-l'l[Cl .FOO>$
<\'Yll/Xlllllfl FIX)
<l‘lll-lllfl ,lOO Olll.ISl>$
'/-<Oll!sk l l O[lLlS‘l>
,l'OOS
Z<Ol'lSfI 1 '<CIlAHH[L FIX>>
‘ An OH-'SE_T i> not .1 sunclnred object, as lhis example should make clear.
t-1.9‘ II».-_tt_s|,|ntt nttt
The R$t1Rtt nrrt t< \in|i|:|r tn the ATOM DECL, except that the declarations are of argument positions
and value |.'|tht'| than nf \peril'ic ATOM. Pattern: can be preceded by Sl'RINGs which further
describe the nrgntttvttt (or value).
M.8 ~ l-1.9 Data-type Declarations



I The Ml')l. l‘rrv_Q|'.1nt|nint; I nngnage I37
i
The .sitnplt~st RSUHR FIFCL is fnr an RSUBR or RSUBR-ENTRY (chapter I9) which has all of its
grgtllllbltls r-rnltmlrtl and returns a Dl'Clr<l value. For crtantplez
"l7lf'CL ("Vl\LUE" FIX FIX FLOAT)
dt(‘l.‘t|("~ t||.'tt Ihmv rut‘ two a:t;utnonts. a FIX and a FLOAT. and a result which is a FIX. While the
t 51R1HG "v/\tut-," is nnt cuttslraitletl tn appear al the from of the DECL, it does appear there by
cttstntlt It nm-tl tmt :\p|\(';lY at all. if the result is not to be declared. but (again by custom) in this
case it is t|sn.tll)' tlt‘cl.1tt-tl /‘tHY.
' If any :n;;nntt-ttts :ttt- npliullrtl. the SYRING ‘OPTIONAL’ (or 'OPT‘) is placed before the Pattern for
the first nptilulml .1tt_'u|nt'ut:
‘ *'|ll’(.'l ("V/\lUl " FIX FIX ‘OPTIONAL’ FLOAT)
If any nf the xuqttntcttts is ttnl to he evaluated. it is prcccdr.-d by the STRING ‘QUOTE’:
I
'/ll£CL (“V/\LU£' I-[X "QUOTE" FORM)
x dcclnrt-\ mic :trquntrttt. \s"hirh is unt EVl\Lt"d.
\
ll the zugttntrttts atv In be (-v:tlu:t|¢-tl and gathered into a TUPLE, the Pattern for it is preceded by
the STRING "IUF'l.f":
t
1
"lliI(‘L ("\/!\llll>" l'lX "'|UPLl;" (TUPLE [REST FIX]>)
If the atgtttnt-nts mt‘ tn hr nnt~v.1l|t.1tcd and gatltcrctl into a LIST, or if the calling FORM is the only
'argtttnrnt"_ the l'.1llctn is |irt~cctlctl hy the appropriate STRING:
PUECL ("V/<lUE" FIX "ARES" LIST)
vDlCl ("Vl\l.lll"' FIX "CAlL' <PRIl1TYl"E LIST>)
| Ill every <:tst- tl|t- \pL'tl.‘|l intlicatnr SYRIHG is followed by a Pattern which describes the argument.
cvcn tltmtqlt it tn.-ty snntctiutcs produce fairly lndicmus results. since the Pattern for 'TUPLE" always
Inns! he .1 llll‘ll ; fnr "ARCS", a LIST; and fnr "CALL", a FORH or SEGMENT.
14.9 Data-type Declarations



1'
t
t
l38 The MDL Programming Language t
i
I
Chapter 15. Lexical Blocking 
L('\'ir:\l. or untir, |7|l'l(l_i|I_L' is another means of preventing identifier collisions in MDL. (The first
was dyn.-nnir lrlnclitn; -- hinding and ENVlRONl1ENTs.) By using a subset of the MDL lexical
blocking fntiltltt-s. the "hlnrl. structure" of such languages as Algal. PL/l. SAIL. etc.. can be
simulated. should ynn wish tn do so.
l
I5. l. l'l:tVsi_<;(Ir\_|t'~ttlrr.'tlintts
Since wh.-it l'4>Iln\\'\ :\ppe.1rs tn be rather complex. a short discussion of the basic problem lexical
blocking u-l\-es .1nil!\ll')l.'s basic solution will he given first.
/\lOHs are iih-nul'ir~is. ll is thus (~\\etltiRl that whenever you type an ATOM. READ should respond
with the nniqu<- itlc-ntifier )'rtt| wish tn designate. The problem is that it is unreasonable to expect
the l"l‘tI\ll[~. nl all /\TOlts to he unique. When you use an ATOM A in a program. do you mean the A
you typt-il tun minutes ago. the A you used in another one of your programs. or the A used by some
librnr ' )rﬂ"r.'|lt|?
) I >-
Dynntnic blrtclitti; tpuslting down of LVALs) solves many such problems. However. there are some
which it l|ﬂt‘\ unl mlvc .- mrli as state variables (whether impure or pure). Major problems with a
system hat in; only ilyuntnic hlm-Ling usttally arise only when attempts are made to share large
nntnbz-r.~ of si§nil'i\~an| prngmtns among many people.
The solution ll'\(‘tl in l\ll)l, is basically as fnllntvsz READ must maintain at least one table of ATOHs to
guarantee any ultiqtlc-ttr'~'~. So. MDL allows many such tables and malies it easy for the user to
specify nhtch one is \\;tnlt'd. Such 2 tnhle is an object of TYPE OBLIST ("object list"). All the
complication \\'lIlk'|l rﬁllO\\'\ arises out of a desire to provide a powerful. easily used method of
working with Olll lSl\. with reasonable values used by default.
J
l5 - ISJ Lexical Blocking
I
€
4



Tr
I
I
.
I
l
t
I
1
l
‘;
The MDI Prngntlntning language I39
15:2. onLI$1:
An OBLIS1 is of t'RlIHYF‘l_ lIVkClOR with UIYPE LIST; the LISTs hold ATOH4. (The ATOHs arc ordered
by a h;|»h I.nl|i||lI on their PHAHE»: t-.1<h LIST is a hashing bucket.) \Vhat follows is information
about Olll.ISls as utrh.
l5.2.l.OBLlS1 NJlIl\'\
E\'cr)' nmn|.~il|)- rnn<ti|uu-ri 0l1l1Sl has a nantc. The nantz of an OBLIST is an ATOH associated with
the OBLISY unilt-r lhr indicator OBLIST. Thus.
<G[_lI‘ROl‘ 0I)ll‘Z, Ol1LlST>
or
(K-fl o/>11-:1 0llLlS‘l’>
rcturln the nrunc nf nbhs.'.
Si1nilarl)'. rrrr) nnnic nf an OBLIST is associated with its OBLIST. again under the indicator
OBLIST, \n that
<C[TPl{Ol" 0/_v-‘l';I—nan|0:.tfOIn OBLIST)
or
<G[l oI.w’::=r-/mmemlum ODL I51’)
returns the OBLISI “lime nanm is cbhzl-name.
Sincc I|ll‘|(‘ is nml-m_i; '~|\r‘r|:|| about thr assoriatinlt of OBLISTs and their natnrs. the nalnc of an
OBLISI t‘:\|1 lm tlirtntjrtl hy usr of l'UH‘ROP. hoxh on the OBLIST and its name‘ It is not wise to
cluutgn the OBLISI :\§\rtrinti|m withntn changing the nzune association. since you arc likely to
i:o||l'n-c RI,/\D and PRINT terribly.
You can nlw nu‘ I'll! Hr f‘llI|‘kOl' tn rc|n0\'t' the as\oci.1!ion hctwcvn an OBLIST and its name
(‘ﬁllI|)|t'|t'I_\‘. ll‘ )1-n want the OBLIST to go .1w.1y (be garbage collected). _aLl you want to keep its
n.1tnr~ Allillllti. thn |nll'~l ht‘ tlr-|n~: ntIn~|wi~v the aswciatintt will fnrce it to stay. even if there are no
nthci l(‘r(‘l'r‘ll(("~ tn ll. tlf you h.\\-c no rt-fcrmircs tn either the name nr the OBLIST (an ATOH --
i|tclndint_; .1 l‘»‘l‘l nnmr -- pr-inI\ tn its 0f1llST)_lmtl1of|ltrn| -- and lhcir auociatintt -- will go away
witlmnt ynur lt:t\'ttt;_' tn rcnnnvc the .1\snci.1tinn. of course.) lt is no! recotntnencled that yon remove
thr ||.1tn(‘ nt an OIILIST \\itlmnt h:t\-mg ll gn .1\\'.1y. since thou ATOHs in that OBLIST will PRINT the
same .‘l\ if llur)‘ nmr in nn om IS‘! -- which is dcfcntittg the purposc of this whole cXcrcisc.
l5.2 - l5.2.l Lexical Blocking



l-$0 The MDL Programming Language
l5I2L2y N001 l$l
<NO8LlSl' alum hx>
("|\\:4L¢' nhlist't cr!‘.'tlP\ :t|tt| rt-tnrus .1 new OBLIST, cnntaining tto ATOM. whose name is alum. unless
there :tlre.1tl_\ twists an OOLXSI of that nnttte. in which case it returns the existing OBLIST. /ix is the
size of the Oﬁt IST rrratt-tl -- the tntmbcr of hashing buckets. fix is optional (ignored if the OBLIST
already t'xi\tsL I3 by tlt-fault. tr specified. /ix should be a prime number. since that allows the
hashing tn work be-ttcr.
I523. Olll. ISI?
<OBLlSl" ulom)
returns ~FI\| SE () if .1.'0mis nnt itt any OBLIST. If alom is in an OBLIST. it returns that OBLIST.
l5.3. REAP nnil Qlll IS-ls
READ (‘an Irv t‘\|t|it‘illy mhl tn lonl. up an ATOM in a particular OBLIST by giving the ATOM a trailer.
A trailer rnttsists nf tht- rltatactcrs !- (cxclatttatiutt-point dash) following tlte ATOM, immediately
followed hy the n:tmv nf the OBLISI. For example.
A! -OB
specifies the unique /tl0:l of Ptlftt-IE A which is in the OBLIST whose name is the ATOM OB.
Note that tho ttntttt‘ 4\I' the OBLIST tnltsl follow the !- with B separators (like space. tab. carriage-
return. Pita). The-re is a tt.1tnt~ usrtl hy dt‘l'atllt (section l5.5) which types out and is typed in as
!—sepm.tIo.-.
Trailers can hr use-tl rrrntsively:
B! ~I\! -08
specifics the nntquo AIOH nf PHAMF ft which is in the OBLIST whose name is the unique ATOM of
PH/\HE I\ which is tn the OIILISI whnse n:tme is Oil. (Whew!) The repetition is terminated via the
lool».-up and ilt\t'|lin|| tlt-~ct'il.ved below.
If an /\tO2l with :4 git-t-it t'lU\H[ is ttrn fntmd in the ODLIST specified by a trailer. a new ATOH with
that PNAHF is rrvatt-tl :tncl itnerterl intr\th.1t OBLIST.
lf an ODL IST wltnw n.1tnc it given in a trailer docs ttot exist. READ creates one. of length I3 buckets.
l5.2.2 - l5.3 Lexical Blocking
A
l
F
r
is
t
L
 
I I
 
DID-lIIIIIlIIl
I hlell
 
FUIFF



T
1
1
»
I
Q4
The Mill. I'|n;;i:tnnttittg I.:ttt§;ttagr- l4l
tr traik'r ttttmttntt is ttnt ttst-tt (thc "nntnt:tl" case). and for an ATOM that terntinatcs a trailer, READ
mt-,L,< up thr l‘tlt'\tlI' of thr ATOM in a llST of Ol1LISTs. the LVf\L of tltc ATOH OBLIST by default. This
lonl.-ttp \l.'Ill\ \\‘Illt <1 .0!!! lSl> antl rmltinttcs until .0BLIST is exhausted. If the ATOM is not
fntttttl. Rt’/\t1 n~n;tII_\- llIS('|l\ it into <1 .OBLIST>. (it is possiblc to force READ to ust: a different
vlctttcnt nt‘ tltt- IIST til’ Ol"lLlSTs fnr new insertions. if the ATOM DEFAULT is in that LIST, the
OBLIST fnllntvittg that ATOM will lit‘ nscd.)
|_5.-I. r'Rt_u|_ .1m_| Qtzt t$.Vt_s_
\\'hcn PRINT is tgirt-tt :ttt ATOH tn ntttpttt. it otttptlts as little of the trailer as is necessary to specify
the /\TOll ttttiqttrlv tn RI’l‘\l‘|. ‘l'lt:tt is. if the ATOH is the first ATOM of that PHAHE which READ would
fintt in ll\ nmtn.tl tr---L-up in tltr rtirrcnt .ORl IST, no trailer is output. Otherwise, !- is output and
the name of tltt- OUL lSl is rrcttrsively PRlNled.
\\'.arttittt-_: tltctr :ttt- ttltsctttc casrs, wltirlt do not occur in ttortnal practicc. for which the PRINT trailer
recursion tlnrw tint tmntin.-tte. For instance, if an ATOM ntust have a trailer printed. and the name of
the OBLIST is an ATOM itt that very sante OBLXST, death. Any similar circular case will also give
PRINT at ltcrnia.
|5.5. |niti.1]_§t.1_t£
ltt an itttti.1lt\lI>l. .0i1tl.SI r(ttttI\tttSl\\/0 OllLlSTs. <1 .0BLIST> initially contains Ito ATOT-ts. attd <2
.0Bl 1ST) rnttt.tttt- all the ATOM» tvltose G\l»‘\l.s are SUBRs or FSUBRs. as well as OBLIST, DEFAULT, T,
etc. lt is \lllll('llll tn lnsc ttacl. nf the lattcr: the specific trailer !-separator will always cause
rcfcrritrv tn tlt:tt Ont I51. ltt ntttlitiott. the SUBR ROOT, \\-lticlt takes no arguments, always returns
tltal Olll IST .
Tltv tt:\tttt' nf <l".O0t> is R001; this ATOM is itt <ROOT> and would cause infinite PRINT recursion were
it nnt rm t|tt- tt&1~ ttf |~-.v;:.:.-.=t‘or. Thc nantr 01' tltc initial <l .OBLIST> is INITIAL (really
IHITI/\l '< l
The AIOH 01%| lST :tlutlt.1'~ a CV/\L. ,0Bt_lST is initially the santc as .O[lLlST; ltowcver. .0l3LIST is
tmt .1l'l't't*trtl lt_\- tltt- Slllilts ttstwl to nt.tttipnlatc the OBLIST structure. lt is instead uscd only when
(‘fl"('H'\ "[*('llF.
ltt the t;\s<- of .1|t <‘ttnt_ tlttt rttttcnt .OBLiST is cltt-cl.cLl to scc if it is 'rc:tsnnablc" ~- that is. contains
ttnthint; of tltr tttt-tn; tt'i't _ (lt istt‘.t\r1t:.1ltl('.ltt|t no: strtndard, for .0Bl IST to be a single OBLIST
t|tsl(‘:\tl1t| .1 1151--t tttt-tn] ll' it is IL‘t'l\tIttJlJl(‘. that value stays current. Otherwise. OBLIST is SET to
.OBt_XSI. Nntv lltrtt <h.1ttt_'t~s tttatlr tn tho O[lLlSTs on ,Ol3LlST -- for example. new ATOMs added -~
tctttattt. If f‘\I‘ll _0t‘.t IST i\ tttttcnsmtablc. Ofll IST is SET and $ElGCd to its initial value. <ERRET>
(sectimt lG lv .1ltv.t_\'s rtsstttttrs that .OZlLIST t.\ t|nrc:t\on:thlc.
15.3 - l5.5 Lexical Blocking



I
I42 The MDL Programming Language
1
Three other Olll ISM e.\ist in a virgin .\iDl.: their names and purposes are as follows: ‘
ERRORS‘ - <nnt.1in- ATOHs whose PNl\HEs are used as error messages. It is returned by (ERRORS).
INt£ltl:tIt't5'- is used by the interrupt system (section 2l.S.l). ll is returned by
<1ntt=mtut-ts>. '
Hltttttlt '- is ttsrtl infrequently by the interpreter when loading compiled programs to fix up ‘
references tn lr\(‘:\tintts within the iltterpreler. .
The pre-lrmtling nt‘ t-mnpiletl prngrann may create other 08LI$‘l’s in an initialized MDL (Lebling.
I979).
15.6. t-xt om; .1lnt_t _tmt:tp_q;
These SUl'lRs are .in.1|r-gnu» to lIC!'il and end itt Algal. etc.. in the way they manipulate static
blocking (ntnl in pg ntlmr way).
< BLOCK /r2O:'\—t.'ft;-'t'./-O/-Ob-'15"; >
returns it-. .1|;;un\¢nt after "pnslting' the current LVAL of the ATOM OBLIST and making its argument
the current lVI\l . You nutally want (ROOT) to be an elt-tnent of look-up. normally its last.
<T.Hl’t[!LOCK>
"p0ps' the LV/\l_ of the /HON OBLISI and returns the resultant LIST of OBLISH.
Nntc that this "pn\hing“ and “popping” of .OBLIST is entirely independent of functional
applicatintt. ltintling. rte.
tn
\|
$l|>[1£§_r§_::"fi_.1_I_t'tI_ trill‘ Lt-xi<*.1l Blocling
l5.7.I. RI All (again)
(READ (lt.t!:.'1z_‘! co!-roullnc /0OF<>t1p>
This is .1 fuller r.-ill tn READ. /ooh-up is .-tn OBLIST or a LIST of them, used as stated in section l5.3 l
to Innl. np Atom .1tttl ilI\f‘Il them in OllLlSTs. lf it is not specified. .OBLIST is used. See also
sections ll.l.l.|. I13. and l7.t.1l for nther ztrgntnents.
15.5 - l5.7.l Lexical Blocking
t
7,;



Tllr MD! l'rr\gr;n|||tIi||!_; Lnttgtligt‘ 143
|5_7,'Z, PARSE and LPARSE (again)
(l‘I\llSl: -.hm_- r.=r.'ii.v.'Iiv look-up)
I ,1, \v.‘t$ prm-inn'~l\' incnlir-ut‘tI. npplits READ‘s algoritlnn to string and returns the first MDL object
| r('$ll|l'i||K. This i_nt_"]||1lrs lnnling up prospcctivc ATOMs on /oak-up, if givtn. Or .O8LIST. LPARSE can
‘ 5 be call:-1| in llit‘ ~.1|m- way. See also sections 7.6.6.2 and l7.l.3 for other arguments.
I 15.7.3. lOOK|Il‘
<L0<»;ur' Y-.‘rrn_-7 @1_~n=;>
rpttirns tlm A1021 nr I'HAHl <;Irrn;j in tho OBLIST Ob/rsl, it‘ there is such an ATOM: otherwise. it rcturns
¢F;\|_1~,F ( )_ tr '/‘IN’: would PI\RSl»_ into an ATOM anyway. LOOKUP is faster. although it looks in only
one OBLXSI iintcad m‘ a LIS1 of them.
15.7.4. ATOM
< /not-1 .-~.,,,;>
creates and iotnins .1 xpanking new AIOM of PNAHE string which is guaranteed not to be on an!
t OBLIST.
An AIOH whirl: is nnl ﬁn any OBLISY is PRINT"! with a trailer of !-IFALSE ().
l5.7.5. RI HOV!
(R[HOVL' -.l/.w<_-7 :11;/1:!)
rt:'|un\'r\ l|tr‘ A10?! nf t'rtI\Ht' -:1»:/-5 from Oblrsl and returns that ATOM. H‘ there is no such ATOM,
RLHOVE |z'tu|n\ ill Itlbk (). Also.
< Rf HOVF slum >
rvttmvz-s Mn; - fir-in its OBLISI, if ll is on one. It returns atom if it was on an OBLIST; otherwise it
returns /.~F/\LSE ().
l5.7.G. IHSERI
< IHSL R1 st"-11;: or-afvm Obi,-.’l>
15.7.2 - 15.7.6 Lexical Blocking
z



144 The MDL Programming Language
create-\ nn ATOM nl‘ l"llI\Hl' ch”-;;_ inscrts it into ublisl and returns it. If there is already an ATOM with
the same Plmtll-’ :\\ ."IlOn| in nI~hr.I_ an rrror occurs. The ataudard way to avoid the error and always
get your "to,-.t is
<OR (LOOKIIP <!rtn;1 obhs!) (INSERT airing oblisI)>
As with Rljl-IOVC . INSERT ran also talc an ATOM as its ﬁrst argtnnent: this ATOH must not be on any
OBLIST -- it must Itavr ht-on R£l~t0Vl'd. or just created by ATOM -- else an error occurs. The OBLIST
argnmz-in is nfvrr optional. If you would like the new ATOM to live itt the OBLIST that READ would
have Cltnsvll. )'ﬂn can <5‘/\RSE Slnng) instead.
l5.7.7. PIJAHI
< l"|U\H[ -VI om )
rctnrn- a SIRHIG (nvwI_\- crc-an-d) which is aIOm'$ PNAHE ("primed name"). ll‘ trailers are not needed.
PNAHE i~ mm-h fauer than UHPARSE on Rfdm. (ln fact UNPARSE has to go all the way through the
PRIN1 algnritlnn twice. the first lilnc to soc how long a STRING is needed.)
15.7.8. Sl‘llI\llF.
SPNAHY ("~h:ut-tl prilttrtl name") is itIrntic:tl In PHAHE. except that the STRING it returns shares
storage with .'(t7t/v (app0mJi\ l), wliich is more efficient il' the STRING will not be modified. PUTting
into slltlt .1 STRING will rattsc an crror.
l5.8. EX5\_tt_I_|)|l'£ itt_t1t_ltt_-(_§ql_tttiptt l0 the INC Problem
What l"nll0\\'s is :tn emntplo of the way OBLISH are "normally" used to provide "externally
at-ailnblv" I\‘lOH\ and "lural" I\lOl'ls wltich are not so readily available externally. Lebling (I979)
describes a systrntatic way tn 3CC(Il||pli\|t tht: same thing and mote.
<MORl.l$l INCO l>
;"CrcaLc an OBLIST Lo hold your external symbols.
Its name Is IHCO!-INITIALP .'
INC! -NICO
;'Put. your cxl.cr'nal symbols into that. OBLIST.
If you have many. Just. write them successively.’
15.7.6 - l5.8 Lexical Blocking
T
I .
1
"I
T
n
( l
i
Oﬁ':1*€I?
i
F
tl
I
I
:1:
O.
l
N
s:
I
tl
rc
\
!
r



t
t
r
I
4
The MDL l’rngr:u|ttning Language I45
(BLOCK (<llO8L1Sl' INCI!—INCO 1) (GET INCO OBLISl'> (ROOl'>))
;"CrcnLe a local OBLIST, naming it INCIl~INCO, and set up .OBLISl’ for
rr~.-ttlinq in your program. The OBLIST INCO ls included in the BLOCK so
Lhat; as ynur external symbols are used. they will be found in the
right. plate. NoLe that the ATOM INCO is not ln any OBLIST of the
BLOCK; therefore, trailer notation of !-INCO will not. work within
current. BLOCK-FNI'IllLOCl( pair.‘
the
(DEFIHF INC ;'[NC is found in lhﬂ INCO OBLISY.'
(A) ;'A is not. found and is therefore put. into INC! by READ.‘ '
I»'lIlCl. ((VI\lUE A) (OR FIX FlOAT))
<SEl .I\ <+ ..A l>>> ;"All other ATOM: are found in the ROOT."
(ENDl'lLOCK>
This cx:uuph- is mthr-r tri\'i.1l. Inn it contains all the issues, of which there are three.
The fir~| iih~.\ ix that you sltnttld create two OBLISH. one to hold ATOHs which are to be known to
other nu-r~ ttnro). and thc nthcr tn holtl internal I\TOHs which are not normally of interest to others
(INCH. Tito --aw glint-0 has one ATOI1 in each ratognry.
§<~cnntl. IH(‘0 i\ l'.\p|it‘ill)' used tvithnut trailers so that surrounding BLOCK: and ENDBLOCks will have
an eff:-ct nu it. Thus IHCO will he in the OBLIST dcsircd by the user: INC will be in INCO. and the
llﬁer can refer In it by saying INC!-INCO; IHC1 will also be in INCO, and can be referred to in the
satnc nay: l'in:\|ly. A is really A!-INCI!-IHCO. The point of all this is to structure the nesting of
OBLIST5.
Finally. if for srwntc It‘-'lSOIl (like saving storage space) you wish to throw INC] away. you can follow
the stmttton; with
(Rl'l-l0Vl 'lllCI' (GET INCO O[lLXSl'>>
and thus rctnmv all rt-fcrctnct-> to it. The ability to do such pruning is one reason for structuring
OBLIST rr|'¢rc'||c(-s.
Note that. et on nftt-r removing INC], you can ‘got A back‘ ~ that is, be able to type it in - by
saying smucllting nf the form
(lllSllll <1 <1 ,lHC!-]NCO>) <1 .OBLlST)>
lhorcby grnliliittg A out of the ounctttrc of INC and rc-inserting it into an OBLXST. However. this
resurrccts the natnr rnIli\inn causcrl by (INC!-INCO A>.
l5.8 Lexical Blocking
i
L.
1
I.
—



146 The MDL Programming Language
Chapter 16. Errors, Frames, oto.
lG.l. LISTEN
This SUBR takes any number of arguments. It first checks the LVALs of INCHAN, OUTCHAN, and
OBLIST for reasottability and terminal usability. ln each case, if the value is unreasonable. the ATOM
is rebound to the cnrrespnnding GVAL. if reasonable. or to an invented reasonable value. LISTEN
then does <TTYECllO .INCltAN T) and <ECHOPAIR .INCHAN .OUTCHAN). Next. it PRINTs It:
arguments. then PRlNTs
LISTENING-AT-LEVEL I PROCESS p
where I is an integer (FIX) which is incremented each titne LISTEN is called recursively. and p is an
integer identifying the PROCESS (chapter 20) in which the LISTEN was EVALed. LISTEN then does
(APPLY (VALUE REP>>. if there is nne. and if it is APPLICABLE. lf not. it applies the SUBR REP
(without innl-lug n new FRAME -- see below). This SUBR drops into an infinite READ»EVAL-PRINT loop.
which can be left via ERRET (section l6.4).
The standard LISTFN lnnp has two features for getting a handle on objects that you have typed in
and MDT. has typed out. ll’ the ATOM L-INS has a local value that is a LIST, LISTEN will keep
recent inputs (what READ returns) in it. most recent first. Sitnilarly. if the ATOH L—OUTS has a local
value that is a LIST. LISTEN will keep recent outputs (what EVAL returns) in it. most recent first.
The keeping is done hcfnre the PRIHTing. so that “S does not defeat its purpose. The user can
decide how tnncll tn keep around by setting the length of each LIST. Even if L-OUTS is not used.
the atont LAST-OUT is always SET to the last object returned by EVAL in the standard LISTEN loop.
Example:
(SET L—INS (NEWEST NEVER NE\l)>S
(NEWEST NEVER NEH)
.L-INSS
(.L-INS NEWEST NEVER)
(SET FOO 69>$
69 '
(SET FIXIT <2 .L-INS)? ;'qrab the last 1nD\|l'$
(SET FOO 59>
16 - l6.l Errors. Frames. eu-_
T
L



Tl|¢- AH’)! l'rn§;r.1|n|ning Lallgnagc I47
.L-IHS3
(.l-INS (SP1 FIXIT <2 .L-INS>> (SET TOO 69))
(PU! .llXll 3105)!
(SET TOO 105)
<CVAl .TIXIl>S
I011
.L—lHS$
(.L-INS <EVI\L .FIXIT) (PUT .FIXIT 3 105))
I005
I05
16.2. l_l_z_|_:Qlz
Tl|i< Sllllﬂ i\ 1ln- mnv :|\ IISTEH, ('\f\'|7l ll|:ll (ll il generates an inlcrrnpl (chapter 2|). if enabled.
and (‘Fl n l‘RlHl\ 1! lHlOll" hrfnrc PRIHTiug its argunncnls.
\\'hcn an} fsnltlt m ISUIXR rlou-cu an annmalnnx cnndilion (for example. in argulnenu are of the
wrnng lYl'l'l. ll \ .\iI\ ERROR with al J1-as: l\\'n argnnicnls. including:
(11 an /\l('\I\ \\'|||I\\" PHAHF ll£‘\(‘!'lll(‘\ rlm |nul)lr|n_ normally from llu: OBLIST ERRORS! - (appendix
lb.
(‘ll lhv AIOI; lllﬂl ||;l||u'\ l|l(‘ SUBR ﬂr ISUBR, and
<3» .1n\ mm-r ||Ii(Illlli\|lfIIl of nntzcsl.
and l_l-mi :<~=nvn~ §\;l).1Ir‘¥‘I lhglglll In LFIROR rclnrns. Exccplion: a few (for example DEFINE) will
trike flnriiu .l\¥lr\l| lll;ll \l('|lf‘IIll\ rm lhe value relnrncd. This nnn-_\landard action is specified in lhc
vrror ||u-\~ag|- H in! FRROR :ul_;nnl('nll.
lG.3.>I_§[\l-1F_-Iln-_l‘|'7ll>
.-\ FR/\Ml n lln‘ l"ll|"(l |>I:n-ml nn .1 PROCFSSK cnnlrnl slacl. (chapter 20) wl|(~nz~vcr :4 SUBR, FSUBR.
RSUUR, m lt.S\Il‘.1¢-1lll|!Y !(I|:||1l('| IEH is .'\|1|7li('(l_ (These nbjrrls are la:-rein collcclively called
"Sub:-mnln--~"\ ll r|Il|l.'|iIl\ |nf~rm.1lim| dcsrribing ulna: was i|.)pli(‘d. plna a TUPLE whose elemcnu
arr |ln~ .'\l|_lllllf‘IIl\ In vlm <nl-muunr applied. If any of llic Subroialiinfs arguments arc lo be
('va|u:\|mI_ ||u~\- “ill l|:1\'t‘ hm-n by llnr llll\(‘ llm l'RAl'1Eis gens-rated.
A FRAI-H? |\ an .1nmn.1lun\ ‘IYPE in lhr fnllnwing ways:
Ill Ix r.1||||I'\! hr ll'p('iI Ill. ll can he gt-ncrnlcd only by applying 2 Subrounne.
(9! ll um-~. urn npr -nu Ill any \l:\ndard Inrm-1l.bul rather as IFRAHE followed by the PHAHK of
the Sulumiruw nppliml.
lG.l -15.5 Errors, Frames. El:



H8 The MDL Programming Language
lS.3.l. ARCS
(ARCS /IJI!-E)
(':ugument~'l returns the argument TUPLE of ffilne.
IG.3.2. FUNCT
<FUllCT fr .v/11¢->
("function") rrmrns ilm AIOH wlumc C/LVAI. is being applied in /fame.
I533. FRAHI (Ilm Sl|l".Rl
<l'l(/\l1E //.e/-:0)
rctnrn- llnc FR/H1! \l.'l$‘|_(‘(l ||r'f0rr._‘ frame nr. if thcrc is none. it will generate an error. The oldest
(low:-<1) Ill/'\lll that r:||| ho rcnniunl \»-ithnnr orrnr has a FU-‘JCT nf TOPLEVEL. lf called with no
-1rgtl|n|*nt~. H!/.r:F |('turn- the lnpnmsl H'll\HE used in an application of ERROR or LISTEN, which was
bound by rho itllcIpt(‘I\'r in Il|(' ATOI1 LERR\ !—lNTERRUPTS ("last error").
l6.3.-1. E.\:nnpl|-s
Say you have gnnvn an t‘rrOf. You can now type at ERRORE LISTEN loop and get things EVALcd.
For c-saunplr.
<l'UIJCT (!RI\H[>)$
I RRUR
(I UHCI (F ll/UH (FR/\l'lE )))$
Ilrc —/1.1/1.1‘-01- !/t::-Sub!0;/lmc-winch—(al/cd-EPr?OR:a!Orn
(ARCS < FR/\Hl_' (FRAME )>>5
tlm ~ .1: ;"ur.';5-/If < —Io» IIm—Subr ouhne - W/1!(l7'('4l//L’d"EF'RORt/Up/B
lG.4. EK_Hl l
<[RRET aln Iram<‘>
This Sl1HR("1-um r<-|urn")(llr.1nsrs rhr cnnnol stack to be slripprd down to the level of frame. and
(2) tltrn returns »--v_~.. The net r(‘:-llll is than the application which generated Irame is forced to return
lS.1l 4 l6.4 Errors. Frames. etc.



The Mlll. l‘|'n§_'ran||ning l_Rl|gtl3g(‘ I49
,1";-_ Atltlilinltnl \itlt~ rffrcts that would have happened in the absence of an error may not have
happcttctl.
| 11,; 59¢-utttl nrgttlttvttl tn (RRET h nptionzl. by default the FRAME of the last invoeatiou of ERROR or
‘ LISTEN.
If ERR! t is ¢.'t||t‘tl with Q arguments. it drops you 1l_l_ the way down Io the bottom of the control
stacL -- lu-l'r-tr tlw It-rt.-I-I LISTEH lnnp ~ and then calls LISTEN. As always. LISTEN first ensures that
i MDL is t(‘t‘(‘|‘lli\'('.
Exautplvﬁ:
(" 3 <4 a l>>$
"l RROIP‘
/\RG—HllO!lG-TYPE
~
|ISll"HIllG-Al-l[Vl'L 2 PROCESS I
\'I\l'l('-S (FR/tl-if (l'Rl\HF>>>S
[<t I]
<lTRPl’T 5)! ;“This causes the + t.o return 5.‘
1‘.'- ;"f\n.1lty returned by the ""
Note that when ynu :ttt' tn :\ call tn ERROR, the most recent ael of bindings is still in effect. This
means that ynn can r\.1miuc \'.1ltt(‘\ of dunnny variables while still in the error state. For example.
<l'lEl'lllL l (A "I\UX" (I3 “at sl.rt'ng"))
"[I[CL ((V/\LUE) LIST (A) SYRUCTURED (B) STRING)
(.8 (REST .A 2)) ;"Retut'n HHS LIST.‘ )$
F
(F '(l)>S
'|lHlOR"
Ol|'l—Ol —llOl|lJTtS
RKSI
LISl[llIllG—l\T-LEVEL 2 PROCESS l
.l\$
(1)
.US~
"<1 -,t.r1ng"
<tRRt_t '(f»)> ; "Make the REST return (5).'$
("it $Lt'tnt_|" (5))
I6.-l Errors. Frames. etc.



‘so The MDL Programming Language
16.5. RI“ gg
<01: mv /1 .»,..<->
<-ausrs the rontrnl marl. In he nripprd dnwn jusl beyond /lame, and then causes the Suhrouline call
that gen:-rated n.-.-..'~ In be (Inna again. /rnmc is optional. by default the FRAME of the last invocation
nf ERROR or LISTEN. RElRY differs front AGAIN in that (l) it is not intended to be used in programs;
(2) it can r(‘I|'\' any nhl lrllne (any Subroutinc call). when.-as AGAIN requires an ACTIVATION (FROG or
REPEAI or "Ali I’): and ('2) il‘ it rcrrica the (VAL nf a FORM that makes an ACTIVATION, it will cause
rebinding in the argunmnt LIST, thus duplicating side effects.
|6.6. y§n_qqt>
IJNHIND is an rS|IHR|h.1r 1.11.1". lwo ;It3_'||nIt‘||ls, usually FORM». lt [VALs the first one. and. if the EVAL
return- |ln||n.1|l_\'_ XIII‘ \:\I||e nf the IV/\l <-all is the value of UHHIND. If. however. during the EVAL a
non-lnc.1| l(‘|lllll .Illl‘lIl]!I\ In r(>l|t|H llvlnw the UMIIND FRAME in the control stack, the second
nrguincnt is (V/\li-it. in \.1lue |\ i_;-|\or:-d. and the nnn-local return is completed. The second
.1rgnmr~ni i\ i~\.i|n.~iu--l in the (‘lI\'lIﬁIlIIlI‘lIY vh.-it was prcxcnx when the call to UNVIND was made. This
facility i\ nu-lnl for rl:-nning up ilntn haacx that are in inconsistent stalcs and fur closing
Ic|np0r:\r)' Cll/\Hl.‘Fls that |na)' he Ii-fl nrtnlnd. FLOAD sets up an UNHIND lo close its CHANNEL if the
user attc~n||\|\ ltl FRRFI \\|I|lﬁlll riIll\|IlHg the TLOAD. Exatnpluz
(DEFIIH: CL!/\H /\Cl ("/\lJX" (C <OPkH "READ' ‘A F1LE">))
"UCCL ((C) (OR CHAN!-‘EL FALSE) ...)
<COIlD (.C
<UN\v'INl) <PROG ()  (CLOSE .C>>
(CLOSE .C))))>
16.7. _CItv||tg'1Il-(L (“G8
'r_\'pin!; rnnirnl-(2 ("(1, <ASCll 7)) at MDL causes il to act just as if an error had occurred in
whatc-\'cr u-.1~ Fllf|!‘ll|h\’ ht-in; rlnnc. You can tht-n c.\:nninc the values of variables as above.
continuv h_\' ;ip|>l_\ in; FRREI tn Ont: Ilrglllllflll (which is ignored). RETRY a FRAME lower on the control
stack. or (huh even) thing by applying ERRCI to no argunlcnls.
16.5 - l6.7 Errors. Frames. etc.
 
1"



T
The MDL l‘rngr:unn\ing Language I5!
16.87 C0l|Il'Iv|-S §"S_\
Typing rnn|rnl»§ ("S, (ASCII l9>)'at MDL canscs it to stop what is happening and return to the
FRAME .LERR\ !—INIERRUP‘lS. returning th: ATOM T. (In the Tenex and Tops-20 vrrsions. “O also
has the s.-uuc effect.)
16.9. OVCRFLOLI
<O\Jl-RI-I OH /.=Isr-0!—any>
There i\ mic crrru that can be disabirtlz numeric overflow and underflow caused by the arithmetic
SUBR\ (+. —_ ". I) The SUDR OVERFLOV takes one argument: if it is of TYPE FALSE,
under/m~rrl‘Im\ uunrs :\r(' disnhicd: nlherwisc they are enabled. The initial state is enabled.
OVERFLOW tL'lI1l'H\ I nr #FI\LSE (), reflecting the previous state. Calling it with no argument
rcturus the vmrcut stale.
l6.8 - lG.9 Errors. Frames. etc.
M



Y
152 The MDL Prvgramming Language
Chapter 17. Macro—operations
LL R§_'\I_1.P\1-3\'L<r§
l7.|.l. Z and Z34
The lﬂL(‘lI\ 7. nlltl '/.'/. are iuterprt-led by READ in such a way as to give a "macro" capability to MDL
siuli|.1r|nl'l./l'\.
\\'het|e\'cr RF./\lI l‘l\(‘f\llll|l‘l'$ :1 single Z -— anywltcre. at any depth of recursion -- it iI11ItIl‘di;ll€lX.
without lnnkiug at the test of the input. evaluates the object following the Z. The result of that
cv:ilu.-ttimi is ltwrtl liy READ in place of the nbjcct following the Z. That is. X moans "don't really
RF/A0 |hi'~_ nw lV/\l nf ll iuslt-:|d.' Z is nftcn turd in files in front Of calls to ASCII, BITS (which
sec). eta. :tlt|mu_q|| when the FUNCTION is compiled the compiler will do the evaluation if the
argunn-nts arc cnttstnttl. Also wen is X.lNCll/\H, read as the CHANNEL in use during LOAD or FLOAD;
fnr cxznnplc. <PUl 7.7 INCHAN 18 B) causes succeeding FIXcs to be read as octal.
\Vl|et\c\‘er RF/\[\ t-urnttntcrs 741, it likcwiae imlnt-diately evaluates the object following the XX.
llmvcvcr. ll rmnplctcly tgxmrcs the result of that evaluation. Side effects of that evaluation remain.
of enursc.
Example:
<Dl'TlHE SLTUP () (SET A O>>$
SEHIP
(DEFINE NXT () (SET A <+ .I\ l))>S
NXT
[’/.X<SC'l'UP> 7L<HXl> Z<NXT) (XX(SETUP)) X<NXT>]$
[1 2 () 1]
I7 - l7.|.l Macro-operations



Y
“
The MDL l‘iﬁ_t;r:tiniumg Language l53
17.1.2. t_Iut<
<t tux (‘\;).'.<rt_', -mmi; OIJIIEI)
creatm iin iihjvit i-I TYPE Lltlk, l'Rtt-HYPE ATOM. A LINK looks vaguely like an ATOM; it has a
PH/till’ ttlw -hi»-_-; .1|i;iimi~tit). icsitlcs m an OBLISY (the calls! argument) and has a "value" (the exp
rtiguntt-nil. A l il.L has the str.1tt5;z-prn|>city that. wlicucrer it is encountered by READ (that is. its
Ptllttlt i~ ii-.ii|. Just lil 1- nu A10.‘-1, possibly with OIILIST trailers). READ $\lbS|llUlC$ the LINK's "value"
fiir l|tt' l lt-‘R lll\lllL'\il-ll\‘i)‘. The effect of REf\Ding a LlHK's PNl\t1Eis exactly the saute as the effect of
rvﬂdini; its "\'.\lttr*“.
The 0./~!:'.' .lIt_ltllIl'l|l is tiptinttnl. <l .0llLlST) by defattit. LINK returns its first argument. The
LINK is \ll'<llt'(| \-i.i lfi'§t,Rl, -in an error results if there is already an ATOM or LINK in ob/is! with the
sntnt‘ I'll/‘ilil .
The pri|u.iiy It-ts i-I’ l lllk\ l\ in iutr-r:\cti\-e wort. with MDL: expressions which are connnouly used.
but .1iitm_\'iui;ly tnui; tn l)‘|H‘. ran be "linked" to l‘rlI\MEs which are shorter. The standard example is
the fnllo“ i |l1_':
<l,Ilik ‘<ERRET> ""h" <ROO1'>)
which lml.- the A102-1 iif t'rt/wt “C in the ROOT OBLIST to the expression <ERREY>.
l7.|.3. Pimgt -llll-lil'i turd i\l.\rm-rlmiacters
During RH»!-m_g frmn nii input Clti’it.'t:l| nr i‘r\RS[ittg a SlRlIlG, any character can be made to have
.1 ~pi-i~i.il mi-nmiiq .-\ ch.\i.1cter can came an arbitrary routine to be invoked. which can then return
any iiuiuhi-i Ill [‘il‘l|l(‘lll$ to Lie put into the object being built by READ, PARSE. or LPARSE.
Tr:itisl.i|i¢in nf 1il.Ilil('l('l'S ii. nlsn pﬂssiltle. This facility was designed for those persons who want to
use .\lDl Rt./tit m iln l.1l§(' prtrls of their input but have to modify its actions for some areas: for
example. mu niiglit tiant tn treat left and right parentheses as tokens. rather than as deliiuiters
indiratmt; .1tlST.
l7.l.3.l. Rl'_I'\ll ('l'|n:tll)')
/\ssrvri:tt('tl with ttfftlt l'~ rttt ATOH. READ-T»'t[lLE!—_ wlinse lncal value. if any. must be a VECTOR of
(’|(‘lll(‘Ill\_ rvllf‘ rﬁl i-;iih l‘|l.'Il'i‘Ifl(‘l' up tn ntnl including all characters to he treated specially. Each
l‘l('lIll‘ll| illtilt-'li("~. if |I"l 0. the nctimi to he lﬂi\(‘l] upoii READ3 encounter with that character. A
similar VFCTOR. the ii-inil value nf P,'\FtSE*Tf\lJll:'-. if any. is used to find the action to take for
characters ('lllf'I\llIil‘l¢‘ti \\iIl‘ll PARSC or Lt"l\RS[ is applied to a STRING.
These lﬂil|('\ eaii lint 1- up tn ‘Z36 ('i\‘lll€lll$, one fnr each ASCII ch:tr.1cter and one fnr each possible
¢\Ci-‘illlﬂill'Ill'lI(Iill|-".~\$(:iI-('llIllJlClUl' pair. in MDL. the exclatiiaticui-point is used as a tuethod of
l7.l.2 - l7.l.3.l Macro-operations



Y
l5-I The MDL Progratnnting Language
r-xpntntint; ttt<- ,\'s(2tt rhxttat tr‘! set. and an cxclatnation-pointlcltaractcr pair is treated as one logical
ch:tr:tvtrr uhrn nnt rr-:n||ttt__' .1 STRING.
The (‘ltltttttl ftttltwtttttttlitttj tn .1 cltaractcr is (NIH Iable <¢ 1 <ASCII rhar))>. The element
cnrrt-spmitlint; tn :tt| rsrt.1m.1tintt-pnittt/ASCIIl-character pair is <NTH Iable <+ I29 (ASCII ch-v>>>.
The t.thlt-t.1n ht- shnttt-t than ‘I56 rlrtncttts. in which case it is treated as if it were ‘Z56 long with O
elcnn-nt-. lit-_\-mitt it» .\\'ttt.1l trngth.
An elctnrttt of thr l-|ll|[‘\ n|t|\t satisfy nnc of thr following DECL Patterns:
'0 l||||l('J\|l'\ th.tt tttt special action is to lit-t.1l.en when this character is encountered.
(‘.ttr-ttAt It ti itttlit .1lt‘\ that thr t-ttrntttttr/ctl cltatactor is to he translated into the given CIIARACTER
\\'livttt~\'rt it .t|\itt'.\I’\ l‘\(‘t‘|)l tvltrn :ts an nbjcct of TYPE CIIARRCTFR, or in a STRING. or
l|I|I|Il‘lll.t|(']'v' ltillnntttg .1 \.
f l>f Ill(||t.1lt'\ llt.\l the rltztrattrr is tn he git-r-n tht: satnc trcattncnt as thc character with the
.-\§(Ill \.thtt- 1-f the t t?<. This .1t|r>\v'~ you to cause other characters to be trcatud in the same
nay .1~ /\-Z ft-t r\.1tttp|t' The s.ttnt' t-\t*c'ptintts apply as for a CHARACTER.
<1 TSI I l>Z> tttitimtr-s t|tt~ \.1l|t(‘ thing. rxccpt that the charactcr dncs not by itself cause a break.
Tltvtt-ftvtr-_ ti’ it mturs wltett tcatlittg an f\iOM nr nuntber. it will be treated as part of that ATOM
or tttttttltct.
i\t't‘l it nsttt ttn tint" ;tt;;\t|ttt"|tll ttttltratrs that tht- rharartcr is to be a break character. \Vlir:ttcvcr
it ts l'l\(ItlltlLI‘tI't|_ thv t|'.1tltll':1 mt’ tht- rtittt-nt nlijrct is fitiisltctl. and tht: corresponding element
nl lltu l-I|lll' |~ /|Z‘i‘l Yt-it tn tho .\S(lll Ctt/‘RACER. tlf READ is called during the application. the
otttl-nt~litt~ st--t HI XIII‘ rt|t'\ttt.‘[t tctnpmatily crnttains a special Lind of ACTIVATION (TYPE
Rt /ttt/t) <4-i that |"|lI|-T\r>[Il(‘ can ltc sigttallcd p|'ﬁpCl'l)' tn the original RKAD. lsn'I that
\\-ntttlvtlttlit 'l hr \:tltn- tt~tntnt~<l ts talon tn be \vlt:tt was rratl. unless an Object of TYPE SPLICE
is ll'l\llIlll| lt \'I lltr t'lr‘tnt‘ttt\ r-f thi~ ub_;t~\'t. tshich is of PRIHTYPE LIST. are spliced in at the
pr-int \\|l('ll' .\‘tl1l i\ tr.1ilt|t_\; /\n ctnpty SPLICE allntvs nne tn return nothing. lf a structured
(\ll_lt'\’| l'~ inn tt<-in; l-nilt. rttttl .1 S!'t lCl' is rt-tnrnt-tl. clcntcnts aftrr the first will be ignored. A
SPL TH tlntttt-‘ timltng t\ \ttntl;tr trt :\ SIG!‘-EHT during evaluating. except that. in some sense. 2
5|‘! 1(t s.t\ ~ "1-\p.mtl |ttt"', \»lit~tt~.1stltc strttctttrc containing a SEGMENT says "l will expand you‘.
<| ISI r\t't't ti ftlill > lIllli(."ll('\ the .'~.1l|\9 thing. (‘.\r(‘pl that the character does not by itself cause
a Int-.tl. 'l'In-ttt--it-. if l| nccttts \\'|I(‘ll reading an ATOM or nuntber. it will be treated as part of
that ATOM ttr nntnltcr
READ t.tl:-~ .ttt nit-litiv-n.-it nptinnat :tr-__'ntnent. \\‘|llC|l is what to use instead of the lncal value of the
ATOM RLfttt—Tf\l)l Ii as the \1E_CTOtt nl rt-:-d-tttacru characters. ll this argument is supplied. READ-TABLE
is rclmnntl tn it \\'ll||lll thr call tn READ. READ takes front zero to four arguments. The fullest call to
READ is tltu-:
t7.t.3.t Macromperations



7
The M UL I’rrw_q|.nu|||i||g L:u\gu:\g¢- I55
(Hi/\|I (h.-H.-‘M rOf~!O:1hr1z‘ Icok—up read-lab/e:ve<I0r>
The mhm .1|\;|||nv||x~. an-v cxplnincd in >cclions ll.l.l.l. H6. and 15.7.1.
ERROR and LISH N |ul|i||d RI /\l‘|<‘l/'\iiLF_ I0 ||IF CV/\L Of READ-TABLE, if any. else UHASSIGN ii.
l7.l.3.‘.?. I-‘.\:\|upl¢~\
Eaamplva nf <'.1(h nf llw lliffeleunl kinds of c-nurics in macro tables:
(SC? RYAN-1f\ﬂlE <I\/ECTOR Z56 0)>5
I---1
(PUT .RL/\(I—Tl\[lL[ <¢ 1 <I\$CII '\u>> !\/\>
;"C|l/\RAC'H'_R: t.rnn:.luLe a to A35
f--- I
“hai-
/\hC
<l‘l|1 .|{I:'\U-1f\[H[ <4» 1 (ASCII !\'/.>> (ASCII !\I\)>
;"I'1X: make '/. JUSL a normal ASCII charactcr."$
l »--J
A’/-I3('$
/‘\\'/.l5C
(PUT .RI_'AU—TAT!lC <+ I </\SCII !\,>) (<ASCII !\.)))
;"<lIS1 I'IX>: rfiilke comma no longer 0 break
character, but still snccia'l H’ at a break."$
L---1
/\.[‘.E-
/\\.l§
;"'H\nL was an l\IOI1w|Lh PHAHE [LB ."
‘.85
.il
;"T|\-11. was, Lhn FORM <GVf\L ll) ."
<F‘UT ,R[/\U-I/\iXL[ <¢ I <:'\5CII !\:))
-TIIHCTIOH ((X) (LIST COLON (REf\D>))>
;"/'\I'l‘l ICMXLE: nnkc .1 new Lhmg iwke ( < and [ .“$
I-»-1
B:/\':~
ll
(EUIOM /\)
:::IOOI=
(COZOH ((OlOH (COiQH FOO)))
l7.I.3.I - 17.1.3.2 Macro-operations
;



T
I56 The MDL Programming Language
<PlI‘T _Rl’/'\l"kTf\l‘ll_[ <+ l (ASCII !\:>)
‘(-'| Ill-‘CTION ((X) (LIST COLON <R[AD>)))>
;"<lTSl /\PPLTCI\8LE>: like above. but not a break
nnw."S
i -- -l
lI:/'\5-
l!:l\
;"Tl1<|l was -in IKTOH."
:::fOOS.
(CO1 OH (f U1 OH (Col OH fOO)))
l7.l.3.fl. PARS! null ll‘i\l(5Effn|.1Ilyl
< I‘/'\iZ.\| -.‘r / ' -'-if/\ //1-‘Vi HP Dnr_*.o-l.=[>-'0,-vpdor /0ak~a/1cad:c/1.-w/a(Ier>
"'I‘Sl' I"/\f‘§[ rm Hlv from zcrn In fire arguinenls. If PARSE is given no
is ihc l'ullr'~I (Jill 1-1 IIl\_ _. \. . .. _
lll(||l\ in |l'l||||x\ Xlm fins! nhjvct parscd from the Inca] value of l||C STRING PARSE-STRING and
-1r1_'|| * . ‘
l'~ .',‘i‘\l §lI"ll(; IO iill‘ STRING lmrinq llmsr: CllARf\CT[Rs which were parsed RESTtd
:ul(li1ir-n.-xll\ Sl ' ., -_ .1 _
if ll’ !“\!"<.l |~ l\l'|I 1 <-lllTllGIr-p1|w The ATOH PARSE-STRING is rebound to The STRING wnlhm
n _ 1 \. l_ . . . . .
Il|:\I v.1ll H lh(‘ ,-. - .'.1.':'v .1|gu|||('ul l\ given To PARSE, PARSE-TABLE is IQUOIIIHJ lo it within lhal
r.-ill lﬂ T‘/~H.‘;l . I-'|n.|l1\, i‘/\RSl can mks :| loan-alwnd CHARACTER, \4|'iIiCiI is lrcatcd as if it were
lngirnll/\ \'\lll :\|vn.1:|-:1 10 Hm frnm nl‘ |l|e slung bring parsed. Other arguincnls are dcscribcd in
svclinns 715 (L? and l3 7.2
LP/\F-TSF is r~\.1|:l\ ill!‘ T‘/\RST_ oxcrpi than ir rrivs in parse The whole STRING, returning a LIST of
the obj:-ch \~u~;uc\I.
I72. EV/'\l .\l.'!\l1)\
A l'Vf\l nmrrrv \|rI\‘ui('s who rm|\'cni(‘n(C nf a FUNCTION without "IC overhead of calling. SPECIALS.
ll [
etc. Ill Hm lf'\IIl|Y|il’Ii \4‘l'~lﬁ|I. ,\ spr-ci:zl-purpmc funcliou than is called often by FUNCTIONs that will
be c0m|)ilv:*d is :1 gnml c;unlii|:uo fnr an EV/<L macro.
|T.2.l Ill I ll/\( and l)’.l‘f\llll
DEFMAC ("TIM Till‘ Ina: m"> is \\‘llliN‘li(‘.1il)'L’\i\Clly the same as DEFINE. However. instead of crealing 3
FUNCTION, l-I I rmr til‘-llf'§ .1 HACRO. A MACRO is of PRIHTYPE LIST and in fact has a FUNCTION (or
nlher /\l'l"l TC/\lH I |YT'l>l.1sils singlv (‘lrl\If‘|Il.
A MACRO ran iru-IT Irv .‘l|lpli(‘(.l T0 .-|r§;u|ncuts. A MACRO is applied in a funny way. however: il ls
l7.l.3.2 - l7.2.l Macro-operations
 



T
Th!’ M lll l’|n;;|.1u||ni||g lnllgxlagr 157
! LVAlml I\\ll'(‘. Tm hm rv/\| CRIISCS ll-<~ HACRO's alum-m I0 be applied (0 the r1ACRO‘s argulncnls.
’ \\'l|.1m\~¢-r llmx :|pl»l»¢;-||<n| |r‘l|u|1\ (uumlly numlu-r FORM) is also EVALcd. The result of ll|E second
E\Jr'\Lu:|l||>u |~ ll|z- |l'\llll nf .-applying who MACRO. EXPAND is u\ed to pcrform the ﬁrs! EVAL without
l
l||(‘ scrﬂllll
Tn :\\'Illl. < n|l||>lu;lm-||\. llm fin: lW\l thy FXPAHD, lo crcale llle ohjcct lo be EVALcd lhc second time
mnumll is ll--uv in .1 Ill]?-|('\'l"| Ouvirunlnelul. The rcsull of this policy is lhal lwo syntactically
idK'||lil1\| nn-n.1||<-n= c-l’ .w HACRO .1l\» ays lcxurn the same c.\p.-union lo be EVl\Led in the second slcp.
The fin: l\/Al l;r~m-|;nr\ |\\'n \-\'n-.1 rRAl~lLs: our for a call In EXPAND. and one far a call to EVAL the
r1/RCFZO .1|wpl|vnlim| m :\ lﬂ|\»|(‘\'(‘| r~u\'lrn||||\cnI.
l-Ixamplr:
(llll-ll/\C ll;C (/\lH "OPll0N|'\l“ (N 1))
"l'l_Cl_ ((Vf\l,UE) FORM (IHH) ATOM (H) (OR FIX FLOAT))
(FORM SET .i\TM (FORM v (FORM LVAL .l\TH> .N>>>$
lllf
,ll1'l'3
*ll»'\lllCl (-FUNCTION ((/UH "QPTIONl\L" (N 1)) ...))
<Sfl X l>5.
1
(INC X>5~
2
.X3-
7
(EXP/\lill '(lHC X>>$
(SET X <+ .X l>>
P4.-rha|>\ llm i||lI‘||lin|| i< rlvmm if PARSL and 14 are used:
<[\[f!l/\C 111C (All-l "Ol"TIOHf\L" (H 1))
*l|lCL (...)
-1|’/\|l$l "<Sll '/i.l\lH (+ '/-./UN 'A.N>)"))
Hf\CROs |'v.1|l\’ (‘\|¢ll:il ll|(‘i| :ul\'.1|\l.n;c\» \\ll(‘ll llmy are compiled. The compiler will simply cause the
frrsl IV/'\ln.1-nnn m mun win FXPf\l-‘I'll and c0lllpi|C lllc rcsull. The single element of a compiled
F‘-/\CRO ls nu I-!§.llklll1\| RI‘>\ll‘.ll-LHIRY.
1112.2. Examplv
Sllppﬂs1.‘)ﬂn \\.'|l|l ln rl|.1n_qc llw fnllnuin; simple FUNCTION X0 a MACRO:
<l||llY!l I-ﬁLlP.llT (X) "DFCL ((X) FIX) (+ ‘X .X>>
l7.‘Z.l - l7.2.2 Macr0~oper:Hions
g



‘S8 The MDL Programming Language
You may hr l(‘tll|Ht~tl tn wt-ttt':
<t\t't'.~t/\c t»ount£ (X) ~0EcL ((x) FIX) (FORM + _x .x>>
This H/\t‘.|(O \\ ml ~. hut only whrn the mgtttnent dm:-s not use tetnporzry bindings. Consider
<t|tt INK lRll"l[ (Y) <+ .Y <DOU[$L[ .Y)>>
If thi> ttmt 1101: |~ .t|t|ti|l'(l_ tho lr\|)-lt'\'t'| llllldlllg of Y is used. not the binding just crcatcd by the
;\pl]|i\‘ﬂ[iI!]l ('(|||||||[.lItﬁ|| of |hi> t-LIHCIION wnuld probably fail. because the compiler probably
wmtltl h.\\'t~ un fﬁ|1<|t'\'('l lnittulittg for Y. \‘i'rlI. how about
flllili/ui DOUBLE ('X) (l-Oi{f‘| 0 .X .X)> ;"ThO DLCL I165 L0 Q0.‘
Now whit ix Ill(\I(' tilv tl|t' ntiqitmt H-'.‘JCti0rt, lwcausc no lnngcr is the argument evaluated and the
rosult r\ ;\lu.1t<-tl n;_~.1|||, ,\||t| IRIPI E works. lint now cottaidcr
<DFf ll-'1' I!;lL~/till)-DOllBLE (Y) (DOUBLE (SET Y <0 1 .Y)>>>
You tni|_;ht ||tt|>ctl|.1l
(INC-Al;D—llOUClF I) -> <|'IOLlULE (SET Y <-v X l>>)
-> <(lOlI[ll_C 2)
—> <4 2 2)
_> .1
But. w||t'|| ttOut;|t |\ .1;-plum! tn that l'0t<H, thc argutncut is OUOTEd. so:
(INC-/Hill-iIOl,lillE l> —> <l!OUBLF (SET Y (v 1 .Y>>)
-> (PORN ~ (SET Y <+ l .Y>> (SET Y <1 .Y)>)
~> (~ Z 3)
-> 5
Sn. sittt(' thv t‘\.tltt.t1t~-It hf O0Ut;l_C‘§ argttntcttt has a side effect. you should ensure that the
t>\'alt|.1tinu l\ tlnttr' :~\.1rt|y ntlfl‘. my hy FORM;
(III l'Ht'~t.' YIOUDLE ('»‘\HY)
<fORH FROG ((X .»‘\HY)) IDECL ((X) FIX) '(<- .X .X>)>
As a bmttu. tho [ti Ll r.-tu nucc more Ln’ usttl.
This c\.\tu|>lr~ |~ intrmlril tn ~hmv that writing good MI\CROs is a little trickier than writing good
FUNCI I02-t~_ Hut tlmt-|'fm1 may hv wr1tt|t\\'hilril't|t£' compiled program must be speedy.
17.2.2 Macro-operations
I
|
I
I
 
lllllllll
I -  
I lllll
 
I
Ill



Tlnc Ml’)! l'rr-;|.1m|m||_z; l..1ng||agc I59
Chapter 18. IVI:\chine Words and Bits
The |\ll)l l‘.1<i||x_-.' fm sh-.1l|n__Q \\'ill| ||ui|1lm|n1~lml marhme words and hils involves two data TYPE5:
WORD and lll1S. A \-.‘OR[I ix \llll||l_\' an |l|lll|lL'l'|)(L'l(‘d lnarhiue word. while I BITS is 2 "pointer" to .1
$1‘! 0| Inn \\lli\l|l .1 WORD. ()pc|.\|xug on NORDs is usually done only when compilcd programs are
nus:-d(\|\.1|vn-1 I'M
|s.|._y1om»~.
/\ WORD in .\Hvl, 1- ac Pl)!’-I0 maclunc \vOr|J of 36 bits. A WORD always PRINT; in "l formal". and its
contour-. .nr .\l\\.y\ ~ |‘lli||l(‘\| ||| ncml Hmncc [H'L‘C(‘ll(‘d and follo\\'(~d by "). Examples:
A/WORK! U ;"nll Os"S
"\-’Ol!lI "00DOOD00O000'
-'1-‘mill '-N300‘ ;“nnc b\t l"S
"WORD ‘OOOO00ODZOU0'
-'\\'0l\'i1 "_-.7.’»?'>?E'>?f>7‘3Z" ;"evcry other DH. l"S
"L/Ollll "‘:v._"f\Z'w2';v?f|?5?'
\-IORD is us nun :':::r:r‘rP(; n is aim |ho PRIHTYPE of FIX. FLOAT, CHARACTER, and any olher TYPE
\vl|irl|r.1\| fr! II\ (|.1|:\ nun ﬂnr‘ |u,1rl|i|1!‘ wnxd.
-\ \~IOl'(I|<'.1nnn: hr :|l| .1:g||nu~n: In +, -, ﬁr imlq-cd any SUBRs except for CHTYPE, GETBITS, PUTBITS
and \(~\'r|,\l l-||~|n.\|npnl.1Ii|u; fumlimns. .1ll :0 hr U('SC!|l)('d bv.-low. Thus an)‘ arillnuelic bit
IH."|ll|p||l.11|1~|| nuns: ln- rlunt‘ hy cll1‘|’F'I Eng .1 l--‘ORD lo FIX. doing rhe arithmetic. and Ihcn CHTYPEing
bark in uni-'.-. lhmm-m, hi: |n.'H||p||l.1i|ﬁn can be done \\-ilhom CHTYP£ing the rhing to be played
wixh In .\ ‘.-.'o;::|, ~~ l1-ug .|~ n is ~|' l‘Rl|"|TYPE WORD; me result of me mauipulariou will be of the
snmc TYPI .\~llu-1-|i»;i||:|lnb_|rclﬁr can be CHTYPEU to it‘
I8 - l8.l Machine “lords and Bits
L



IGU
13.1!‘ B118
-\|| nbj<'c' r-1 Y'|'f‘F I‘-ITF. ix 0" PR1!-11'1"" \-I
511$ |'~ ;n<-.|~(1\ !h.u <-1 .1 1'1)1'-10 "L~_vn~ poimc
. >= ORB, .1miPRIHTs Jun hLe a WORD. The inlernal form of a
r'. which is. in fact. jun what a BIYS is.
The MDL Programming Languagc
For ]7llli\!I\v-\ --f r-\;vl.\iuiu-_' \»-ha: ;\ :L‘IS . ‘
(Tl\i\ as um Hm "~r.uul.\|<l" mdc-ring: (hr "sl:u|d:|rd" one goes from left lo right.)
&‘v“41 15 71
0
1 :§,as<-un\elIm| rhe ails in a WORD are numbered from right
I0 @_1. wnh xlw ||;|nn|--~| In! uunnbcr-:v.l 0 and lhc Icfzmusi numbered 35. as in
»\ 811$ ls nmu rm|\'r~nir-nllv u¢~.1n-1| \'i.'\ rho SUHR BITS:
/.8115 ,\ ~r:.'.': .w. ,,,;uI~eﬂ',-:=-_,m>
r('I||rn\ .1 i'.{|.\ \\||u|\ "|>ru|1:\ In"
.1 wv of hils v.:dI/v wide. wirh riglnmosl bit rlghf-edge. Both
.:r1_;um1-ul~ u|u\I |.1- 1-I‘ XYi'[ F IX, and the second is oplinnal. 0 by defaullv
Ex:\mph~-: rlm ||uli<~a||-1| .1 1 \l|(iH|0|| n
indic:\u'xl wc of luils in .1 LIOKHI:
(BITS 7>
(B115 <1 IF!)
<HXlS .ln)
18.3. §£1m1>
35
.35
33:
 76...O
f BITS rclnrlls an object of TYPE BITS which poinls lo the
Z2 2l20 X91817  O
__._i
< GE TRX XS lf('7"ll']V'l!'I1|' . p2—'.~DI(1 D115)
\vI|er(' "-'"- i\ :\||nh}v(~1nfI’RI[1IYL’} U "
_ Qhﬁ, returns a [£1 object wlmse TYPE is WORD. This nbjcc! is
rnnusxrm-In! in xlw l’--lluuiuq \».1_\': Xhv st‘! of bits iurm.-1-pointed to by bu‘: is copied into the new
nhjcct. ll1§||!-A|l_|||\X(‘\l. rlml is. linrd up .1¢;.1ins( lhc right cud (Lvil nnlubcr 0) of the new nbj€c(. All
.hr-<:~ lnls r-r vhv um-\\ 1-h‘|z~n \\lurl| .ue um (npmd arc svr to zero. In olhcr words, GE TBITS takcs bits
frmu an .uh\u.u_\' 121.101‘ nu '-n~ and 1 I
to GETBITS is um .\l'fcv;l1-d.
Examplr-s:
18.2 - I8 3 Machine Words and Bil:
lmsmc-1n an the righl mud of 2 new object. The from argument
F
i



‘T’
The MDL Prnqnuuuning Language l6l
<GETl$llS -WORD "7777/'7777777" (BITS 3>>$
H-JOFU "O00O000OO007"
<f2l1llITS '0l?3/P3670123" (BITS G l8>>$
-ll-'Oilﬁ "ODO0O(JO0O045'
I8.-I. Pl] l Ill I 5
< Plll ll I TS /t_7.'[‘!‘I!IlIv\ re- ward Ln!-.' /ram.-pnmfype-wo.'d>
whcrc Iv :\n|l r-.->- air ml’ |'lllrl‘lYf'F HORO. nrlnrns a gm; nf la. nmdifivd as follows: thr set of bits
in to \\l|i\l\ .'v|(" |\l'iI||l‘l‘ no l|_y l>,.'~; are ruplnccd by the appropriate number of rightmost bits copied
from nvm lupllﬁllfll. 0 hy ulrfmnlll. ln olhvr words: PUTBITS lakes bits from the right end of from
and uuff-. ll|r‘l|| inln nu :\rhi|r:|ry pmixinn in a rnpy of Io. None of the argunlcnls Io PUTBITS is
affcclml.
Exalnplrsz
‘ <1-n|ul|.<. ~un|zn -7/777777777‘/-\ <8lIS 6 3>>$
¢-wonn ~777777177oo7*
‘ <ruln11s <\~/ORD -oom77000111~ (BITS 5 15> mom: =123*>s
' ~wn»<n -no-'~1/c-Joo111~
<vuluns -uouu -/054321076541 (OHS 18>);
vuorw ~7o:.4szooooou-
l
I‘! 5 lli|\si\r' l5:-rvlr1|| O 11‘|1lIr1l|$
.‘-i-.__._.._ -___ l__' ___
1
Each of Ihr Sultln i\.'l;|l:, ()RR_ XORH, :u\(I FQVB 1-'I|\(‘S arguments of PRIHTYPE UORO and rclurns a
WORD \\lIi\|I is llw lnluiw llnnlc.-|n "and". mclusivc "or". exclnsxve "or". or "equivalence" (inver.-.e of
_ (‘xch|<»i\'r* "m"\, l\'\[H'\'ll\'(‘lY_ of its .1r_<|nncnls. Each HALO; any number of arguments. ll‘ no
:|rg|unr||l is qnrn, .1 \-IOIH) \\‘il|| all lain nlf (ORB and X0518) nr on (AHD8 and EOVB) is returned. If
i "lll_\‘ mm .-.;i---Mn is givrun. il is 11-mrucrl nnchaugr-rl bnl CHTYPEd lo a \-JORD. If more lhan Iwo
argumcm-. 4"" =5“.-n. lhv 1-pm.-um i~ ﬂp|)||('(l m Hm first two. lhen applied to (ha! result and the
I||lr(1.Cl\‘- llv '~||lC um in rnnl'n~.c AND and OR wilh ANDB and ORB.
l8.3 - 18.5 Machine Words and Bits



'1
I62 The MDL Programming Language
[ 13.5‘ mm iu~ ﬂmfyL\.1; Qlﬁl-1'i""_‘~
5
<1 SH '1 ._-- .~p.-/ml;-we-\v0rd ﬂmOu.'M':fr.\'>
r
a r('||lr||\ .1 3:3"-L \-JO!-Eh c'IuI.1il|i|1_q rhr bin in from, shiﬂcd lhc number of bits specified by a/noun! (mod
‘ qr , . - -
“J6, <.1_\< 1|“ h.l|d\\.\|r‘) /rm lms .1rz-brnu_qlu in at Ihc end being vacalcdz bits slniflcd out at the
nllmr end .111‘ hm. ll’ .1»,»o1/r.-.' i_~ posnive. shiﬂinq is KO the left: if amour-II is negative, shifting is lo
‘ .
rho right. l'.\.1n|ph~~:
‘IISH H h>5v
1 U!-IOUD "OOOO0OOOlOO0"
<LS|| H ~(->3
"\JOI(f1 'ﬁUDOOO0D0OOO"
< ROI .-.-.~ ;;~.-'/.,t_\;>1~-n ard .>.~.::um‘.-.':x>
r('I|||||s ‘I |y~\_\- mum 1 4I||I.'\||li|l§; ihr hils in /mm, romxcd rhc numb:-r of bils $p¢cifiCd by an-10unf(|n0d
256. \.-|_y\ Hm l|:|||l\\‘||¢‘). Rr-1.-uinn is :1 ryclic hinvise shifx where bits sluifwd cu: at one cud are put
back nu nu I||l' unhw. H .=/~mm/ n |m>|n\'e. rolalinu is lo lhc lrflz if amount is negative. rola(io|| is to
l|I(‘ right. I-‘\-uuplr-<1
<l101 8 0)}
"WORD "OD0OOOOOlODO"
(R01 B —6>S
INOIZFI '1000O0O0OODO'
18.6 Machine Words and Bits
T
V
\
L
I
, I
i --m
?
?
F
rvlrr
?
I??
F
?
???
????



Q The MDL Prngrattttnittg Language I68
Chapter 19. Compiled Programs
t9.t. RSUBR_(tlte_Tl{'F_)_
R5Ul’§Rs ("rolm~.1t.1hlt~ mltrotttittes") are ntachine-language programs written to run in the MDL
envirnntut-nt. 'l"ltt'y are ttt-n.1Il)' produced by the MDL assembler (often from output produced by the
compiler) :\|tImtt_qh this is not ttccessnry. All R$UBR.s have two components: the "reference vector‘
and the "cnrtc vi-rtnr". ltt sotnc cases the code vector is in pure storage. There is also 1 set of
'fixups" nsmciatrtl with ct-t-ry RSUBR. although it may not be available itt the running MDL.
l9.2. Tltt:_R£[e§t:tlrt' Vrclnr
An RSUBR is ba~icall)' a VECTOR lh:tt has been CHTYPEd to TYPE RSUBR via the SUBR RSUBR (see
below). Tl-i- rx-\'lIC'lOR is the rcfcrettcc vector. The first three eletnents of the reference vector have
predefined tnmutittgs:
The first clctncnt is of TYPE CODE or PCODE and is the impure or pure code vector respectively.
The nccoutl cletncttt is an ATOH attd specifics the natne of the RSUBR.
The thirtl (‘|(‘ltl('lll is of TYPE DECL and declares the type/structure of the RSUBR‘s arguments and
result.
The rest nf the rlemcttts of the rcfcrcttct: vector are objects in garbage-collected storage that the
RSUBR needs In rofr-rt-ttee and any intpnre slots that the RSUBR needs to use.
When the RSUDR is rttttnittg. one of the PDP-10 accumulators (with symbolic natne R) is always
pointing tn the refrrcttee vector. to pcrntit rapid access to the various elements.
I9 - 19.2 Compiled Programs
L



16-: The MDL Programming language
I9.3. RSUBR Linking
R BR. nlt :m ' /\l't'| ICABLE object. all in a uniform manner. In general, a call to an F/SUBR is
SU Q c:m c _)
linked up at aswiulily/ennipile time so that the calling instruction (UUO) points directly at the code
' ilo iIlI(‘| rrtrr for the FISUBR ltowcver, the locations of most other APPLICABLEs are not
III I ‘ft .
known .1t 1ur~m|>l\-/rnmpilc time. Therefore. the calling UUO is set tip to point at a slot in the
li
reference vet-tnr fit)‘ milexmg off acciiniulator R). This slot initially contains the ATOH w ose
C/L\'/\L is the r:ith~il object. The calling inechanistii (UUO handler) causes control to be transferred
' ' ' d b
to the call:-it nl-_jrci and. depending mi the state of the RSUBR-link flag. the ATOM will he replace y
its C/l.\'Al. (If the call i\ of the 'qtticl;' variety. tlie called RSUBR Or RSUBR-ENTRY will be CllTYPEd
' f It RSUBR-link
to a QUICK-RSl_Il;R or QUICK-ENTRY, respectively. before replacement.) Regardless o I e
fl:ig's state. calls to l’UttCTt0tls are never permanently linked. A call to a iioii-Subroutine generates
an extra FR/\ttt', wtmse I'ttttCT is the dummy ATOH CALLER.
RSUBRs are liitki-it together for faster execution. but linking may not be desirable if the RSU8Rs are
b ' I l|l‘illl - '(‘l|. .'tltt| \‘:||ifvtt§ revisimis are being re-loaded. A linked call will forever after go to the
(‘ll  
same emle. trgnrillru of the current C/LVAL of the called ATOH. Thus. while testing RSUBRs. you
\V'llli ll'\_l“5.'lb|(‘ linking by calling the RSUBR-LINK SUBR with a FALSE argument. Calling it
lllﬂy . . .
with El iinii-FALSE argititietit enables linking thereafter. lt returns the previous state of the link flag.
either l or M’/kl SE (_) . Calling it with no argiinteitt returns the current state.
19.4. Pitre -‘\|Ilulll|)ll(C Code
Tlie first element of mi RSUBR is the code vector. of TYPE CODE or PCODE. TYPE CODE is of
PR t1TYt‘E UVECTOR. nml the UTYPE shmild he of PRIHTYPE WORD. The code vector is simply a block
I
of words that arc the ill'tll’ll¢ll\'IlIS wliicli coinprisc the RSUBR. Since the code vector is stored just
like :i siamtnril ttVt't2TOR, it will he moved armmd by the garbage collector. Tlicrefore. all RSUBR
code is iequtreit In he lm-niioii-mseiisitive. The compiler guarantees the location-insensitivity of its
out iit. The a-wmhli.~r helps to make the code location-inseiisitne by defining all labels as of sets
I)
ret:iti\'e in the ll(‘t_'illlltll§! of the code vector and causing instructions that refer to labels to index
' ' ' UUO
.1IllﬂIlt.'llt(‘.1l|)' oft‘ the l‘l)P-I0 accmmtlatnr syniholically named H. H, like R, is set up by the
liatidler. but it points to the cﬂde vector instead of the reference vector. The code vector of an
' ' ‘ ' b DDT
RSUBR can be frn/cit (ltsitig the FREEZE SUBR) to prevent ll from moving during debugging y
m the '>lI|)l‘I’i(1|' o|ir-rating-sy\tet\i process.
lf the first ll‘|L‘IlI('lll of .-in RSUBR is of TYPE PCODE (‘pure code"). the code vector of the RSUBR is pure
and slinrnlile. TYl‘£ PCODE is of PRIHTYPE WORD. The left lialf of the word specifies an offset into
an intcrnnl t.1hlr~ nl’ pure RSUﬂRs, and the right half specifies an offset itito the block of code where
this RSUHR starts. The PCODI: prints out as:
%(l‘CODE name:sln'ng olfseldix)
t9.3 - l9.4 Compiled Programs
T
I
1
b
u
I v—i
m
t
u
4,1. |.l
u
u



i
Th; M l)l. Prrtgmlittttittg Lattgttage I55
whert‘ -an-r ll-"llllt"\ the Putt)‘ in the usrrk pure-RSLIESR tahle. and oﬂsel is the offsvt. (Obviously.
pcQD( it .x|m thu ttztute of n SLIUR, which generates at pnrc code vector.) Pure RSUBRs may also move
3|-nut|tl_ hut trill)‘ l|_\‘ ht‘in_t; ilttltttlrtl tn .\lDL's page map at diffcrctn places. Once again H can be
nsctl r-\.-itt|_\' as l-rt:-tr In tln Iﬁrnltﬂll-tl|tlt‘|)(‘lltlt‘lll atltlrrss rvfcrcttcittg. Individual pure code vectors
(:;\t| he "nt|tn.1|vpt-1|" (ttt.\tlt‘tl as living Inn tn printnry storage but in their original pure-code disk
film-sl if 11,0 ~.|:n;t' lu stnrzlgc .\llm-mvtl for pure code is exhausted. An unlnapped RSUBR is mapped in
again \\'|1t||t‘\'(‘| lll‘ttl('\l All putt‘ R5tlBR\ are tnunapp:-d bcfnrc a SAVE file is written. so that the
cmle is nnt ilttplh-.1trtl nu ttixk. A purified RSUBR nntst use RGLOC ("rclative BLOC") instead of GLOC.
RGLOC prrut||cz~\ otijorts nf TYPE-. LOCR instczul of LOCD.
 ‘TYPE-C :ttttl lV1'lV-U
In nrdm tn llfllllllf‘ uscr Ill‘\JTYPFs rcasminbly. the intcltml TYPE codes for them have to be able to be
dil'l'0:'rnt Finn: unr Ml)l_ tun tn rtnntltrr. 'l'l|crrl’orc. rcfcrcttccs to the TYPE codcs must be in the
refer:-ncv rt-ctnt tztthcr than the cmle vector. To help handle this problem. two TYPEs exist. TYPE-C
("typo cutie“! :\|nl iYl‘[—H ("typv \\ord"l. both of PRIHTYPE WORD. They print as:
'/¢< lYl‘l —C I; pn pr:/.:I_\ pg.-alum)
‘/-< l Yl‘E -N l_\-pc pr/ml _t Lvcmto/.1)
The StIt'.R IV|‘l’—(‘. pvmlnccs an internal TYPE codc for the type. and TYPE-H produces a prototype
"1 YPE wont" tnppoin-Ii\ ll fm an nlijrrt nl' that YYPE. The prlmlype argutncnt is optional. included
only as .1 chvrl. :|;_;.1in\t th<- 0.‘-"tll to NEHTYPE- TYPE-H can also take 3 third argument, of PRIHTYPE
WORD. uhmc titght half is inc|udc1.l in the gmteratcd "TYPE word‘. ll‘ Iype is not a valid TYPE, a
NEHIYPI is .1ntn|n.\ti¢.1ll)' (tr-no.
To be <‘"lIl|)l\‘l('. :1 -i|nil.1r SUUR and TYPE should be mentioned ht-re.
<l‘RllllY|‘l -c 1,,-v->
prntlnccs an itltt'||t:Il "~tn|':|§;c allr\c.1tinn code" (appendix X) for the type. The value is of TYPE
PRIMIYPL-t‘., PR]!-:1Yf‘l’ \-IORD. ln :tl|n0st all cases thc SUBR TYPEPRIM gives just as much
mfmnmtinn. t‘\rt‘pI III the r:t\c of TEt‘lPLAT[.s: all TYP[s of TEMPLATE; have the same TYPEPRIH, but
they nll have dill’;-it-ttt PRlNlYPE-Cs.
19.6‘ R5t|mt ttht- Sln:Rl
<RSllllR [rcvfe /tame (195! lg! /cl . _ _]>
CHTYPt_s its :ugntm-nt tn an RSUBR. after checking it for legality. RSUBR is rarely called other than
l9.4 - l9.6 Compiled Programs



it
I66 The MDL Programming Language
in the MDX. Assembler (Lebling. I979). lt can be used if changes must be made to an RSUBR that are
prohibited by MDL3 built-in safety mechanisms. For example. if the GVAL of name is an RSUBR:
<sEt Ftxtt (CHIYPE ,name\ VECTOR>>$
[~-J
. . . (cliatigos to .FIXIT) . . .
(SETS name <RSUBR .FIXIT)>$
QRSUBR [. . .]
I9.7. RSURR-ENTRY
RSU8Rs can have nnilliplo entry points. An RSUBR-ENYRY can be applied to arguments exactly like
an RSUBR.
< RSUBR -l> N1 RY [rsu!>r—or-alom name:-vfom derl] 0/Isel:/Ix)
returns the VECYOR arguinr-nt CHTYPEd to an RSUBR-ENTRY into the rsubr at the specified ollsef. If
the RSUBR-CNYRY is In have a DECL (RSUBR style), it should come as shown.
<ENTRY—LOC r.=ubr~e:'nIry>
(“entry location") ri-turns the 0//se! into the RSUBR of this entry.
l98 R§UﬂR< in Files
There are thrz-v kinds of files that can contain RSUBRs_ identified by second names BINARY, NBIN
and FBIN. Tlicrr is nnlhing magic about these names. but they are used by conventinn.
A BINARY filo is .1 completely ASCII file containing complete impure RSUBIB in character
l'0pt'(‘S('lll.'\ll4'7II. l;'\'cn a cndc vcctﬂr appears as ICODE follewed by a UVECTOR of PRIHTYPE llORDs.
BINARY files arc gcnmally How In load. because of all the parsing that must be done.
An NUIN iilc t‘ﬁIIli|l|I\ :t nnxturo of ASCII characters and binary code. The start of a binary
portion is ugtmllctl tn READ by tlit‘ character control-C. so naive readers of an NBIN file on ITS may
incorrectly nsminc that it cnds bvfore any binary code appears. An NBIN File cannot be edited with
a test editor. An Rsut-tR is written in NBIN format By being PRINTed on a ‘PRINTS’ CHANNEL. The
RSU8R.s in NBIN files are not purified either.
I9.6 - |9.8 Compiled Programs



i
i
l
l
l
L
The MDL Progranitning Language I67
A" FBIH file is actually part of a triad of files. The FBIN file(s) itself is the impure part of a
collcctiﬂlt of |mr|fiul RSuBR-. lt is simply ASCll and can be edited at will. (Exception: in the ITS
and Tops-'10 \'('l\iI>t\\. the first object in the filo should not be retrieved or changed in any way. lest
; "grim rt-apor"|uo_gr.1tn for FBIH files think that the other files in the triad are obsolete and delete
the-in.) The |)ltIt' totlc itself rt"~iIJc"> (in the ITS and T0ps~2(l versions) in a special large file that
COlll;lill> all tmv--ntly-uwil ll\|I(‘ tutle. or (in the Tenevt version) in a file in a special disk directory
with first name tI|t' s:tt|t|:' as the rm/1:0 argunient to PCODE for the RSUBR. The pure-code file is page-
mappetl tlircctly into .\‘lDL storage in rend-only anode. lt can be umnapped when the pure storage
lnust he I'(‘(‘l.'\i|lll‘(|. and it can he mapped at a different storage address when pure storage must be
cotitpncterl. There is also a "fi.\np" file (see below) or portion of a file associated with the FBIN to
rnttnd out the ll'l.'\(|.
An initial MDI ran have pure RSUBRs in it that were "loaded" during the initialiaation procedure.
The files are not p.1ge-tttapped in until they are actually needed. The “loading” has other side
effects. such as the creation of OBLISTs (chapter 15). Exactly what is pre-loaded is outside the scope
of this document.
l9.9. Fixt|p_s
The pitrposu nf "fi\up~." is to correct references in the RSUBR to parts of the interpreter that change
from nut‘ rt-Ir.-tso nf MDL to the next. The reason the fixups contain a release number is so that
they can he t-ninplrtt-ly ignored when an RSUBR is loaded into the satne release of MDL as that from
which it was l:\\t written out.
There are litl(‘(' fnrins of fixups. corresponding to the three kinds of RSUBR files. ASCII RSUBRs.
found in BINARY files. have ASCII fixups. The fixups are contained in n LIST that has the
following format:
(MOL —re-'ease.-ri.\-
namemrom \'<I!ue;I/I (use:/ix use.'!h . . .)
name.-.=!¢m v.a!us:frx (usemx usc:II'x . . .)
»-Y)
The fi\np\ in Htlltt files and the fixtip files associated with FBIN files are in a fast internal format
that lnﬂks like .1 UVl*_ClOR nf PRIHYYPE VORDs.
Fimps are usually tliscattletl after they are nscd during the loading procedure. However. if. while
reading .1 Int.‘/\RY or HBIH file the ATOM I<[[P-FIXUP$!- has at non-FALSE LVAL, the fixups will be
kept. \'i.1 :\|| .'\$\l'\(‘l:\ll(\ll hetwt-en the RSUBR and the ATOM RSUBR. It should be noted that. besides
correcting the rﬂtle. the fixllps tltotmt-Ives are corrected when KEEP-FIXUPS is bound and true. Also.
the nsseinhlcr and contpilcr tnal~.c the sante association when they first create an RSUBR. so that it
catt be written r\ttt with its fixups.
l9.8 - l9.9 Compiled Programs



165 The MDL Programming Language
ln lhe (n~c' of pure RSlll3Rs (I BIN filo»). things are a linle different. lf a pure-code file exists for
lhis rc-In-.\~u n1 MI)l,. 1| is med immedialrly. and the fixups are completely ignored. If a pure-code
file for ll|i\ rrlr'.1s(‘ doom‘: c.\i<-I. the fixup file is used Io create a new copy of the file from an old
one. and :1l\n .1 urn |'l~\'i\itvn of xhc fixup file is crcalcd to go with the new pure~code file. This all
goes on ;\umu::\|ic:|lly behind the user's back.
l9.9 Compiled Programs



ti
t
-
1
i
The MDL Prngratntning Language 169
Chapter 20 . Cox-outines
This cliapter pntpnrts to L'\|)l;\llI the corontine primitives of MDL. It does make some attempt to
explain rorontinr-s as snclt. but only as required to specify the primitives. If you are unfamiliar
with the tunic cnncrpts. confusion will probably reign.
A cornntine in MD! is itnplcntcnterl hy an object of TYPE PROCESS. ln this tnanual. this use of the
word "prncr<~." is distingnisltcd hy capitalization from its normal use of denoting an operating-
Sy$lOlll |'|t‘ﬂt‘t\s (which various systems call a process. job. fork. task. etc.).
t\iDL‘s built-in cnrmitine primitives do not inchnle a "time-sharing system". Only one PROCESS is
ever running at .1 tintt'_ and cnntrnl is passed back and forth between PROCESSes on a coroutine-like
basis. The printitivrs are snfficicnt. howcvcr. to allow the writing of a "time-sharing system" ii
MDL. with the ariilitinnal use of the MDL interrupt primitives. This has. in fact. been done.
201- Pﬂogsss at-=_.1Y.P_n
A PROCESS is an object which cnnt:tin.\ the "current state” of a computation. This includes the
LVALs nl’ I\tOHs ("l»inrlings"). "ilepvli" of functional application. and "position" within the application
of each applied function. Smne of the things which are Q part of any specific PROCESS are the
GVALs of !\T0r1s. 3Ss(IClaill‘lll\ (l\SOCs). and the contents of OBLISTs. GVALs (with OBLISYs) are a chief
means nf cmninnntcmion and sharing between PROCESS“ (all PROCE$Ses can refer to the SUBR which
is the GVAL of '. for instance). Note that an LVAL in one PROCESS cannot easily be directly
referenced frnin another PROCESS.
A PROCESS l"RIHTs as !/PROCESS p. where p is a FIX which uniquely identifies the PROCESS; p is the
"PROCESS nninhcr" typed ont by LISTEN. A PROCESS cannot be read in by READ.
The term "run a PROCESS“ will be used below to ntean "perform some computation. using the
PROCESS to record the intcrtncdiatc states of that computation".
N.B.: A PROCESS is a rather large object: creating one will often cause a garbage collection.
20 - 20.1 Coroutines



, I
t70 The MDL Programming Language
g0.2. st/33r_qr_.1_t{r\{0ct"s§
<STATE Ivan":-1:) ‘
returns an AIOH (ttt the ROOT Ol3t.lSl) \\-hicli indicates the "stat:-' of the PROCESS process. The ATOM:
which STATE can tc-tnrn. and their tttcattittgs. are as follows:
RUNAIH F (sic) -- prc:cv~:s has never cvcr been ru||.
RUNNING -- procms is curtz-ntly running. that is. it did the application of STATE.
RE$.tH~1/\t3t t‘ -- A~ror'e‘<;.'- has In-en rnn. is not currently running. and can run again.
DEAD -- Drcztrs has ln-en rttn. but it can not run again: it has "terminated".
In addition. an int:-rrt||\I (rlmptcr 2]) can he enabled to detect the time at which a PROCESS becomes
I "blocked" (waiting for tertninnl input) or 'unbl0ck€d' (terminal input arrived). (The STATE BLOCKED
has not been iIl|pl(‘tt\t:|tl\'U.)
gm. PROCESS mt; sung)
( PROC [1 SS :.‘-'trIer:ap;\/irable)
creates and t('tt|r||s .1 new PROCESS but docs g run it; the STATE of the returned PROCESS is
RUNABLE (sic).
starter is .snnu=thing -1|)p|i¢‘..'lbiE to pti argtunz-tit‘ which must be evaluated. starfer is used both in
starting and "tcrtninating" a PROCESS. ln particular. if the slarler of a PROCESS ver returns l
value. that PROCESS becomes DEAD.
Q
SUHF
204 RF,
The SUBR RESUME is used to cause a cont ut t'o
p at n to start or to continue running in another
PROCESS. An ;l[tp|i(‘RtIO|t of RESUME looks like this:
(RESUME rclv,-/;.m_v process)
where we/t-.n is the "rcmrncd value" (sec below) of the PROCESS that does the RESUME, and process is
the PROCESS to be started or continued‘
20.2 - 20.4 Coroutines
S _



T_
' The l]!O'((_"I§ argtitmwit tn RESUME is nptional. by default the last PROCESS. if any. to RESUME the
. pR0t:£SS in which this RESUME is applird. ll’ and when the current PROCESS is later RESUHEd by
another PROCESS. that RE.SUML's /elval is returned as the valuc of this RESUME.
The MDL Prngralnming Language l7l
I 20.5. s“-ivqLi_"s_£’_‘i9f-'_=§.$£:
2O.5.l. Starting llp ;t New PROCESS
I
Let us say that we are running in some PROCESS, and that this original PROCESS is the GVAL Of PO.
Sontewhvrt‘. tvr have rvalttatcd
(SLTG l-‘l (PROCESS ,Sl/\R'lER)>
w||g-re ,5T/\Rtt'_R l'~ mint» appropriate function. Now. i_n_,_lE. we evaluate
<RESUl‘ll; .I\ .Pl)
and the Fnllnwing ltappcltsz
(l) Lil ,§’_Q tltt: argititveitts of the RESUME are evaluated: that is. we get that LVAL of A which is
current in .90 and the GVAL of P1.
(2) The St/\|F of ,l"0 is changed to RESUHABLE and .P0 is "frozen" right where it is. In the
middle nf the RESUME .
(3) The STAN rtf .Pl is cltattgetl to RUNNING. and .STﬂRTER is applied to .P0's LVAL of A 
_,ll_. ,P1 nnw cnntinut-s on its way. evaluating the body of .$TARTER.
The .A in the RESUME could have been anything. of course. The important point is that. whatever lt
is. it is t:~\'.1lt|att-rl in ,PO.
What happens next tlt‘[‘tetldS. of course. on what .STARTER docs.
20.5.2. Top-lt:‘\'el Return
Let us initially ;ts'~u||tc' that .STARTER tlncs nothing relating to PROCESSes. but instead simply
returns a value -- .\.-t_\- srarva/. What happens when ,STARTER returns is this:
(ll The STATE of .Pl is changed to DEAD. .Pl can never again be RESUHEd.
I 20.4 - 20.5.2 Coroutirtes
L



l
'72 The MDL Programming Language I
(2) The law PROCESS to RESUME ,Pl is found, namely ,PO, and its STATE is changed to
RUNNING.
(3) 11.1: v.»/ is rcturttctl in ,P0 as the valttc ol' the original RESUME. and .PO continues where it U
left off.
All in nll. this simple F115? hanks _itt.st like an elaborate version of applying ,STARTER to .A in .P0.
20.5.3. Sytnntctrir RESUHEittg ‘
New .-||ppn<t~ that while still in .Pl the following is evaluated. either in ,STARTER or in something
called by .5!/\ltlFR:
<RESU|‘1[ .B/KR ,PD>
This is what lt:\pp('ns:
tl) Tho argntncnts of the RESUME are evaluated ii ‘Pl.
(2) The St/Hf nf ,Pl is changed to Rt-‘SUHABLE. and ,Pl is "frozen" right in the middle of the
RESUME.
(3) Thr ST/HF nt’ _P0 is thnngvd tn RUNNING, and .Pl's LVAL of BAR is returned as the value of
Jo} nrigttitll RESUME. ,P0 then continues right where it left uff.
This i\ t_li§ intcrz-\ti||§_' raw. |b(‘C<'ll|\(‘ .PO can nnw do another RESUME of ,P1' this will "turn off-
,PD, pass .1 vnlttr in ,Pl and "turn nu" ,9]. ,P1 can now again RESUME ,PO. which can RESUME
.Pl bark :tg.1in.otc nil n:m\o.jun_ with c\'t'rytl|i|tg done in a perfectly sytntttetric manner. This can
obviously also be tlnttv with three nr more PROCES$es in the same tnattner.
Note how thi\ cliff:-t\ front norntal fnnctiottal application: you cannot "return' from a function
w'tl cl '
1 tout t-sttnyitn; the s-Into that function is in. The whole point of PROCESSes is that you can
"return" (RISUNEI. rctnc-tnbcrittg your state. and later continue where you left off.
20.6. Emtnplc
20.5.2 - 20.6 Coroutines



11‘; MDL Prngranmiing Language l7!
1 ;"In\L|nlly. we are in LISTEN in some PROCESS.‘
(DEFINE sun: (A)
IDECL ((A) (OR FIX FLOAY))
(REPEAT ((S .A))
IDECL ((3) (OR FIX FLOAT>)
<SET S 4+ .5 (RESUME ‘GOT l'>>>
(SE! S <+ .5 (RESUME "GOT Z'>>>
(SET S (RESUME .S)>>>$
SUH3
;"5UM3_ used as the startun function of another PROCESS.
nets RlSUHLd with numbcrsl It returns the sum of the last
three numhcrs \t was given every third RESUME.‘
<SElG SHHUP <PROCESS .SUM3>>$
W -mzocass 2
;"Now we start SUMUP and give SUH3 its three numbers.‘
(RESUME 5 .SUMUP)S
“GOT 1“
<RESUME l ,SUHUP>$
"G01 2"
(RESUME 2 .SUMUP>$
B
, jun as a uolc. by inking advantage of MDL's order of evaluaiion. SUM3 could have ht-tn written ls:
<DEFIN[ SUM3 (A)
<REPEI\l ((5 .A))
IDECL ((/\ S) (OR FIX FLOA'l))
‘ (SET S (RESUME <+ .S (RESUME ‘GOT 1') (RESUME ‘GOT Z">>>>>>
' 20.7. Olhcr (Inromininy Features
20.7.1. ans/\x-seq
<UR(AK-SEQ any process)
. ("break ovalualinn sequence") rm-turns process, which must be RESUHABLE. after having modified it
. so Illa! \vli(‘|\ ir is ucxl RESUMlfd. in will firs! evalualc any and xhen do an absolutely normal RESUME;
| the value romrncd by any is llnrown away. and the value given by lhe RESUME is used normally.
\ If a PROCESS is BREAK-SE01-d more than once between RESUMEs, Q of the anys BREAK-SEOed onto it
‘ will be rcnlcmbcrﬂl and evaluated when the RESUME is finally done. The any: will be evaluated ln
8 20.6 - 20.7.l Coroutines
I 2



17-t The MDL Programming Language
"last-in t'ir.u-nut" order. The FRAME generated by EVALing tnore than one any will have as its FUNCT
the duntttty I\lOl‘l BRl:I\KER.
20.7.2. rtAtu
W/hen you initially start up MDL. the PROCESS in which you are running is slightly "special" in
these two ways:
(ll Any attempt to cause it to become DEAD will be met with an error.
(21 (MAIN) always rctnrns that PROCESS.
The PROCESS nttnthcr of <MI\lN> is always l. The initial GVAL of THIS-PROCESS is what HAIN always
returns. VPROCESS l.
20.7.3. HE
< HE >
returns the PROCESS in which it is evaluated. The LVAL of THIS-PROCESS in a RUNABLE (new)
PROCESS is what HE always rclnrns.
20.7.4. RESUHER
(RESUHER pr0ress>
returns the PROCESS which last RESUMEd proccas. If no PROCESS has ever RESUHEd process. it returns
4FALSE ()- more-._< is optional. <ME> by default. Note that (MAIN) does not ever have any resumes’.
Example:
<l"ROG ((R <RESUl1ER>)) :'n0t. ef\"eCtivq in (HAIN)'
ﬂDECL ((R) (OR PROCESS FALSE>)
(AND .R
<==7 (STATE .R) RESUHABLE)
(RESUME T .R>>>
20.7.5. SUICIDE
(SUICIDE relval process>
'l0.7.l - 20.7.5 Comutines
_-Q.‘
L
t
l
hllliillliihilliiﬁllllll




L
I
~
.
I
t
The MDL Programming Language I75
acts just like RESUME, but clnbbers the PROCESS (which cannot be <HA!N>) in which it is evaluated to
the STATE DEAD.
20.7.6. tstzp
<l$T[P prO(PSS)
returns ;I'!OCt.’t~'F. after putting it into ‘single-step mode".
A PROCESS in single-st:-p nmrlc. whenever RCSUM[d. runs only until an application of EVAL in it
begins or finishes At that point i|| little. the VROCESS that did the ISTEP is IlESUHEd. with a refval
which is :\ TUPLE. if an application of EVAL just began. the TUPLE contains the ATOM EVLIN and
the nrgutncttts to EVAL. ll’ an application of EVAL just finished. the TUPLE contains the ATOM
EVLOUT nnrl the result of the cvalimlinn.
process will rt-tnnin in singlv-step tnode until FREE-RUN (below) is applied to it. Until then. il will
stnp hcforc and aftrr each CVAL in it. Exception: if it is RESUHEd from an EVLIN break with a re!»/al
of TYPE IIISMISS (PRIHIYPL MOM), it will leave single-step mode only until the current call to
EVAL is about to return. Thus lower-level EVM.s are skipped over without leaving the mode. The
usefulness of this mode in debugging is obvious.
20.7.7. FREE-RUN
<l'RCE—RUN process)
takes its argtuucnt out of single-step mode. Only the PROCESS that put process into single-step
mode can take it out of the mode: if another PROCESS tries. FREE-RUN returns a FALSE.
. . ' g_~s with PROCESScs
208 Snt-akin
FRAME:-. EN\JIROr4t-tttlls. TAC-s, and !\CTIVATt0Ns are specific to the PROCESS which created them. and
each "knows its nwn father". Any SUBR which takes these objects as arguments can take one which
was generated by any PROCESS, no matter where the SUBR is really applied. This provides a rather
sneaky unvnns of crossing hetwccn PROCESScs. The various cases are as follows:
GO, RETURN. AGAIN, and ERRET, given arguments which lie in another PROCESS, each effectively
'rcstarts" thr PROCESS of its argument and acts as if it were evaluated over there. If the PROCESS in
which it was ext-cnlctl is later RESUt1Ed. it returns a value just like RESUME!
SET, UNASSIGN, BOUND?, ASSIGNEO?. LVAL, VALUE. and LLOC, given optional ENVIRONMENT
20.7.5 - 20.8 Coroutines



|7s The MDL Programming Language
argtttitctih which lic in another PROCESS, will gleefully change. or return. the local values of ATOM;
in the other PROCYSS. The optional argument can equally well be a PROCESS, FRAME. or
ACTIVATION in another PROCESS; in those cases, each uses the ENVIRONMENT which is current in the
place spt~cifit'd.
FRAME, ARES, and FUNCT will he glad to return the FRAMEs. argument TUPLEs. and applied
Subrnutiuo names of another PROCESS. If one is given a PROCESS (including <HE>) as an argument
instead of a FRAME. it returns all or the appropriate part of the topmost FRAME on that PROCESS‘:
control stark.
If EV/\L is applied in PROCESS Pl with an ENVIRONMENT argument from a PROCESS P2, it will do the
evaluatimi ii Q but with Q3 ENVIRONMENT (E). That is. the other PROCESS‘: LVALs. etc. will be used.
but (ll any new l'RA.*1Cs ncctlrd in the course of the evaluation will be created in Pl: and (2) Q will
be RUNNING -- not PP. Note the following: if the EVAL in Pl eventually causes a RESUME of P2, P2
could functionally rt-turn to below the point where the ENVIRONMENT used in P1 is defined: a RESUME
of P1 at this pnint wntild cause an error due to an invalid ENVIRONMENT. (Once again. LEGAL? can
be used to forestall this.)
20.9. Final Notes
E
(I) A RESUMABLE PROCESS can be used in place of an ENVIRONMENT in any application. The
"current" ENVIRONMENT of the PROCESS is effectively used.
(2) FR/\MEs and ENVIRONM£NTs can be CHTYPEd arbitrarily to one another. or an ACTIVATION can be
CHTYPEd to oithr-r of them. and the result "tvurlts". Historically. these different TYPEs were first used
with different SUBR'» -» FRAME with CRRET. ENVIRONMENT with LVAL, ACTIVATION with RETURN —
hence the invention of different TYPEs with similar pruperties.
(3) Bugs in multi»l’ROCESS programs usually exhibit a degree of subtlety and nastiness otherwise
unknown to the luiinan mind. If when attempting to work with multiple PROCESSes you begin to
feel that you are rapidly going insane. you are in good company.
20.8 - 20.9 Coroutlnea
 e
1.
1
L
1
-_
L
I_
L
wl



ll
HJ
I
l
p._____ _... _
The MDL Programming Language I77
Chapter 21. Interrupts
The MDL interrupt-handling; facilities provide the ability to say the following: whenever “this
event’ occurs. stop what:-\'t~r' is Irving done at the time and perform "this action": when "this action’
is finishvtl. continue with wlratever was originally being done. This event" can be things like the
typing of a cli.-rracter at a terminal. a time interval ending. a PROCESS becoming blocked. 0|’ I
program-de|'inr~<l and -generated "event". 'This action" is the application of a specified APPLICABLE
object to -'l|'gllllI|?lll'~ |‘|l'ﬂ\'i(|(‘|l by the MDL interrupt system. The sets of events and actions can be
changed in e.\'tretnel)' flexihlo ways. which accounts for both the variety of SU8Rs and arguments.
and the rich interweaving of the topics in this chapter. Interrupt handling is a kind of parallel
processing: a prngratn can lie divided into a "main-level" part and one or more interrupt handler:
that execute only when cottdilintis are ripe.
2?!-L D_='_f .i"iQ=,"u_Q\’ _T¢.t11'-.
An iutcrﬂusl is not an object in MDL. but rather a class of events, for example. ‘ticks’ of a clock.
garbage collections. the typing of a character at a terminal. etc.
An interrupt is said n_cgttl when one of the events in its class takes place.
An 2|_QFLH i|llt‘I!t||‘H is one wlmse occurrences arc signaled to MDL by the operating system. for
example. "tieLs" of a elnek. An internal interrupt is one whose occurrences are detected by MDL
itself. for exatnple. garbage collcetiotts. MDL can arrange for the operating system not to signal
occurrences of an external interrupt to it: then. as far as MDL is concerned. that interrupt does not
OCCIIF.
Each intcrrnpt has a name which is either a STRING (for example, “GC", "CHAR", "HRITE") or an
ATOM with that Ptlftlllj in a special OBLISL named INTERRUPTS!— . (This OBLIST is returned by
<XN‘lERRUl‘lS>.) Certain names mnst always be further specified by a CHANNEL or a LOCATIVE to
ltll melt interrupt by that nante is meant.
\Vl|t‘|| an interrupt occurs. the intrrprclcr looks for an association on the interrupt's name. If there
is an assnci.-irion. its AVALUE shnnld be an IHEADER. which heads a list of actions to be performed.
In each IHEADER is the nmnv of the interrupt with which the IHEADER is or was associated.
2| - 2l.l Interrupts



I78 The MDL Programming Language
In each Illt ADETR is an eh-tnent telling whether it is disabled. If an IHEAOER is disabled. then none of
its actions |\ pt‘t'l'0vin(‘tl. The opposite of disablﬂi is Lllablcd. It is sometimes useful to disable an
IHE/\Dl ll |Pll\PﬁfJlli), hut rt-inr-wing its association with the interrupt's name is better than long-
tertn disahlmg Tht-re are SlJllRs for creating an IHEADER. associating it with an interrupt. antl later
renmving the a\\nci.-ttinu.
In each llll Mil? l'~ .1 |lrit'\l’i_I£. a FIX greater than 0 which specifies the iuterrupt's "ituportance'.
The |)r"C("~5tttLj of a lnglter-priority (l.1rgt-r-utnuheredl interrupt will supersede the processing of a
low:-r»|irmrtt_v Isntallrr-nnmherctl) interrupt until the high-priority interrupt has been handled.
In each Illlf\lIiR it .1 t'|m~.\ihly empty) list of llANDLERs. (This list is not a MDL LIST.) Each
H/\NDl ER cnrtvsptnnls tn an action to perform. There are 5U8Rs for creating a HANDLER. adding it to
an Ill[Al'l[R's lust. and later rettmvlng it.
In each ll/\ttl1tFR is a Function that we will eall a handler (in lower case). despite possible confusion.
because that is really the ht-st name for it. .-\n akctizi consists of applying a handler to arguments
supplied Luv the interrupt \_v\tr-tn. The number and meaning of the arguments depend on the name
of the interrupt. In each IIANIHFR is an element telling in which PROCESS the action should be
performed. ‘
21.2. egg
<t:vcrn ~.»..-_= prlorrl) W/1l(h>
creates and returns an enabled INEADER with no HANDLERs. The name may be an ATOH in the
INTERRUPTS OBLISI nr a STRING; if it is a STRING. EVENT does a LOOKUP or INSERT in
(INTERRUPTS>. It‘ there already is an IHEADER associated with name. EVENT just returns it. ignoring
the given K1FIOI(f)'
which tnnst be given only for certain names:
It ulusl he a Cll/\HNIIl. if and only if name is “CHAR” (or CHAR!-INTERRUPTS). In this case it is
the iI||)llI CH/\HtlEt_ frmn the (pseudo-lterntinal or Network socket whose received characters will
cause the mterrttpt tn occur. or the output CHANNEL to the pseudo-terminal or Network socket.
whose ttesiretl rharactt-rs will cause the interrupt to occur. (See below. Pseudo-terminals are not
availalile Ill the Tent-x and Tops-20 versions.)
The argument ntust be a LOCATIVE if and only if name is ‘READ' (or READ!-INTERRUPYS) Or
"URINE" (nr VRItE'-IHtt'RRUPI$l. In this case it specifies an object to be '|nonitored" for
usage by (interpreted) MDL prngratns (section 2l.8.9).
If the interrupt is rxternal. M DL arranges for the operating system to signal its occurrences.
21.1 - 2l.2 Interrupts
l
l
ll
I



i
!
l
»
l
!
t
The MDL Programming Language 179
2| 3 HI\N[)Ll R (the SUE
;';l¢—'il'_i
<l|/\tXDlL’R Ihcadtr anp/rcab/c process)
C‘-e;|[p§ ,1 |lr\HDLfR_ :\tltl\ it tn the frnnt of ilm-rd;-r's HANDLER list (first action to be performed). and
returns it as .1 t-nine. .v;vp/imhtc may be any APPLICABLE object that takes the proper number of
grgulnettts. (N1-nv of the .'|t'§_;t|ltl(‘tIl.5 can be OUOTEd: they tnust all be evaluated at call titne.) process
isithe PROCESS in uhich the hantllcr will be applied. by default whatever PROCESS was running when
the interrupt mrvtirrrrl.
1'||¢- value tctnrnctl by the handler is ignored, unless it is of TYPE DISHISS (PRIHTYPE ATOM), in
whitlt raw nnnc nl” the rcmaining actions in the list will be performed.
The prrt(‘l'\\ill§ nf an interrnpt'\ netions can terminate prematurely if a handler calls the SUBR
DISH ZSS (we b<'k-\~'l-
2t.4. 9r_r
(Oi F ilvpatfrr)
renmves the assnrmtinn bcttvcrn ifveador and the name of its interrupt. and then disables iheader and
returns it. (An t-rmr nrcnrs if there is no :ts\0cialiO|l.) if the interrupt is external. MDL arranges for
the npt-rating systctn nnt tn signal its occurrences‘
(Off name whirh>
finds the lHl> f\t\tR :ts'~nri.-itr-rl with name and proceeds as above. returning the IHEADER. which mus!
be given nnly for ct~|t.1in names, as for EVENT. Caution: if you (OFF ‘CHAR’ ,INCHAN>. MDL will
become deal‘.
(OFF It.tmH<-1)
returns /Iﬂrtri/E! after removing it from its list of actions. Thcrc is no effect on any other HANDLEIB
itt the list.
Now that you knmv how to retnnvc IHEI\DERs and HANDLEFU from their normal places. you nerd I0
know hmv tn pnt thrnt back:
( [VI H T /m_—.wdvr >
If rhvader \\'.1\ pf(‘\'ir1tt\»l)' disabled nr disassociatcd from its name. EVENT will associate and enable lt.
(HANDLER //icndcr hand/cr>
213 . Q|_4 Interrupts



180 The MDL Programming Language
If /taltd/1:r was |tro\'i0usly rc-ntoved from its list, HANDLER will add it to the front of /heads/s list of
actions. Note that r~-ocesr. cannot Ln: specified.
21.5. 1|gt1g,t»[»3_@¢t u_/\ialLljR mm TYPEs)
Bnth ll|e\(- TYl‘l-s me 1-r |"R]lll'YPF. vi-CIOR, but they do not PRINT that way. since they are self-
referencing. Instead they PRINT as
-II; pg‘ ma-I In/vrﬂﬁftrvg-cle!n€/1/
The contents of In!’/\[1Ht\ and Hl\HDLERs can be changed by PUT. and the new values will then
dttcrntinc Iltc brlmvinr nf M l)l..
Before ilc-xcribing the vlmns-nts nf these TYPE: in detail. here are a picture and a Pattern. both
purporting tn \l|mv hnw lhry lt1nL:
IIHEAIIFR [nnmn:.1t,0m or which
disabled?
*——--—-——-——> WHANDLER [' - — - - - - - - -
—-> IHANDLER [IHANDLER []
nrtortlyl < — — — — - - - - — — -
—-" + ---- —-'
applicable | applicable
urocess] < ----- --0 process]
<IHEl\DER <OR ATOM Clll\NHEL LOCATIVE>
(OR ‘HOSP 0 ‘HOSE -1)
(HANDLER HANDLER (OR HANDLER IHEADER) APPLICABLE PROCESS)
FIX)
2|.5.l. IHEADER
The clclnrnts nf an IHEIADFR arc as follows:
(ll n:\mt- nf iIIlt'trtl|)l (ATOM, or CHANNEL if the name is ‘CHAR’, or LOCATXVE if the name is
"RE/\[l" or "\~'RITE")
(2) llﬂll-I(‘tﬂ if and only if disal)l('d
(3) firu ll/\NUl LR, if any. else a zvro-length HANDLER
(4) prinrity
If you lnw track nl‘ an IIIFADCR, you can get it via the association:
For "CHAR" interrupts. (GET Channel !NTERRUPT> returns the IHEADER or IFALSE () if there is
21.4 - 2l.5.l Interrupts
_ in I1
1.
l



T
The .\ll)l l‘rr\gr;unntittg Langnagc I81
tin ;|\<.nrtat|n||: <l’-VENT "CllAR" 0 ¢h.=nn¢-I> rt-turns the IHEADER, creating it if there is no
;;s-.nci.1t|m|.
For "Rh/til" |ttl(‘|’|ttpls. (GET /cral.-.-c READ‘-INTERRUPTS> returns the IHEADER Or IFALSE () if
l|I(‘I(‘ is nn .'\\'~!It‘t;lt|n|t: <l'VENT "P.U\D" O /ocalu/e> returns the IHEADER. creating it if there is
nu ;\\\n<‘t.‘tltntt
t
| pm I-unttr" |||lt"||t||)1\_ <t;[t /(J(.J?l'/(‘ WRITE‘-1NTERRUPTS> returns the IHEADER or IFALSE ()
sf Ilmtc i~. |\n .1~snrt.1ttnn: <L\ILNl "HRIYE" 0 lOta!|ve> returns the IHEADER, creating it if there
is no ;x\\ﬂ(‘i.1ltntl.
! Otltt-tuiw. tltc IHEAUER 1% PUI mt the nnnte ATOM with the indicator IHTERRUPT. Thus. for
L'\.'\llI|)lt', (Slit l'.LOCK' -INTERYIIJPTS ZIlTERRUPT> returns the IHEADER for the clock interrupt or
HMS! () if t||t~t(' is no associatiott: (EVENT "CLOCK" 0) returns the IHEADER, creating it if
tltt-re is nn .1ssm‘i:lli0tl.
' 21.5.2. ll/\NDtE_R
A HANDLER \pt‘(ifi(‘\ rt mrticttlar ﬂclintt for a particular interrupt. The elements of a HANDLER are as
follows:
(I) no\t m\H[\t_[R if any. else a zero-length HANDLER
(2\ prct inns ll»'t!Jt‘ll LR nr the IHFADCR (Thus thc |lANDLERs of at given interrupt form a "doubly-
littLt‘tl list" cl|:t|nm_q l|('l\\'('t‘n each other and back to the XNEADER.)
(3) h.1nttlt-r tn ht" .1ppllt~tl(:ut)tlttn;; APPLICABLE that evaluates its arguments -- the application
is tl0t|(' um h_\- At'l't Y hut by RUIHNT, which can takc a PROCESS argument: see next line)
(-1) l’FY.Ot't SS in which lht' handler will be applied. or IPROCESS 0, meaning whatever PROCESS
was tnnntng when tlw intcnupt nccturcd (ln the fortncr case. RUNXNT is applied to the handler
.1nt| its .1t§_=ntnrnt~ in thr r|tt't't'nll)‘ running PROCESS, which causes an APPLY in the PROCESS
stnrt-tl tn tht: llf\HlIllR_ \\|\|(|t PROCESS ntnsl he RESUP‘-ABLE. The running PROCESS becomes
Rl,St!r-l»'\l3tL', and the slnrrtl FROEESS becomes RUNNING, but no other PROCESS variables (for
example Rl Slltll R) :trc rltangctJ.\
‘ZL6. ~- _" ll!VR_\_
Otht: St
(OH '1.t/,7/.' .1;-;~/nah/r pr|0n|‘_'/:/1x proress whr:h>
i$ cqttiv:a|t~nt to
2l.5.l - 2L6 Interrupts
V
E;



l82 The MDL Programming Language
(ll/Ullll ER <lcVl> HT rtarne prlcrify whIch>
-:pp/ICED/0 process >
ON is :\ cntnhin.1ttnn of EVFNT and HANDLER: it creates (or finds) the IHEADER, associates and enables
it. adds a H/\r~|HLt-'R tn the front of the list (first to be perfornted). and returns the HANDLER.
< DISABLE I/Ir*.tr1'e‘! >
is et't'ecti\-My <l'tlt I/H_‘FI/f‘-V 2 HOSE -1). Actually the TYPE LOSE is unimportant, but the -1
signifies ll|.1l 1/rc.>dr' is disabled.
< |' Nﬂﬂll I/n>.?dr*r >
is efl“cctivi~Iy <i‘llt /.'r/_‘.-.2-.> 2 JLOSE 0). Actually the TYPE LOSE is unimportant. but the 0
signifir-s that me.=dr:/ is rttrtblvtl.
2l.7. l’rinQ_ti_v~_ntttl _l,tt_t»c|rttpt Lcvrls
At any gnrn ttnm there is .1 tit-fitted ititgrrtint litlll. This is at FIX which determines which
intt=rrttpt~ can rrall) "int<'rtnpl" ~ that is. cause the current processing to be suspended while their
wants .1t<- \.'tli\l'it‘tl_ Nnrntal. ttntt-i|\t(‘rr||pt programs operate at an interrupt level of 0 (lero). An
interrupt 1-tpmcr-=<.r-rlat .1n interrupt level equal to the interrupt's priority.
2l.7.l. lntt-rrn|tt l"tnr('suttg
lIll{’fl't||)l\ ":tctu:tlly" occur nnly at well-defitted points in time: during 2 call to a Subroutine. or at
critical plntt-~ \\‘ll|lll| Sulirriutinrs (for oxantple. during each iteration of MAPF on a LIST, which
may be ritrtilml. nr uliilv .1 PROCESS is "BLOCKED" (sec below). N0 interrupts can occur during
garbage cnllr-rtinn.
Vl'l\at :tctu.tll_\ lmppctis \\lt(‘Il an rttabltrd itttcrrttpt occurs is that the priority of the interrupt is
cnntparril with the r|tttt‘ttl lIlll‘l'l’ll[)l lcvcl. and lltc following is done:
If the priority l\ gL<~;1t<~_r than the current interrupt lcvrl. the current processing is ‘frozen in its
tracl.<"-1nd |)t'r1\(‘$HtIg rvl' the actinttlsl specified for that interrupt begins.
If the prtnrity t~ It-'~s than or equal to the current interrupt level. the interrupt occurrence is gucued
-- that is. thv fact that it ncntrrcd is saved away for processing when the interrupt level becomes low
enough.
\N'|it.-n the processing of an int:-rrtt|>t's actions is completed. MDL usually (l) ‘acts as if" the
2l.6 - 2l.7.l Interrupts
F
\
g



The MDL l'r0gr:nnminq l..1nqua;t: I83
,- t '-L'\l\lllI' intr-rrnat It-\'t-t is rcstnrcd. and rocessin continues on what was left off
p[g\|ﬁl| jv L l
(pcrha|>» for nn ltlltt‘ ttnr:|tinn): and t2) acts as if‘ any queued interrupt occurrences actually
t occurrmt right thrn. in their nrigtnztl order of occurrence.
‘ »
21.7.2. INT —l LVFL
M 1-|,,_> 5U£lR ill?-LE \/[L is used to l‘\JllIlt\9 and change the current interrupt level directly.
‘t
‘l
<lNt-LEVEL)
t
 simply rctttrns the current interrupt level_
< lHl—l l'\Jl L fix)
¢||a|;;;c»<- the llll('I|\t|)l lr‘\'t‘l tn its nrgttttlcttt and returns the previously-existing interrupt level.
t tf ltll-LLVLI ifI\»!‘l\ tltr intminpt tr»-rt. it docs not "realty" rcturn until all queued occurrences of
itltvrrtlpts of piitnity higher than the target priority have been processed.
l
Setting the Iill-LL‘./[L rxtrrmcly high (for cxztntple. (INT—LE\JEL <CHTYPE <HIN> FIX>>) effectively
it disablvs all llIl(‘Ifll!Il\ thnt nccurrcnccs of enabled interrupt; will still be queued).
l
U If t tSt[rt nr FRROR I\ called “hen the IhT-LEVEL is not zero. then the typeuut will be
i‘ lISll HTNG-AT-LEVEL I PROCESS p INY-LEVEL i
4
2l.7.3. DISHISS
DISHISS p('!lI|ll!- n handler tn return an arbitrary value for an arbitrary ACTIVATION at an arbitrary
interrupt lcvcl The rall is ax fnllnws:
<llISl‘llSS '».=!t_tc:,=n) .2(l/vnhon1.-vlrleve/;f|x>
whore only thv ~'.:t'._'¢= is required. lf .=r.':.'.w.'ton is untitled. return is to the place interrupted from. and
va/ue is ignnrcd ll‘ tn! leveel is otnittcd. the INT-LEVEL prior to the current interrupt is restored.
! 2l.7.l - 2l.7.3 Interrupts



I84 The MDL Programming Language
2L8. Fipecific ltttorrttpls
D8$Ct"i|)tiI'1lt\ of the clmrncteristics of particular "built-in" MDL interrupts follow. Each is named by
its SYRING n:ttttc. Expect this list to be incomplete yesterday.
"CHAR" is rurrr-ntl_\' the tnnst rntttplt-\ huilt-itt interrupt. because it serves duty in several ways.
These diffcrottt \\'3)'$ will be described itt several different sections. All ways are concerned with
cltaraclcrs or m.1rhiut- words that arrive or depart at unpredictable times. because MDL is
cottttttttltirntittg with 3 person or another processor. Each "CHAR' IHEADER has a CHANNEL for the
eletnent that ttntttes the itttvrrtlpt. and the ntnde of the CHANNEL tells what kinds of ‘CHAR’
interrupts nrctu tn he tiatttlled through that IHEADER.
(I) ll’ the Cttmmtil is for input. "CHAR" occurs every time an ‘interesting’ character (see below)
is t(‘ft"I\'(‘t| (rrun the CtlANNFL's rr:tI tcrutittal. or atty character is received from the
Cll/tttttt L‘s |)S(‘ll(]"~l(‘lIIllll-‘ll. or a character or word is received from the CHANNEL’; Network
\rv\‘Lt‘l. ur tutlttttd (in the ITS version) the operating systent generates an interrupt for any
I'(‘il\fIll.
('1!) lf tlu" Cllfttttttl is l'nr output to a pseudo-terntittal or Network socket. ‘CHAR’ occurs every
time .1 rltarncter or word is wanted.
(3) If the CH/\tttt£L i\ for output to a terminal. “CHAR” occurs every time a line-feed character is
rttttpttt or tin the ITS version) the operating system generates a screen-full interrupt for
the terntinal.
2l.8.|. "CIIAFZ " received
A lmttdlct for an input "CHAR" interrupt on a real tertttinal tnust take two arguments: the
CHARACTER which \\'R\ typed. and the CHANNEL on which it was typed.
ltt the ITS \-ersimt. tho "int:-tr-sting" characters are those "enabled for interrupts‘ on a real terminal.
namely "E1tIuottr_;li “G, ‘K through "_. attd DEL (that is. ASCII codes 0~7, I3-37. attd l77 octali.
In tltc Tenr‘\ :||ttl TOIYS-7.0 \'("rsinlIs, the operating system catt be told which characters typed on a
tertninal shnultl r.-tttse this interrupt tn rtccur. by calling the SUBR ACTIVATE-CHARS with a STRING
argntuettt crttttattttttt; those characters (tto more than six. all with ASCII codes less than 33 Octal). If
called with tm .-trgntnt-ut. ACTIVATE-CIIARS returns a SIRING containing the characters that currently
interrupt. Initially. only “G. ‘S. and “O interrupt.
.~\n initial MDL .1ttr.tdy ltax "CHAR" ettaliletl on .INCHI\N with priority 8 (eight). the SUBR OUITTER
for a hnntllttr. in tun Ill IPROCESS O (the running PROCESS): this is how ‘G and ‘S are processed. In
.1dditimi.rt-cry lilttt‘ .1 new CIIAHHEL is 0l‘Ettrrl itt ‘READ’ ntode to a terminal. a similar IHEADER and
HANDLER are .1ssm~i.1tett with that new CHANNEL automatically. These automatically-generated
IHEADERs and ll/\NULERs use the statidard tttachinery. and they can be DISABLEd or OFFed at will.
Howcvtsr, the IIIEADER for .trtcu/tn should not be OFF-‘ed: MDL knows that S is typed only by an
interrupt!
21.8 - 21.8.! Interrupts
¢
3
t
I
i
t
I 1
t
it
:\
1)
1,
"i
0-)
IIFI'lF0II'I'IPUO-I'Fl'U'l"'FFFF.'



The MDL Pfﬁgfﬂlllllllllg Language I85
Exantplﬁl the following causes the given message to be printed out whenever a “Y is typed on
_INCHAN:
(SET H <lll\lll'lilR <GET .INCl|l‘lN INTERRUPT)
ll-UNCIIOH ((CH/\R CHAN)
"DECL ((Vl\LUE) /\NY (CHAR) CHARACTER (CHAN) CHANNEL)
(AND <==7 .CllAR !\"Y)
<l‘RlNC " [Sc-me of my best. friends are ’*Ys.] '>>)>>$
ell/\HDLLR 'FUNClION ((CH/\R CH/\N) ...)
<+ 2 “Y [Some of my best friends are "Ys.] 2>$
4
<0!-l> .ll>1~
ill/\HDiL‘R |'vFUHClION (...)
Note that nrrnncnrrs nf "CIIAR" do not wait for the $ to be typed. and the interrupting character is
oinitted from the inpttt strum.
A "CHAR" i||lt‘t'rtlpt can also be associated with an input CHANNEL open to a Network socket ("NET'
device). A h.-ilullrt grts applied tn :1 NETSTATE array (which see) and the CHANNEL.
In tho l'l‘S wrsirvn. .1 "CHAR" interrupt can also he associated with an input CHANNEL open to a
p5(‘lll|O-l(‘l’IIltIl.‘li t"5TY“ device and friends). An interrupt occurs when a character is available for
input. Thvsr int<-irnpts air srt up in exactly the same way as real-terminal interrupts. except that a
handler gr-ts .'t])p|i(‘(| tn nnly 1 argunit-nt. the CHANNEL. Pseudo-terminals are not available in the
Tenca and Tops-‘.20 versions.
For any other flavnr of ITS channel interrupt. a handler gets applied to only one argument. the
CHANNEL.
21.8.2. "CHAR " w:\nted
A "CHAR" interrupt c.-in be associated with an output CHANNEL open to a Network socket ("NET"
device). A Ii.1n|.llt-rg1t~ts applied to a HCTSTATE array (which see) and the CHANNEL.
In the ITS version. .1 "CIIAR" interrupt can also he associated with an output CHANNEL open to a
pseudo-tcr|nin.1l (“STY" dt-rirv and friends). An interrupt occurs when the program at the other end
needs a cliarncrci land the npcraling~systc|n buffer is empty). A handler gets applied to one
irguinont, the Clllltttlll . P\t-iirln-terininals are not available in the Tcnex and Tops-20 versions.
21.8.3. "CHAR" for ||('\v lino
A handler for an output "CHAR" intcrrnpt on a real terminal must take ' arguments (using
OIIE Oi IWO
2l.8.l - 21.8.3 Interrupts



I86 The MDL Programming Language
"OPTIONAL" nr "tLll‘LE"1: if two arguments are supplied by the interrupt system. they are the line
numb:-r (FIX! and the ClII\NHF.L. rt‘\|)t'cliVcly. and the interrupt is for a line-feed: if only one
nrgninr-nt is '~tl|‘l|l|l¢‘ll (nnly in the ITS version), it is the CHANNEL, and the interrupt is for a full
terminal screen. Note: the supplied line number cotnes from the CHANNEL. and it may not be
accurate if the progrnut alters it in subtle ways. for example. via IMAGE calls or special control
characters. (The |1rn;;r.1in can compensate by PUTtiug the proper line number into the CHANNEL.)
21.8.-I. "GC "
"SC" occurs Jun .1l'_u_~r t'\‘er_\' gstrhage collection. Enabling this interrupt is the only way a program
can knnw that .1 |_r.1tl.i:igt* collection has occurred. A handler for "BC" takes three arguments. The
first is .1 fl OAT intlicatine the number of seconds the garbage collection took. The second argument
is a FIXiuilir.1ting the cause of the garbage collection. as follows (chapter 22):
--a om .-..w.\2-o
9 P" .?" .
Prttgr-1tn called GC.
. Movable striragv was ('hllill$|Cd.
. (Irtnttnl swirl. o\'erl'ln\»-ed.
. Top-lt*\‘t'l LVI'\Ls nvriflmved.
. CiVI‘\L vector n\'('1l'lﬁ\vt'd.
TYl'l' vector riv.-rr|'ln\\'etl.
l|nutn\-.1lile rg.1rh.\;r'-rr\llected storage was exhausted.
. lnteritnl stnrl». nverflm-.-ed.
Both control and internal stacks overﬂowed (rare).
. Pnic storage was exhauxtcd.
Second. r-ahaustive garbage collection occurred.
The third ar;4i||uent is an ATOM indicating what initiated the garbage collection: GC—READ, BLOAT.
GROW. LIST. VECTOR. SET. SETG, FREEZE. BC. NEHTYPE. PURIFY. PURE—PAGE-LOADER (Pure
storage was (‘.\ll.'lIl\l(‘tl), or IHIETRRUPT-IIANDLER (stack overflow, unfortunately).
2|.8.5. "DlVl I-ll—l\GC"
"DIVl;Rl-f\t3C" (".\ntrun.1tic C-arlmge Collection") occurs just before a deft.-rrahle garbage collection
that is ncetletl hetxtuse 1-I (‘\|lﬁlI\lL'd tnovable garbage-collected storage. Enabling this interrupt is
the only \\'.=t_y .~i prr-g|.1in<.1n Limw that 5| garbage collection is about to occur. A handler takes two
argutnent~: .1 i'lX ti-thug the nnnibt-r of machine words needed and an ATOH telling what initiated
the garbage t‘<\lle<‘l|t\t| (tee .1lm\'t*)> ll’ it hishes. a handler can try to prevent a garbage collection by
calling BLOAT with the FIX argntnent lf the pending request for garbage-collected storage cannot
then be satisfied. a gartinge collection occurs anyway. AGC-FLAG is SET to T while the handler is
running. so that ||e\\' storage requests do not try to cause a garbage collection.
21.8.3 - 2|.8.5 Interrupts
T
i
2



3
1
1
1
1
I
l
!
k
The MD! Prngrattttning lattgttagt 187
2t.a.6- "CLOCK"
-CLOCK", when cttnhled. occurs every half second (the ITS "slow-clock" tick). It is not available in
the Tenex :|ttd Trvps-‘.20 versintts. It wants handlers which take no argutnents. Example:
(ON "CLOCK" (FUNCTION () <PR1NC “TICK ">> 1)
21.9.7. "nt our-rt-'
"BLO(1k[U" IICLlll\ \vl|t~ttt'\'er .jtty_ PROCESS (nut only the PROCESS which may be itt a HANDLER) starts
waiting fny te|min.1l input: that is. an nccttrrencr.‘ indtcates that somewhere. somebody did a READ,
llEADt"llR, Hi xtrtllt, Ivl, etc. tn a tvrtnittal. A Itandlcr fur a "BLOCKED" interrupt should take one
qrgnntont. natnely the PROCLSS which started waiting (which will also be the PROCESS in which the
handle: runs. if tin specific nne is in the HANDLER).
Example: the following will cause MDL to acquire a I prompting character.
(OH "BLOCKED" IFUNCTION HIGHORE) (PRINC !\">) 5)
2l.8.S. "UNBLOCKED"
"UNBLOCKFD" turtns ttlienevrr a S tliSC) is typed on a tertninal if a program was hanging and
waiting fnr illplll. ﬁr nhen a TYI call (which see) is satisfied. A handler takes one argument: the
CHANNEL via which the S or character is input.
2l.8.9. "Rl.l\D" and "HRIIF"
"READ" antl "WRITE" ate associated with read or write references to MDL objects. These interrupts
are rtften rallrrl "nmn|tnrs". and enabling the interrupt is often called "tuonitoring" the associated
object. A "rentl ruft-retire" tn an »'\lOtl's local value includes applying BOUND? or ASSIGNED? to the
ATOM; sitttil.1rl)' for a global vrtlue and GRSSIGNED7. If the IHY—LEVEL is loo high when ‘READ’ or
'VRITE" 0C(‘|t|s_ an errnr nccnrs. because occurrences of tlu:.se interrupts cannot be queued.
Monitms are set up \\Il|I l'\./HIT nr OH. using a locative to the object being monitored as the extra
which rirguttteitt. just :ts .1 CIMHHEL is given for "CHAR". A handler For "READ" takes two arguments:
the lrtcntivc and tltu FRA-Mt. nf the function application that makes the reference. A handler for
“\-IRITE" tales tltrrr arguntents: the locative, the new value. and the FRAME. For example:
(SET A (1 .7 3)>$
(l 2 3)
(SET [1 (AT .A 2>>$
dLOCL 2
21.8.6 - 21.8.9 Interrupts



I88 The MDL Programming Language
(ON “URIlk" (FUNCTION (OBJ VAL FRH)
'O[CL ((VALUE VAL) ANY (OBJ) LOCRTIVE (FRM) FRAME)
<CRLF)
<PRlHC "Program changed ">
<PRlNl .08J>
(PRINC ' LO '>
(PRIN1 .VAL>
<PRIHC ' via '>
<PRlNl .FRH)
<CRLF>>
4 D .B>$
IHANDIIR ‘FUNCTION (.U)
(l .A lO>$
(l0 2 3)
<7 .A 2O>S
Pruqrnm changed ILQCL 2 to Z0 via IFRAHE PUT
(I0 20 3)
(OFF "WRITE" .B>$
JIHLADIR ILOCL 20
‘Zl.8.l0. "SYSDO\Jll“
"SYSDOUH" rvcrnrs \v||("t1 .1 s_y.\tetu-gnitlg-tlnwll or system-revived signal is received from ITS. It is
not :tv.1il.1lilc in the Tones and Tﬂps-20 versions. If no IHEADER is associated and enabled. a
warning I5 prtntnl mi thc terminal. A liandlcr takes one argument: a FIX giving the number of
tliirtiolln of .1 wrnml until the shutdown (-1 for a reprieve).
2l.8.ll. "ERROR"
ln an effnrt tn \lI\t|)liT}' rrrnr Imttdliug by prngrams. .\lDL has a facility allowing errors to be
ltandlt-tl like inlt-rrupts. 5ETGin; ERROR to a user function is a distasteful method. not safe if any
hugs arr‘ :irr-utul /\u "FRROR" ililcrrupl wants a handlcr that takes atty number of arguments. via
"TUPI E". WI.»-u ah Prrnr nrcun. ||.\lll||l‘|'S are applied to the FRAME of the ERROR call and the TUPLE
of ERROR .\ri;mut-uI\. lf a given hnntiler "takes care of the error‘. it can ERRET with a value from the
ERROR FRAME. .1ftcrli.1\-tug done <lNT-LEVEL O). If no handler takes care of the error. it falls into
the normal LRROR.
lf nu crrnr urcur~ at an INT-LEVEL greater than or equal to that of the 'ERROR' interrupt. real
ERROR will be callrtl. because "ERROR" interrupts cannot be queued.
2I.8.9 - 'Zt.8.ll Interrupts
t
v
\ l



1
I
t
<
L
The MDL l’r0_qran|tttiltg Language l89
2l.8.l2. “ll'C"
"1PC" m-curs \\-lien a rttessnge is received on the lTS lPC device (chapter 23). lt is not available ln
the Tent~.\' antl Tops-‘.20 \'t*rsinn'\.
2l.8.l3. " IND LRIOR"
"INFERIOR" nrcurs when nu inferior ITS process interrupts the MDL process. lt is not available in
the Te||t‘\ .-turl Trips-".20 venirltts. A ltattdlrr takes one argument: a FIX between 0 and 7 inclusive.
telling which infermr process is interrupting.
2l.8.l-I. "RllNl " alttl "RI I\| T"
These are nnt available in the Teuex and Tops-20 versions.
'RUN‘l". if ennlvlml, ncrttrs rice. N seconds of MDL running time (CPU time) after calling
<RUNTIl"l[R /V.'.'!\'(?r-//O41/>, which returns its argument. A handler takes no arguments. If RUNTIHER
is c:\Il(‘tl \Vllll un argunteut_ it returns a FIX, the number of run~titne seconds left until the interrupt
uccure, nr ~r»\t St (J if the interrupt is not going to occur.
"REALT", if ('llI‘ll|lt‘ll. nccnrs e§_t1y_ N seconds of real-world time after calling <REALTIHER N.-!t'x—or-
//o.=r>. which returns its argtttnent. A ltaudlcr lakes no arguments. <REALTIHER 0) tells the
Operating <._v<.tent nnt tn ;;ener.tte rc-1|-time interrupts. ll’ REALTIHER is called with no argument. it
returns :t l'lX, the nutnht-r of real-time seconds given in the most recent call to REALTIHER with an
argtttnettt. or if/\LSE () if REALTIHER has not been called.
2l.8.l5. "Dang:-rolls" lnterrupts
"l‘lPV" ("ntentnry-protectinn vinl.-ttio|t") occurs if MDL tries to refer to a storage address not in its
address \|:.1t*0 "l‘lIRl" ncrurs if MDL tries to alter rend-only storage. "ILOPR" occurs if MDL
e.\tect|t(>s an illegal lIl'~lrIlt.‘Ii0|l ("operator"). "PARITY" occurs if the CPU detects a parity error in
M DL's adtlress space All of these require a handler that tales one argument: the address (TYPE
WORD) l'nllnwin_r; the inurnctinu that was being executed at the time.
"ICC" occurs if -\lDl. tries tn tlesl illegally with an llO channel. A handler tnust take two
arguutcnts: a three-t~lv|tu.-ut FALSE like one that OPEN might return. and the CHANNEL that got the
Cl’!'D|'.
Ideally. tlu.-se intt-trupts slmuld never occur. In fact. in the Tenex and Tops-20 versions. these
interrupts always gn tn the superior operating-systent process instead of to MDL. ltt the XTS
version. if and when a "dangerous" interrupt does occur:
2l.8.l2 - 2l.8.l5 Interrupts



190 The MDL Programming Language
If tin l|tL~/\DFR is .1\'~fI<‘l1\l(’(l with the interrupt, iheti the interrupt goes to the superior
ﬂllﬂlﬂllllg-§)'§lGII| |l|’ﬂC?SS-
lf .m IIIEAUCR is .‘l\\|\(‘l.1l(‘ll but disabled. the error DANG€ROUS-INTERRUPT-NOT-HANDLED occurs
(FILE-SYSl[M'£'RROR fnr "lOC").
If :iu llll Am R ls .issn<-i.1tetl and rttahlcd. but the INT-LEVEL is too high. the error ATTEHPT-TO-
OLfl_R-UNDEFEilI\llLE-INTERRUPT occurs.
21.9. Ll:l‘lL[_)\‘v|il|l€‘_tl_l ll_l(‘ffllll_(3 _(_l_[l_TERRUPT[
If the iutcrritpt ti.-tuir givru lﬂ EVENT or ON is ttot one of the standard predefined interrupts of MDL.
they will glvt-hilly create :tti ATOM in <1'NtERRUPTS> and an associated IHEAOER anyway. making the
zissuitiptitui tlt.-it you are setting up a ‘program-dt.-fined‘ interrupt.
Progrniit-ilrfmrtl ititcrrtipts are ttiatle to Occur by applying the SUBR INTERRUPT, as in
-: INIERRUPI I13-VH5’ ".11  .1rgN>
wlitrc it-1/--0 is .1 STRING, AIOM nr IIIEADER. and argl through argN are the arguments wanted by the
haiidlcrs for the tutc-rtupi.
If the ttttcriupi spcctfictt hy IHTERRUPT is enabled. INTERRUPT returns T; otherwise it returns
‘FALSE (). All tlu- usual |-tinrity and qticneitig rules hnld. so that even if INTERRUPY returns T, it
is pnssihlc lh:it nothing "really |i:ippeited" (yet).
INTERRUPT c;i|| also he us:-tl tn caiisr ‘.1rtiftcial" occurrences of standard predefined MDL interrupts.
.\i.1l.itig .l |itnt;r.1ttt-tlt-(ttiml iutvrrtipt occur is siitiilar to calling a handler directly. but there are
dtffcrrtire-s The \-.1lttt~ ictutuctl by a hatidlcr is ignored. so side effects ttiust be used in order to
COlIll|Illllii :ttt- iufr-riu.1tirut l-at-L. tn thc caller, other than whether any handler ran or will run. One
gnarl use rflf ;i pro-;t.ttii-tlrfitirtl ttttrrrttpt is to use the priority and queueing machinery of INT—
LEVEL tn cnuttul the ext-ctttitui tit‘ fttttctintts that utttst not ruti concurrently. For exaniple. if I
"CHAR" ll-‘|Iltll(‘f Just tlr|msit~. rlmtactcrs in a buffer. theu z futictiou to process the buffered
cliaractrrs slit-ultl ptﬁlialtlv run at a higher priority lcvcl -- tn prevent unpredictable changes to the
btifft-r tinting tht- Pll’I(‘(‘§\illQ -- .iutl it is natural tn invoke the processing with INTERRUPT.
lti l|Ir\r(' ('\ﬂtic ap|>ltr.1ttriu~_ IHIERRUPT can signal a condition to be handled by ati unknown
nttittht~t- nl‘ llI1l(‘|)i"llllt‘lll auit "ttatttch~s\' functions. Tltt: functions are "nameless" because the caller
t.loesit't Lnniv tltt-it n.1iues_ riuly the uaute oi the interrupt. This programming style is modular and
(‘VQIII-(|l’l\‘PII, .iud it l\ IIll(' ivrty nf iinpletnetitmg 'lieuristic' algnritliins. In addition. each HANDLER
has .1 PROCYSS tu it--lttclt to rtitt its liattdlcr. rind so the different handlers for a given condition can
do their thin; tu tliffcrcttt etivirnuiticuts quite easily. with less explicit control than when using
RESUME.
21.8.15 - 2l.9 Interrupts
1
t
D
l



PP
Thr M DL Prm_,'r:u|nuing Lzxllguagc‘ 191
21.10. \\'ﬂ_i'iu§i‘*r_l!*!srI,!!|>Q
2l.lD.|. HANG
(IIAHC A"’!’(1>
sus|><-nds t'\e\‘uliuu. |n\e||||pIihI)'. witlmul cnns||miug any CPU Iilnt. potentially forever. HANG is
handy fm a prngmm rh.-n cannnl dn anything nmil an interrupt occurs. If lhe optional prod is
given. it H 1-\-alunlrd cvcry timc an inrcrrupl occurs and is dismisstd back into the HANG; if Ihe
rcsulr nf r\-.1h|;1r|rm n nm l"l\l5L_ HM-‘G uuhangs and rcmrns il as a value. If pred is not given.
(here had bone-r lw :1 u:1|||('d ACTIV/\TiON somewhere l0 which a handler can return.
21.10.12. SHIP
<SLl.[|" /m|u;/n—o/-Ilc.4/ p!(,‘d>
s||sp(*ud\ 1-xx-cuIim|_ nuuwrruprihly, willmm rnnsu|||iug any CPU time. for hme seconds. where Iime is
non-nc-g:\1i\'c. nml lhr-n rcmrus I. D/cd is the same as for HANG.
2110 - 2l.l0.2 Interrupts
L



I92 The MDL Programming Language
Chapter 22. Storage Management
Tlte rt‘:l\rt|t I|ll\ clinpter rrtntes so late in this document is that. except for special cases. MDL
prngratns ll.'I\‘f‘ their sti-»i.1i__-i~ ttet:-tls hantllcd autotnatically. There is usually no need even to consider
sloraqt‘ IlI.'I|l-\!f(‘llll"Ill. t-\ct~pt as it affects efficicttcy (chapter 24). This chapter gives some
explniinttnti iif \\'|I\' this l'> so. and rovers those special ineans by which a program can assume
COllIr0l rtf \tnr:ti;(' |tt:t|t:\§c'tttt'ttl,
The Ml)l 5‘lKl(‘I"[‘€\ ~|i.1i:t- is div-iilcil tum five parts. which art: usually called
(H tutvr.-iLtk' i_;.tr|t.1_g'0-cnllr-cled space.
(2) iinmnvaI>|t- space (hntli garbage-collected and not).
(SI user |>tttt>/|i.1_qi- spare.
(-ll pitic-l;$llLllt tn.1ppitti; space, and
(5lttt|0tttal\tm.1_gt-.
Internal slﬂraqv ni-ciiptrs ltnllt the liiglimt antl lowest addresses in the address space. attd its size
never €|l.'lll§_[f'\ as .'\1l)| 1_‘\l‘(lllP\ Tlir- other spaces can vary in size according to the needs of the
exccitting |>ing;r.-int (;cni~r.t|l_v the interpreter allocates a contiguous set of addresses for each space.
and enrli ~|1:\r(- gratltt.1|l_v fills up as new nhjccts are created and as disk files are mapped in. The
action lJlL(‘ll \\llf‘ll .1 spat-t' hcrntttes full varies. as discussed below.
to
to
. . .\lo_\-:il_tli~ (illll:\;'::('nII(‘(:[U(|4Slnrng£
Mast storage nscd (‘.\[7|I(ll|_V hy t\lDl. progratns is ohtaincd from a pool of free storage managed by
:i “garbage (nil:-cti-i" Qtnrago is nlttatitcd from this pool by the SU8Rs which construct objects.
\Vhen such .1 Sltuit rinits that the pool of available storage is exhausted. it automatically calls the
garbage rollt'i'Ir\r
The i;.1ilmt;r~ inlli~i-mt lt:t\ l\\'(I .-ilignt-ttlitns available to it: the “copying” algorithm. which is used by
default. anil llll‘ "in.\rL~swi-r-p“ nlgniitliitt. Actually. one often speaks of two separate garbage
collectrtrs. llw "tnp_\'mg" our .-tnil the "niark-sweep" one. because each is an independent module that
is tnappt-il in tn the ititcrprctcris intcrtial storage front disli only during garbage collection. For
simplicity. this ilncitntt-itt spt‘:tlt\ of "the" garbage collector. which has two algorithms.
22 » 22.] Storage Management
- L I
l
i



I
t
I
l
3;
The MDL Progrmntnittg Language I93
The garliago collt-ctm c-\:tntint-s the storage pool and ntarlts all the objects tltere. separating them
into l\\'n cl:t~\r-~: those which c:tnnot possibly be referenced by a program. and those which can.
The "cop_\'itng" ;tl-_;otithtn tht-n copies the latter into otte compact section of the pool. and the
retnaintlor of the pool is ntatlt‘ available for newly constructed objects. The "ntarlt-sweep" algorithm.
itnteatl. pnts all oh_|t-cts tn the foruter class (garbage) ittto "free lists". wltere tlte object-construction
5UBRs can fintl thrtn and re-use their storage.
If the rcqttost fm tnrnc storage still cannot be satisfied front reclainted storage. the garbage collector
will attctnpt tn obtain more total storage front the operating system under which MDL runs. (Also.
if there is .1 gtms sttpctfltiity of storage space. the garbage collector will politely return some
storage In tltt‘ opt-t.\titt;; sy$tt't|t.) Only when the total system resources are exhausted will you
finally Inst’
Thus. if yon _jtt\t "forgot :thont" an object. that is. lose all possible means of referencing it. its
storage an-.1 is .-nttntttatirally rcclaimcd. "Object" in this context includes that stack-structured
storage spare nu-tl itt PROCESS“ for functionalapplication.
22.l.l. Statks antl Other Internal Vectors
Control st;tcl.s are ttsctl itt MDL to control the changes itt environntent caused by calling and
binding. l-Irtvlt actito PROCKSS has its own control stack. On this stack are stored LVALs for ATOHs;
PR1Hl'Yl‘[ tttt‘tt'~_ which arc rttltcrwist‘ like VECTOR; PRIHTYPE FRAHEs. which are generated by
calling Snhmtttinr-s: and l\CtlV/\TlOlis. which are generated by calling FUNCTIONs with named
ACTIVI\TIOrt\. PROG, ant! Rt'I‘EAl. TAG and LLOC catt ntal.e lAGs and t_OCDs (respectively) that refer to
a specific. place mt a specific control stack. (LEGAL? returns l’ if and only if the portion of the
control star L. ttt \\l|lr|| its :tr;ntt\cnt is found or to which its argttntent refers is still active. or if its
argntnont tlne<n't rare ahrtnt the control stack. Tlte garbage collector tttay change a non-LEGAL?
object tn IYPE ltt EGAL hefore it-claitnittg it.) As the word "stack' implies. things can be put on it
and rctnrwed ftmn it at only one end. called the top. lt has a ntaxiniutn size (or depth). and
attontpting tn pnt too many things on it will cause overflow. A stack is stored like a VECTOR. and
it ntnst be GRO\-In if :\ntl when it overflows.
A contrnl stat}. is artnally two staclu in one. One section is used for "top-level" LVALs -- those SET
while the /\lOH is not honntl hy any active l'-'nnctiott's argtttncnt LIST or Subroutine's SPECIAL
binding -- and the other -tr-ction is ttsctl for everything else. Either section can overflow. of course.
The top-lot-vi-LV/\L section is |Jt‘lﬂ\V the other one. so that a top-level LVAL will be found only if the
ATOM is tint currently hound elscwltrrc, nantcly in the other section.
MDL also has an itttrtn:tl stack. ttsetl for calling and temporary storage within the interpreter and
contpilcd pro;t.1tn\. it inn is stored like a VECTOR and can overflow. There are other internal
\’l‘Ct0rs that crttt m-crflmr: the "_t;lohal vector" holds pairs ("slots") of ATOHs and corresponding GVALs
("globally hmtntl" or GllOtIttl)" lll(‘8ll$ that the ATOH in question is in this vector. whether or not it
currently ltas a global \':thtt'). and the "TYPE vector“ holds TYPE natnes (predefined and NEHTYPEs) and
how tltcy are to be treated.
22.1 - 22.l.l Storage Management



I94 The MDL Programming Language
222 I-~~m\_‘ms.§IL=:Q~_§£
22.21. Garbagewnllvcted: FREEZE
in very special rirrumsi.-uic<*s. such as debugging RSUBRs_ you may need to prevent an object from
being mr-vml by lllt‘ gniliagr rnllertnr. FREEZE takes one argument, of PRIHTYPE VECTOR. UVECTOR,
STRING, BYTES nr TUPLE. Ii copies ils argument into non-inoving garbage-collected space. FREEZE
rcturus the cnpy t‘.i|TvP[it in its PRIHIYPE. except in the case of a TUPLE. which is changed to a
VECTOR.
22.2.2. Nﬂii-gnub:\gr-vﬁllrrtctlz SIORAGC (the PRIHTYPE)
An 0l>_ject nf PRIt~1I‘rl'l. SlORr\G£ is really a frnzen UVECTOR whose UTYPE is of PRIHTYPE WORD, but
it is al\s':t)'s pnintcil in li_y wmctlmig internal to MDL and thus is never garbage-collectible. The use
of FREEZC is alu-riys preferable. except when for historical reasons a STORAGE is necessary.
22.3. Otlirr Stni':|§£
User ptiro.'p.13_;e sp.'\(t.‘ servos two pllf|)D§€$, First. when a user program PURIFYs (sec below) MDL
objects. they are cnpicd iuln this space. Second, so-called liand-crafted RSUBRs (assembled but not
coinpilmll ran mil nii the it|l('l’|Il'Cll‘l‘ to iuap pages of disk files into this space for arbitrary
ptlrpnsvs.
Pure-RSHBR ni:ippini; space is us;-tl liy the interpreter to dynamically map pages of pure compiled
programs ium and nut of the i\ll)I. adtlrcss space. Pure code can refer to impure storage through
the "tr.1iisl'r-i \-mini .‘lIlﬂI|I(‘f mieriial vector. This space is the most vulnerable to being compressed
in size by tho lnm;-it-mi i__'inuih of other spaces.
liitcrnnl -tnr.i_qi- has linth ptlrt‘ and iuipurc parts. The interpreter program itself is pure and
sliaralilt-_ while iuipurc stnrage is used for internal pointers. counters. and flags. for example.
pointers lﬁ the linmulnrirs uf ntlicr spaces. in the pure part of this space are most of the ATOHs in
an miiml .\ll)l . alum; with their OBLIST buckets (LISTs) and GVAL slots (a pure extension of the
global vector), \\'|ll‘I(‘ pnssihlr. A SET or SETG of a pure ATOM automatically impurifies the ATOM and
as much of its OBL IS! liitrkot as needs to be impure.
22.2 - 22.3 Storage Management
 
7’
I
I
-1‘
L
ll‘
L
L
WI‘
L
L
ll‘ ll‘
k
L
_l>
l'l'l‘l'
L



t
I
!
1‘
The M D1. Progrztnttning l.:tttgtt:tgt' 195
,.1_rl_t.}gL(_Irtllr~cttntt: Details
‘Z-l C, _ g
\$’hett either of the t_'.1rh:tgt--crtllected spaces (movable or itntnovahle) becomes full. MDL goes
through the |’nll-m-ing procedure:
(|) A "Dl\/LRT-I\GC" itttetrttpt nccttrs if the garbage collection can be deferred temporarily by
sltiftitig lmttt|¢l.ttit-~ ||('l\\'('t‘lI storage spaces slightly. The interrupt handler may postpone a garbage
collertintu lay nmvitti; hnuntlaries itself with a call to BLOAT (below).
(‘ll The g.1rtt.igt- roll--ctm In-gins r\t~ctttinn. The "copying" algorithm creates an inferior operating-
s_\'\lClll |trntt'\\ ttmtiictt AGC tn the ITQ vrrsinn) whose address space is used to hold the new copies of
|,m|.g.~t|ti.-t\;t- tth_im is .\tl)| gains :trt‘<‘\s tn the inferinr's address space through two pages ("frontier"
amt "w|mtt-iv") Ill its i|ttt"r|l:\l spare that are shared with the inferior. lf the garbage collection
nccurrt-tt h<-c.1nst- mm-:ililt- gnrlmge-rollt-cted space was exhausted. then the "tnark-sweep" algorithm
might he nst-tl tnstcatl (see belmvi. and ttn inferior process is created.
(3) The gntlingl‘ cntlm-trtr t|mrl.s .1llnh_;t~ctsth.1tran possibly be referenced hereafter. It begins with
the (H/\IH> l'*ltOtJE,5!s and lhtt t-nrrently running PROCESS <r1£>. considered as vectors containing the
control statls. r-lv_|r'ct peitttvts ttt live registers. etc. Every object itt these "PROCESS vectors" is
ttt.1rLt'4| “;tnt~ssil»tr". nntl evrty elctttettt of these objects (bindings. etc.). and so on recursively. The
"copying" algrtt tlltttt tum-t-s ttbjrcts into the inferior pruet-ss’s address space as it marks thetn.
(-ll if the t;.1th.1t;e enllectiﬂtt is "exhaustive" ~- which is possible only in the "copying" algorithm -
then hnth tltr tlmitt of :|ssnci;tti0tts .‘\tttI tnpdevel local/global bindings are examined thoroughly.
which tnl.t>s lllfltt‘ tinw but ts tttr_tte likely to uncover garbage therein. In a normal garbage
€0|l('cliﬂtt these rnnsttucts ate nut treated specially.
(Yul Finally. the "limit-sweep‘ algmithnt sweeps through the storage space. adding unmarked objects
to the itttt-rn:tl free lists for later re-use. The "copying" algorithtn maps the inferior process’:
address space into -\ll.)L'.~ own, rcplarittg old garbagey storage with the new compact storage. and
the inferiur pr0t‘(‘ss is drstm)-ed.
22.5. GC
(RC !;7i‘!7,‘|'/\ ox"/t";rﬁl$L‘~Or—a/2,' ms~frcq.-fix)
causes the i__;.-irtmgv rﬂllerlrtr tn rtttt .-ind returns the total number of words of storage reclaimed. All
of its rtrgttntottu me optional: if they are not supplied. a call to GC simply causes a "copying"
garbage collectiott
If min is e\|)|iritlt snppht-d as an argnntcnt. a garbage-collection parameter is changed permanently
before the gartinge collector rtttts. mm is the smallest number of words of "free" (unclaimed.
22.4 - 22.5 Storage Management



I96 The MDL Programming Language
available for use) ||tr>\'ablt' garbage-collected storage the garbage collector will be satisfied with
having alter it is tlnnr each time. initially it is 8l92 words. if the total amount of reclaimed
\t0r:tg;e is less tltatt M». the garbage collector will ask the operating system for enough storage (in
lO2-l-\vmr.| hlm-l.sl tn make it up. N 8.: the system may be incivil enough not to grant tlte request: in
that case. the grtrbagc cnllectﬂr will be cotttettt with what it has. unless that is not enough to satisfy
a pr-titling tcqttrst for strnagr-. Then it will infnrnt you that it is losing. A large mm will result in
fewer tntal _qath.~tg;r~ vollectirms. but they will take longer since the total quantity of storage to be
dealt with will t__-<-tier.-ally he larger. Smaller T711775 result in shorter. more frequent garbage collections.
¢.>~/1’ tolls tthetliei tir not l|ll\ gatbagc collection should be ”e.\lt:tttstive". lt is optional. a FALSE by
default The tliffrtettrt‘ ht-ttvt-t-u nnrutal :tnt.l exltaustive "copying" garbage collectiotts is whether
certain Lttttls of \ll>|.tf_'etl|.1l r<‘t|ttire cmnpltcated treatment (for ea-atnple. associations) are reclaimed.
An e\h.1usti\'<- gatli.tt;(- collection: occurs every eighth time that the "copying" algorithm is used. or
when Gt‘. is rallrtl U-llil this rtrgntnrut trite. or when a norntal garbage collection cannot satisfy the
Slﬁfﬂgﬁ l'(‘|]llf'\l
m-.-.-rm; gives the nunilicr nt times the "tttarl-t-sweep" algorithm should be used hereafter for every
little the umntal "top;-ttig;" ahgnritlun is used. Giving O for ms-freq means never to use the "mark-
swecp" al-_'t-tithtu, :tttrl giving <CltlYPl <t1ll.‘> FIX) means (effectively) always to use it. The "mark-
sweep" nlgrvttthtn uses (nnsidt-raltly less processor little than the 'c0pyi|tg" algorithm, but it never
shrinl.s the l'|'t‘t‘-stI\|:|t_'t' pttﬁl. and in fact the pool can becotne fragmented. The ‘marl:-sweep"
algorithm t'ttttltl he useful lll a program systcnt (such as the compiler) where the size of the pool
rarely cltitttges. hut rtltlects are created and thrntvn away continuously.
32.0. §L0g'\vl_
BLOAT is ttsrtl tn (flll\[‘ a temporary expansion of the available storage space with or without
cltaiigittg the garli.1;;r-rnllcrtimt |).'t!;ttttCtr|’\. BLOAT is particularly useful for avoiding unnecessary
garbage collectintts \\'il('ll Inarling a large file. lt will cause (at most) one garbage collection. at the
end nf tvhtclt the .l\'.’Il|Rili[' storage will be at least the amount specified itt the call to BLOAT.
(Unless. nf rmtrse. lltr‘ npciattng system is cranl.y and will not provide the storage. Then you will
get an errrtr. <l»RHl i l> frrtltt Iltis error will cause the BLOAT to return 1, which usually just causes
you tn lose at a later time -- unless the opt-rating system feels nicer when the storage is absolutely
necessary.l
A call In BlO»'\l lnnks like this:
<LlLOAT /fr: slit /rl 5/1) I_\-p slo pstk
rrtfh phi! pt;/b plyp imp pur dpsfk dsl'k>
where all argtttttertts on the first litte above are FIX, optional (0 by default). and indicate the
following:
22.5 - 22.6 Storage Management



F
The l\‘ll)l. l’rrvgianuuing language I97
/fr‘: nnnitmr nt \\‘l'lrliS nf free movable storage desired (for LISTs, VECTORs, ATOMs. etc.)
:.IA: ttlltnhur nl wnrds of free controhstacl. space desired (for functional applications and
bitnltni; of AlOI'l\)
/(/1 nutnln~r of new Hip-l(‘\'l’| LVr'\Ls fnr which to leave space (SETs of A'lOHs which are not
rttirmtllv bnundl
5/1,»: nnmlmr nf new rl\/Al s for whieh to leave space (in the global vector)
/\‘;"I nntnht-r of new TYPE definitions for which to leave space (in the TYPE vectcr)
<10; IllllllilI‘I nt \\‘ﬁ1l|‘< of unnmvahle garbage-cullrctcd storage desired
p'?>.1 lltlltl|)('! of umtls uf (tee ttiterttal-stack space desired (for READing large STRINGs. and
(.1||ltI_Q IﬂllliII(‘\ within thr lllICl'[)fCll‘l' and cotnpilcd programs)
Argninrnts on the st-cnnd line above are also FIX and optional. but they set garbage-collection
parailictcrs p(‘l'Itl.'tII(‘llll)‘. as fnllowsz
mm: as fnr CC
pit/1 nntnht-t nf slnts for LVALs atltlcd when the space for top-level l.VALs is expanded (initially
6-H
pljl1>2lIlllllb(‘l of slnts fnr G\lI\Ls added when the global vector is grown (initially 64)
pI_\p: llltllliIt‘f nt‘ slnts fur TYPCs added when the TYPE vector is grown (initially 32)
I/~02 nutnht-r of words of imtnovable garbage-collected storage added when it is expanded
(initially I01?-1)
pun tutinhcr of \\-nrtls reserved for pure compiled programs. if possible (initially O)
rip-:fk: inns: tlcsirahlv size fnr the internal stack. to prevent repeated shrinldng and GROHing
(i||iti.1ll)- Fill]
d:!»\: must tlcwirable size for the control stack (initially 4096)
BLOAT returns the at-tn.-tl number nf words of free movable garbage-collected storage available when
it is done.
22.6 Storage Management



:08 The MDL Programlnillg Language
IQ
f0
7. 3LO-'-I-$T_/'\T
3LOl\T»$?,'-T -..m hc nwd \\-uh BLQAT :n ‘rune’
f@f‘|\l|l”['ll\?l|!\
6
garbage coilccxor ro parricnlar program
?
L
~S TAT ‘e-"_7."\—.?' ‘.-_.--/»:':.'0r )
full‘ vhv ~  :\:-H mi'mm.\;mn .mnm zha 51.11:‘ 0|“ '~:-tvrzage of MDL The argumen: should be a
UVE'ZT=.‘.'-‘ .-: M-n;‘!\ ;‘T .1n<| ! 7"I'=_ FIX Ix‘ BLO/\T-ST>'\Tdn€§|10!gt'{ an argument. i1 wxll provide us
nun I!‘-JF"’T>‘ I1.» ||||'Hr|n:\'|n|| 1-.~‘urn-rd is as fnﬂows: the firs! 3 clcmems mdicax»: H12 number of
g.1rb.v_-'~ . ~£ '= 'xrv.l'~ -hat ,z.'~.1~u|&m:.1l|lcvn ccrnin causes. and the other £9 give informauon aboul
ccrlnun .u-~.\\ M" \‘ﬁr.1'_'1‘ in 1|;-1/ui:
I uunzhfr -1' ;.|:lv\;'~ ~'-"M '\r\||~ \..:|e'.-ll hv -?‘\.i|.\uat|nn of |uov:\'nk' garba;-.'»-:0llccted slbrage
Z. rli1~r- In --.~|xl--~.. -1‘ <-n|\.|rvX ='nrL~sY
x.,...:
C.
Iv» -H Y :11‘-\\ 1»? '1~g~-11-\ -.'i-LMM -Ptiw-an of cnmrol slacl.(s|
xhiln I1: -»\~:;'iu~.\ 1»; 1"[fIlv.|| '_I:({ﬁr
.-. :l|:'1> In 1\\ v|x‘l:m In’ i/7"" vccrnr
G. rl|1'v‘v!va -\1. 1.; >'|r\|| n: i|||||m\.ihlv_ ;.arh.1i_c-clvilcczcd Jmragc
. In --\~|fln\\ -»(|uk‘rn.1|sr.n-L.
dlllrv bx vnr-rx'Im\ ni lmlh ~|.\<l.s at the sum? ume (rare)
9'.“
Q
‘J. nunmm nf u n|;l\ nf mox-.1hle sIr1r.\;'.'
10. ||\|\nh'~r M‘ \»rml'~ r-:‘ um\,1hh_- \mr.1'_'~: Hard :-mce last BLOAT-STAT
ll. m.1\uuu|n :mml--~r rvl' 1»-unis r-F nxrv-'.\hIc ~20.-.1;'c over existing
1'1 m|mh-- I-|' \\--=-n '\|' '.nr\\'.\hl¢' =:m.1,_~,~ mm smcc \XDL began running
I3. ||m\||nun- \|;-~ HI rmurwi \Yrl(‘L
l-I. ||u\nh1_-r rvf unnl-. nu cnmrnl \l.1(l m use
I5. ll\.'\\ll|\|lXlI\|LL‘H[(fHl1||'1l\({|(lI\\1'\'é'a' r~:-achcd
I6. unnnhr-1 vwl‘ -‘Inn f1-r:np»Ic\-rl IVF-Ls
l7.n||u|1n-r nf :0]--11-\ vl l\/M s e\’|\n||-;
I-B. |\\ln|l|~‘| \-f ~i--:~ 1'--1 ?.\J»'\l,~ m global vetmr
I0. nnmh-sr m‘ (NJ/\L\ r\|s||hg
Y0. numhr-r of <1--:\ {ﬁr IYI‘) s in TYPE vpr:-:\r
‘ll. numln-r -1| Tv'~":'~ L'.\|~I|nQ
'12. nnmhr-r 1-1' uF\rl!\ r-I’ mumm nub: §¢\ri>.\;9~c0|lect9d storage
‘J3. numhvr nf ur\||J'~ of m|um\‘.1hI': Si0l'ﬂ_QC unused
'2-8. $11:-111' l.1|;rw: l|n||sr|I(I'\I1!|;_'||n||§il|l||IU\'Ilbl(‘~5HJf2gC block
'15. numlacr nf \\r\|\|~ r-n |u!er|ml~l.1ck
‘JG. numbvr Hf \»md~ rm |nlul|.1l Mack H1 use
‘Z7. m.1xunu|n urv nf inlcrnal stack evcr reached
22.7 Storage Management



The MDL pI'4'?|;l‘iIl|IlllltIg language 199
22,8. GC-El}
<GC-VON L"[‘d)
("l;arlmt;<~-c<vllt~ctr»r monitor") tlctcrtntncs whether or not the interpreter will hereafter print
infnrinzitmu rm the l(‘IlllllI.'\l wht-n 2 garbage collection starts and ﬁnisllcs, according to whether or
not its ;|tt_'t|tnt‘III ts ttuc. lt returns the previous state. Calling it with no argument returns the
currc-nt \t.1l('. 'l'ht- initial statc is false.
\Vhen l)'|)l|lg is vunhlt-zl_ the "cnpying" garbage collector prints, when it starts:
GIN -'4‘-T"(7/I ::uI;r~l'h.=t~(aused.-alorn
and, when it flIlt\llL's:
GOUT re-rand-:-needed
The “ttiark-s\vrt=|)" gnrlungc cnllrctor prints HSGIN and HSGOUT instead of GIN and GOUT. I
‘._?;1£_l'_&t_-lntrtt Qubrmittntts
Two Slll!R<_ tl(‘\€lIllt‘ll nest. use only part of the garbage-collector algorithm. in order to find lll
pointers tn an ttltjvcli CC-IIIIHP and GC-READ, as their names imply. also use part in order to
translate ht-twr-en MDL objects and binary representations thereof.
223.]. Sll[lSTIlUIE
(SLIBSTITUTE !l5*w:,wn_\' ct/d:any>
returns n/<1. aftrr tnnsing .1 |nini.1lurt' garbage collection to occur. during which Eu references to old
are rltnugrtl so as lI\ ivfcr tn rm». Nt-ulter argument can be of PRIHTVPE STRING or BYTES or LOCD
Or livc on the (‘"lIlII'l stnrl. l|lll(‘sS lmth are of the saute PRIMTYPE. One TYPE uatue cannot be
sttbstitutrtl for nlmtlwr. Ono of the few It-gitintatc uses for it is to substitute the "right' ATOM for
the "wrnn_|_;" mm. :tftr-r Ollt [Sh h:t\'t- been in the wrung state. This is more or less the way ATOHs are
ilttptirifictl lt i\ also usr-ful fnr unliukiug R5UBRs. SUBSTITUTE returns old as a favor: unless you
hang nuto 0/d at that point. it will be garbage.
22.92. PURIFY
<PllRIFY .4/rt. - I . . . an} ~N>
22.8 - 22.9.2 Storage Management
L



T"
200 The MDL Programming Language
rvlnrux its l.|~t .1r;-umeut. .-after causing a n|ini:|u|rc garbage collection that results in all the
.'\|'gll|IIt'tll\ llrcmmng pmc and \l|.1r:ablc. and ignored afterward by the garbage collector. No
.1rgnm<~nt rnu liw nu tlw rmnml Mack or be of PRIHTYPE PROCESS or LOCD or ASOC. Sh '
Iflflg
bntwr-on rv|>1‘rar||\1_j-_s_\ sn-m prnrossm actually occurs after a SAVE, if and when lhv: SAVE file is
RESYOREIJ.
22.9.2 Storage Management
l‘
L



5""?
The M DL l"rngr.1|n|ning Language 201
Chapter 28. MDL as a System Process
This clmpter treats MDI. rrmsidercd as executing in an operating-system process. and interactions
between MDL and nther nperatittg-sysletlt processes. See also section 21.8.15.
231. T 1t1_E
TIHF t.1Lr-s any nnnihrr of argntnmits. which are evaluated but ignored. and returns a FLOAT giving
the nnnihet 0|‘ \('t'n|\ds of (ZPU time the MDL process has used so far. TIHE is often used in
inachinc-lz-\'el tlvbnggging tn cxatnine the values of its arguments. by having MDL's superior process
(say. DD'l')pi.1nt .1 hrcakpoint in the code for TIME.
‘E
23 2 Nun
<UHl\HE>
returns :r STRING which is the "mar nrunc" of M DL's process. This is the "uname' process-control
variable in the ITS vr-rsinn ainl the logged-in directory in the Tenex and Tops-20 versions.
( XUHAHE >
returns .1 STRING which is the "intmntr-rt user name" of MDL's process. This is the "xuname" process-
contrnl v.1ri:zhle in the ITS version and identical to <UNAME> in the Tenex and Tops-20 versions.
<JN/\Hi >
returns :1 STRING \\'|ll\'Il is the “jnb name" of MDL's process. This is the "jnan|e" procr.-ss'conlrol
variable in the l'l‘§ version and the SETH-M name in the Tencx and Tops-20 versions. The characters
belong tn the “~i\hit" or "printing" snbsct of ASCII, namely those between (ASCII '40*> and
(ASCII " 137') |n<‘lnsi\'e.
<XJNAHE >
23 - 23.2 MDL as a System Process
>
I I



202 The MDL Programming Language
returns a Stltlttf. which is the "intended job name" of MDL's process. This is the "x_jnatne" process-
cntttrol v;irial.ile in the ITS versimt and identical to (JNI\HE> in the Tenex and Tops-20 versions.
23.2. Es_i_t.~.
( LOCOIIT >
attempts tn log nnt the |)|'ﬂt‘t.‘\-5 in which it is executed. It will succeed only if the MDL is the top-
lcvel process. that is. it is running tlisowncd or as a daemon. If it succeeds. it of course never
returns. If it tines nnt, it returns FFRLSE ().
<OUII-‘
Cntlscs Mlll. tn stop rtrt|ning_ in an orderly manner. In the ITS version. it is equivalent to a
.LOGOUl l, insttttrtinn. Itt the Tenex and Tops-20 versions. it is equivalent to a control-C signal.
and conltnl pnsw» tn the sttperior process.
<vAt_Rr.t -.r,.-,r_.; or no
("value rt-turn") st-ltlnnt returns. It passes control back up the process tree to the superior of MDL.
passing its .1rgtttn<~nt as a int-ssagc to that superior. If it does return. the value is IFALSE (). If the
argument i\ .1 $191116, it is |)IHsL‘t.| to the superior as commands to be executed. via .VALUE in the
ITS vt-rsinn .-intl I-{SCAR in the Tnps~20 version. If the argument is a FIX, it is passed to the superior
as the "t-fft-t~ti\'e atttlrcss" of a .BRF/\K I6, instruction in the ITS version and ignored in other
V('l'$lOlI'|~
23.4. Inlt‘L-_])rnr(‘s\ Cntttlvtttttivalion
All of the SUUR- in this section are available only in the ITS version.
The IPC ("itttc-r-prnrcss cmnntt|tticatiot|") device is treated as an I/O device by ITS but not
explicitly so try .\tlH: that is, it is nrvcr OP£Ncd. It allows MDL to conttnunicate with other ITS
prncesscs by nicrtns of \['II(|IHg and receiving messages. A process identifies itself as sender or
recipient of .1 tttt~\s.t§;¢- with .1n ordered pair of "sixbit" STRING; which are often but not always
<UNAHE> mm <.ntm1c>. A lnessagt‘ has a "body and a ‘type’.
23.4.1. SEND and SFH[l—\lAIT
<SFND 0!/rrrnl or/tr/n2 body Iype mynamel myname2>
23.2 - 23.41 MDL as a System Process
o
_. 1: l_'
4.



M91. Pro rramtnin 1 Lani vttaqe 203
The .L 5 1» .
(Sklll1—\~l/\IT O//101"] 0!/rt!/12 body lypl: myhﬂmcl my/mum?)
bnth st-ntl an ll‘(I mesmqv tn an)‘ pmrcss that is listening for it as Of/tcrnl olhern2. body must be
either .1 Still-‘JG, nr .1 ttvtttok nf nh_jt~t-ts nl‘ FRIHTYPF WORD. lypc is an optional FIX, 0 by default.
which is |).'\|I of the titfnrtttattmt the other guy receives. The last two argutnents are from whom the
titcssqqc is tn lie sent. These are nptionnl. and <UNftHE> and (JNAHE> respectively arc used by
def.-uth. SFHD it-turns :4 FM SF if no one is listening. while SCND—HAIT hangs until someone wants it.
Bnth return T if \('Illl(‘t'IIll‘ .'trct~|1ts the tttcssage.
211.4 ‘Z. llm " lF‘C" lntrtrttpt
\Vhen vnnt .\ll)l |\|I\t‘('$\ rL'c(‘i\‘P\ an ll‘(I message. "lPC" occurs (chapter 2|). A handler is called
with eitht-r tr-ur rn si\ nrgtttnonts glenttcd front the received message. body. Iypc. olhernl. and
o.'lm»n.? :ttt~ nlw.-tys '~l||\|tli(‘(|. n;,t/ta/rm! and my.-tame? are supplied only if they are not this process's
(UN/\HE > ;ttt\l <JlJi'\Hl >.
There is .1 |tt\|ll»itt ll/\ll[)llR fnr the "IPC" interrupt. with a handler named IPC-HANDLER and 0 itt the
PROCLSS slm The lt:ttttllr'r prints nut on the terntittal the body. whom it is from. the lype if not 0,
and wltnttt it is tn it’ Ilﬂl <1tttftt'.L> <-Jtmtll-.>. ll‘ the Iype is l and the body is a STRING, then. after
the itiessngc int'uttn.\tin|t is printed out. the STRING is PARSEd and EVAl.uated.
23.4.3. I PC—Ol- F
<IPC-Ol'F> stops all listening on the IPC device.
23.4.4. IPC—OH
<tPc-on m,~.mt.=1 nI)'!tan:¢\2)
causes listening tin the lI’(Z tlevice as my/lama] myrta-V1192. If no arguments are provided. listening is
on <UNAHE > <.lHI‘tt>ll'.>. When a message arrives. "Il‘C" occurs.
MDI. is initi:tll_\- |i\l(‘|tit)g as <UHAHE> <JN/\ME> with the built-in HANDLER set up on the 'IPC"
interrupt with :t printity of l.
23.4.5. DEHSIG
( UFNS IG (1/-if‘/t)O/).'_€t'Ilfl:.:>
higttnls to lT§ tutu-ctly. not via the IPC dc.-rice) that the daemon named by its argument should run
now. lt rettttns T if the tlaetnnn exists. IFALSE ()ntlierwise.
23.4.1 - 23.4.5 MDL as a System Process
t



204 The MDL Programming Language
Chapter 24. Efficiency nnd Tastefulness
2-LL Fl'I'icir-nr '
i _~. _.-_)
/\ctu.1lt_\. you |n.\l(‘ MDL prrvgrnnis efficient by thinking hard about what they really make the
interprr-tr-| tl_t'1. and tn.tl ing ||Il‘lIl do loss. Some guidelines. in order of decreasing expense:
(ll Fire \tn|.1gr‘i\ expensive.
(21 (lnlling funrtinnx is oxptutsive.
(3\ FROG and REP!’/\T art‘ expensive. except when compiled.
Explmmtinn:
/ll lltnivrz-~\.-i|',' It‘-1' 1-I‘ free xtruagc (creating ttccdless LISTs, VECTORs. UVECTORs. etc.) will cause the
garbage (4lllf‘( tt\|' in inn I|tﬂ|(‘ nllctt Thii is expensive! A fairly large MDL (for example. 60 000 36-
bit \\ﬂf(l\| rnlt t.tl_t‘ 1r~n \('t.'ﬁ|Ill‘\ nf Phi"-10 CPU time for a garbage collection. Be especially wary of
(‘Ott\lrltclirI||\ 1il.c (0). Fm-ry time that is 1.-\'a|u.1ted. it creates a new om:-element LIST; it is too
easy to “rite with things when they aren't really necessary. Unless you are doing PUTs or PUTRESB
on it. use ‘(OJ |ustr:itl.
(12) S.-til. but true .-\t\r- gt-no|.1lly ignored. If you call a function ottly once. or if it is short (less than
nnc lincl. you rut‘ IIIll\|I bi-ttrr off in spccd if ynn substitute its body in by hand. On the other
h.-ind. you tttny lw nnuh wnrso off in nmdnl.1rity. There are techniques for combining several
FLINCTIOM llllti n||(' RSIIBR (\»ith RSUBR-l-,H‘lRYs)_ either during or after compilation. and for
cliattgattg; ll|llCTIOl'l\ into HAFRO»
(3) PROF. is .-i1|no~.t tI(‘\'t'I |trrt~\~..-try, given (a) "AUX" in FUNCTIONs: (b) the fact that FUNCTIONs can
contain may lIlllll,ll_"| I-I' l'0llH<: (cl the fact that COND clauses can contain any number of FORHs2 and
(dl the fatt th.\t new \.ni.1hlv~. can be generated and initialized by REPEAT. However. PROG may be
useful when nu t‘t'|rn ﬂullrs. to establish bindings needed for cleaning things up or interacting with
a liunmtt.
The use of FROG may ho wrisiblc whcn the normal flow of control can be cut short by unusual
conditimu, kn l|t:‘|! lltt‘ pmgi-.1|n wants to RETURN before reaching the end of the FROG. Of course.
24 - 24.! Efficiency and Tastefulness
Y-
L
'l
H-
I
I-H r
WI
Mn‘
I



F’
The MD]. Prrvgrattttning Language 205
nested comm ritn .'\t't"r\|ttplisI| the same end. but deep nesting tnay tend to make the program
unreadable. For t-\.1|n|>l0:
(PROG (l[MP)
(OR (SP1 llMP <OK—FOR-SIEP-17))
(RETURN .TEHP>>
(ST[P—1>
(OR (SIT TFHP <OK—FOR-STEP-2?>>
<R[IURN .TkHP>)
<SlEP-2))
could ill'~|l‘iIl| he writlrll
(CORD (<OK-FOR—STEP-l?>
<ST[l"— l >
<COHD (<OK—l'OR-ST[P—Z?)
<SlEP—2))>)>
By the way, Rfﬁfrtl is faster than G0 in a PROS. The (GO x> FORM has to he separately interpreted.
right? In incl. if you (1l’g;|lll7l' things proprrly you very seldom need a GO; using GO is generally
COlI$l(.|l‘rt‘t‘| "lmd st)-It-". but in some cases it's needed. Very Few.
In |n;|ny I.’fl\!"\, a RI FEAT can be replaced with a HAPF or HAPR, or an ILIST, IVECTOR. etc. Of the
form
<ILIST .N ’<SET X <0 .X l>>
which goiivrntos an N~t'|r‘nl£‘nl I IST of successive nunibers starting at X+l .
Whether a pmgnnn l'~ itll('lp|(‘l('t] nr compiled. the first two considerations mentioned above hold:
gﬂrhagr t‘l'\||(‘rllﬂt\ and fnnrtinn calling rcntain expensive. Garbage collection is. clearly, exactly the
satnc Ftntrtirm calling is it-lativt-ly more expensive. However. the compiler careth not whether you
use RFr'E»’t1_ GO, FROG, ILIST. NAPF. or whatnot: it all gets compiled into practically the same
thing, |lr\\vc\'rr_ tho RIIPEAY or PROG will be slower if it has an ACTIVATION that is SPECIAL or used
other than lay RFIURH nr AGAIN.
24.l.l E\-ample
There follows an t=\.1|nplc of a FUNCTION that does many things wrong. It is accompanied by
conttnc-||tnry_ and two better rcrsinns of the same thing. (This function actually occurred in
Practice. Noctlloss tn 5:1)‘, n.-uucs arc withhold to protect the guilty.)
Blunt rrnntut-nt: this is terrible. its purpose is to output the characters needed by a graphics
24.1 - 24.1.1 Efficiency and Tastefulness
L



T
205 The MDL Programming Language
u.-r|nin;<| I" in.-aw lines cminecling :| set of pnillls. The poinls are specified by two input lists: X
v l . I ' ‘ ' '
a no-» "nu Y \ .1lur~ '1 he nmpni channel is lhe third argument. The actual characters for each line
are rvlurnml Ill .1 I IST |l_\' the fnnclinn IRANS.
<DEFI|‘JF PLOTVDSK (X Y CHN "AUX" L LIST)
(CON!) ((IJOl <==7 (SET L (LENGTH .X>><LENGTH .Y) >)
<ERROR "ll-TNGTHS NOT EOUAl.">))
(SET IISI (29))
<RL'P[I\l’ ((N l))
<Sl'l LIST (‘.LlSY ‘(TRANS <.N .X> (.N .Y>>))
<(‘OlJ0 ((67 <SET N <+ .N l)) .l_>(RETURN .N>)> )
(RLPEHT ((N 1) (Ll <LLNGTll .LIST)))
<l"RIHC (IKSCII <.H .LIST)> .Cl1N>
(CONE? ((0.7 (SET N (0 .H l>> .Ll>
<RE1URH "DOH[">)> ))
Com incn I s;
(I) L151 i\ nuly Iomprvrnrily n(-cw-$ar_v. ll is _jusl crcaled and lill'I'l lliruwn away.
(2) \'-'<1r<(~, I||(' rrH|\Hu(‘r ('.LIST !<TRANS .. . >) cogies the previous elements of LIST every time it
is e.\'(‘n||ml!
(3) lndc-\ing (lri\\|| xliv olemvnrs nf LIST as III < .N .LI$T> lakes along time, if the LIST is long. <3
. . . > nr <4 ... > l§ llﬂl \\rvr\‘l| u-orrymg abmll. but (10 ...)is.2|1d (100 . . .> lakes quilt 2 while.
Even if ilw inilr~\|u; \\'r‘|(‘ nnl |:l|.1§cxl out. l||(‘ coinpilcr would be happier wills <NTH .LIST .N>.
(4) The \'.1r|.1l|lr' CIIH n ||ni|c::i.~ss;uy if OUTCHAN is bound to lhc argument CHANNEL.
(5) lr is i.iur-|'u| lﬂ r.1lI FHROR i|| iho sninr way ma! F/SUBRs do‘ This includes using an ATOM from
l E
I me RRORS OBLISF (if rune is appropriate) (0 (ell wlial is wrong. and it includes identifying yourself.
So. do il lhis way:
24.l.l Efficiency and Taslefulncu
  l
 
Z
-L:
 
{-
, g
 



Th? M DI. l"rngr.1|nn||||_Q Laligllagc 207
<DFT1NI PIOIVDSK (X Y OUTCHAN)
IULCL ((0HTCHAN) (SPECIAL CHANNEL>)
(COMO (<HOY <:=7 <LEHGTH .X) <LENGTH .Y>>)
<[ﬂROR VECTOR-LENGTHS-DIFFER!-ERRORS PLOTVDSK))>
<FR[H( <ASCIl 29>)
(REFER! ()
(COMB ((EHPIY7 .X> (RETURN “DONE'>))
<R[P[AT ((OL (TRANS <1 .X) <1 .Y))))
<PRINC (ASCII <1 .OL))>
(COND ((EHPTY? (SE1 OL (REST .OL>)>
<RETURN>)>>
(SE1 X (REST .X>>
(SE1 Y <RCST .Y>>>>
Of cnurw. |f you lnnw Imw long is Ihc LIST l|\3| TRANS relurns. you can avoid using the inner
REPEAT lnnp and Iirn-c cxplicil PRINCs for each clcmcm. This can be done even belle-r by using
HAPF , as in I|l(‘ urn \'(‘|\iﬂll. whirli ilncs vxaclly Ilie same thing as Hue previous onz, but uses HAPF
lo do llm RES1ing and lhe mud conditional:
<ncr1uc PLOIVDSK (x Y ourcnnu)
IUICL ((OUfCHAN) (SPECIAL CHANNEL>)
<couu (<uo1 <==v <LEH6IH .x> (LEHGIH .Y>)>
<[RROR VECTOR—LENGTHS~DIFFER!—ERRORS PLOTVDSK>)>
<PR]NC <ASClI 29>>
(HAPF <>
wruucrxon ((xc YE)
<HAPF <> IFUNCTION ((T) <PRINC (ASCII .T>>) (TRANS .XE .YE>>)
.x
.v>
"nous">
'.’~I._?. Cn=:_||i|_|g__:\ Q1§I_i1|_Fv;r_\\1n!iQrdrr
H _\-rm |||||\! ru-.1rr ihr ('|(‘lll(‘|Il§ of a LIST in st-qucncc from ﬁrsl to last. you can avoid copying
1'.|I|n*r nun u-hon adding a Inn-r our xo Ihe cud. One way is to use HAPF or HAPR with a first
.lI|'IllIIl‘|ll nf ,L1’ST: rho ('|('IIlI'Ill\ are put on Ilic cmnrol slack rather than in free storage. until lhe
Imnl call In LIST . If you Lnmv how inany clcmonls there will be, you can pul lheln on the conlrol
\X.'a< L. ynurwlf, Ill a HIP! E built for that purpose. Anolher way is used when REPEAT is necessary:
24.l.l - 24.2 Efficiency and Tastefulness



|'
203 The MDL Programming Language _'
<HLPE/\T ((FlRST (T)) (LAST .FTRST) ...) I
IIDECL ((VALUE FIRST LAST) LIST ...)
<S[l LAST (REST (PUTREST .LAST (.NEV)>>>
(RETURN (REST .FIRST>)
.. . )
Herc. .Lf\5T .'l|\\.‘l)'\ pﬁIl1I.$ in the current last element of the LIST. Because of the order of
i.-valt|.1tio|i.|lii~ <S[l' LAST ...>cn IU ls '
u a 0 be Written (PUTREST .LAST (SET LAST (.NEV)>>.
@iB€"i""!.\'l‘<f SW.-1lz!P_-*
If a Fmiitinn lI\l'\ tlii- i--.1Iiie of .1 fret: variable (<(SVAL unmam/esf:af0m> or <LVAL spec‘/al.~.aI‘om>)
without i-liniiqmg it, the er-inpiled version may he more efficient if the value is assigned to a
tlntntiiy llIl_Sf‘FFi/it f\lOl"l in the Fti|irtini|'s "AUX"
_ . list. This is true because an UNSPECIAL AYOH gets
COlI'l|)i|('t| inin .i \lut mi tl - ' ' '
l(' coiitrril stark. which is accessible very quickly. The trade>off is
prnb:iLily u nrt|i\\liilr~ if :i 1,-v<~<v.i-' is rcfereiicetl innr tl
L‘ ian once. or if an urt/nan:/es! is referenced more
than twice. E.\3lll])|('f
(DE! TNT HM“-LOOKU!‘ (THINGS "AUX" (DB ,DATA—BASE))
ITIFCI ((V/\I.UF) VLCTOR (THINGS DB) <UNSPECIAL (PR
. IHTYPE LIST)>)
<HAPF ,V[CTOR <FUNCTION (T) (HEHO .T .D8>> .THINGS)>
24.-1. C;|l"l|t.'!!_f|lI_U l.nrnl_\'nltit{$_
ln the mii-rpirrrr the ~<~qiit~iirc ,X .X .X .X is slower than .X ,X .X .X because of interference
between the OVAL nnil tV!\l mi-rlinmsins (appendix l). Thus it is not good ta use both the GVAL and
LVAL of the $f\lll(' Atom frvqiiviitly. unless references to the LVAL will be compiled away (made into
control stack |'cfvit'iic(-s).
ii-=s9ff.~s1*&'m_r= L»
24 5 M
It is nit;-ii the r:i\(* that you want tn attach some meaning to each element of an array and refer to
an elemciit inik'pr'mlt‘i|tl' of I ' ' ‘ '
y nt ier elcineiits. Firstly, it is a good idea to use natnes (ATOH.s) rather
than iitci;t~r\ (l'lI~fes m even 0l'FS[Ts) for offsets ' l
I I _ in 0 the array. lo make future changes easier.
Secondly. it IR a qnnil irlea tn use tl G
v ie VALs uf the mime ATOHs to renieinber the actual FIXes. so that
llie /\TOl‘1s can be M/\h‘ll'ESl for the co|npiler's benefit. T|' '
iirdly. tn establish the GVALJ. broth the
24.2 - 24.5 Efficiency and Tastefulness



L
The MIH. l‘rr\gr:t|ntttittt; l.:tng||:tge 209
ittt€rptt'It'r and the cntnpilcr will be happier with (SETS name ollsel) rather thatt (DEFINE nama
("TUl"l_E" T) <o!!4:r'.‘ '.T>>.
'-?_4:§»_L1,l1|v~
There are ‘~(‘\‘('lZl| it-rt_v.\ III Milt. tn store .1 table. that is. a collection of (natnes and) values that will
he se.1rrIu~tI tlttmipitsiitgly, rlinmittg lht: Ltcst way is often dictated by tlte size of the table and/or
the nature of the (n:\ntt'\ .1ntl)\'alnes.
Fnr a '~ttl.1I| tat-Ir-. the tt.1tttt~s nnil \'.1|ucs can be pnt in (separate) structures -< the choice of LIST or
array hvttn; it:-tvtttttttril by volatility and lintitability »- which are searched using HEHQ or MEMBER.
This tttrtltntl 1-. \'l‘h\' s|v.1(t--t-rtictcitt If the table gets larger. and if the elements are completely
nrtlernluli-. .1 (nn|l'nrnt\ vrrtnr t:\tt he tned, Lept sorted. and searched with a binary search.
For :1 lrtrigv t.1htr-_ \\'|it'rr rort-mt.\bly rfftciz-nt searches are required. a hashing scheme is probably
best. Twn mrthnils me at-'.1il:thlr in MDL: associations and OBLI$Ys.
In the rlI\I tni-tltml, PUll"ROl' and GETPROP are used. which are very fast. The number of hashing
buckets is fl\(‘(l l)t|]v|i<.1lt‘s are t-ltntinated by =='I testing. If it is necessary to use =7 testing. or to
find all lltt" rutritw III the tahlc. ynn can duplicate the table in a LIST or array. to be used only for
those |YllI|1(\'~t‘\.
In the \(‘\‘It|tt| Ill('l||!tt|. ZHSCRT and LOOKUP on a specially-bttill DBLIST are used. (If the names are
not Sl'Rtttr;~, they can hr rnnvctted to S‘!RINGs using UNPARSE, which takes a little time‘) The
number nf i|f\\iltl\g hurl:-ts can he cltosen for host efficiettcy. Duplicates are eliminated by =7
testing. M/\l’l-'/R can he used to find all the entries in the table.
2-1.7. Nt~stiinL'
The hr-:\t|t_\‘ nt‘ t|r‘f‘pl_\'-|It‘Rl!‘(§ cnntml strttclttres in a single FUNCTION is definitely in the eye of the
beholder. (PPRIH1, :t pr;--lrmiled RSUBR, finds thent trying. However. the compiler often produces
better (‘l'\(|(‘ ft-nu tht-nil Q ynu don't like excessive nesting. then you will agree that
(SFI X ,..>
(CORD (<07 .X) ...) ...)
looks better than
(COHD (<0? <SET X ...>) ...) ...)
and that
2-1.5 - 24.7 Efficiency and Tastefulness



210
<RCP[AT 
<CONl7 
(... (RETURN lvi>))
. . )
looks In-In-r than
<ﬂl VFAT . . A
(COND .. .
(... (RETURN ...))
(£LS[ ...))
>
You can sun‘ Ilw u.zlurr n
The MDL Programming Language
F Ihl‘ chonccs. .\'es!i||g is .sIiH and all belter than G0.



f’
The M [)|_ Prﬂgfklllllllillg Language 2ll
Appendix 1. A Look Inside
Tl|i.\ app:-ti<ii\ tells ;ihnni ilir ninpping between MDL objects and PDP-l0 storage -- in other words.
ii"; w,1_\- lillllg\ laid. "tin the inside", Ni-nie til‘ this tnfurination is essential to knowing how to
prrigr.-mi in Mill . lint it ilnm give smite reasons for capabilities and restrictions that otherwise you
have in I1t(‘lll"lil(‘ The imi.1tmn mid it-rmmulogy get a little awkward in this discussion. because we
are in R i\iilii_-hi I4'1llf‘|lt‘l\\'l‘l‘ll the \\'(‘llit|\ Dr .\iI)l. objects and of bit patterns. In general the words
and phrases _1p|it-zmiig in tlinqrnitis icfer to liit patterns not MDL objects. A lowercase word (like
"tnplt-"l it-ft-is in the smingc ii<~cii|>it-d by an object of the corresponding PRIr1TYPE(like TUPLE).
First stiinr ii-rmiimliiL_-j, in-rits ilisciissioii. The sine qua non of any MDL object is a in of 36-bit
COllI|)llI(’l \\lYlt|\. In _g<~m-r.il. lists consist of pairs chained together by pointers (addresses), and
\'('k‘lnr'~ \'0ll“-I\l of toiitiqtitms blttt‘l.s of pairs. =='I essentially tests two pairs to see whether they
contain the s.-intr~ liit |\.iltt-ins.
Tim riist (|1I\\l‘I-.‘\\\Iit(’\\('(n \\'ﬂ|(| of .1 pair is called the TYPE word. because it contains a numeric
TYPE rmlc that l('|H("~t‘ll|\ the ob_it‘cl'\ TYPE. The second (higher-addressed) word of a pair is called
the _\3l_it_r;_\;_i:i-5|. |7l‘(.Ill\(‘ it (‘I1lIlRiIl\ (part n|' or the beginning of) the "data part" of the object. The
TYPE wmtl 1.mtl '~ﬂlllt‘lill\(‘\ the vnlne word) is considered to be made of a left half and a right half.
\Ve will pictitie :\ pair like this:
I IYl‘l- I I
i---------------|
[ value I
where .1 \'('|'!lCﬂ| |i:ir m the niitltlle oi a n-rird means the word's lialvcs are used independently. You
can see tli.1t the I‘/l‘t C"lit‘ is cniifmcd to the left Iialf of the TYPE word. (Half-)words are sometimes
siibttivitlril min i'i5tt|_-. .i|i|>mpri.\te for the context: fields are also pictured as separated by vertical
bars. The i-i-__-lit half of the IYPF wrvrtl is used for different purposes depending on the TYPE of the
object :intl artiinl liu-atinn of the value.
Aciit:ill_\- i|ii~ I8-hit tY|'i fir-lit is further decoded. The liigli-order (leftmost) hit is the mark bit. used
exclinii-r~|_y hy the ;i'\lilI\g(‘ cnllectnr \\‘|\l'l) it rmis. The next two bits are inonitor bits. used to cause
"READ" Illlﬂ "\-'f?:ITF" mtt-iriipts on read and write references to the pair. Tlie next bit is used to
diff":-ri~iiti.1ti~ tir~i\\t~i~ii liu i-lrmi-ms .1lIt|V(‘(‘IUt' dope words. The next bit is unused but could be used
in the fmtm~ fnr an "¢~\i-tiilr-" nionitnr The remaining l3 bits specify the actual TYPE code. What
CHTYPE tines is to tn|~i_\- the pair and ptit a new TYPE code in the new pair.
Each (iRI;l Ti't't' tpit~i|rfmi~tl .-intl HtwTYPEs) nnist bvlotig to one of about 25 "storage allocation
classes" (rrnii_;hl_y rt-irirspniitlmi; in .\ll)l. PRtr1iYPEs) These classes are characterized primarily by
the mamier in \\ liich the garbage collector treats tliein. Some of these classes will now be described.
Appendix I



?'
gm The MDL Programming Language
"Otto \\'ntd"
This 11.1“ im huh-t» ;tl| (131.1 that arr not pnitttera to some kind of structure. All cxternal (program-
avatlablu) IYPE\ in thi> rl:\\s are 0|‘ PRIHTYPE WORD. Example:
| FIX I 0 I
t--~------------t
I IDS I
"Two \\’nrd"
The nu-ntllcr- of this K|1'l\\ are all l8-bit pointers to lisl eletttrnts. All external TYPE: in this class are
of PRIHIYPE LIST. E.\att|pl(-2
I IISI I 0 I

I 0 I potrtker I
where notnt.nr i~ .1 pmtttcr to the first Iisl elctttcttt. lf there are no elentettls, pointer is zero: thus
empty nlt_jrrl\ nf l‘RlHTYl‘£ LIST are ==? if tht.-ir TYPEs are the same.
"Two N \\'nnl"
Metnhcn nr I|t|\ 1-1.1“ mo all "<mtutitt_g |-mitttc-rs" to block; of t\vu~word pairs. The right half of I
counting [>1-intm i~ .‘ltt .'|rltIr(\\\. and thv left half I5 the negative of the number of 36-bit words in the
block. (This fntttm: is t.ttlmod tn the PUP-l0 AOBJH ittstructiottt) The number of pairs in the block
(LEHGTIII ix It:\|l' that tttttttltrr, sinrc each pair i> two words. All external TYPE; in this class are of
PRIMTYPE VECTOR. F\:\tttp|t': *
I \/LCTOR I D I
I -?"I(-n1_tt.h I pointer I
wtu.-re lcrlglh is tlm ILHGHI of the VLCIOR and pointer is the l0czliOn of the start (the eh.-men:
stleclc-ri by mt NIH nrgttmcttl Of 1) nf the VECTOR.
Appendix l
T
I



l
T|lL' .\1l)l l’|ﬁ§t:\tnu||ttg l.:|ngtt:|gl‘ QI3
"N \\'nr<t"
This rl,\\\ l\ t||t- \.|ntt“ at tlw |)l'('\'l(1lt\ nnc. t'\(t‘pl that the block contains objects all of the saint
IYPE uithv-nt tiltlttuliml TY|‘L \\r\lll\ Thu TYPE crttlc for all the clentcttts is in vector dope words.
whirlt arr .-it .\IlllIl‘\\('\ just Lirgcr than thc block itsvlf. Thus. any obj:-ct that carries information in
gr-. ‘tYt't “wt! t-ltntnl _L-<- in the hln\-L: PR1HTYF‘Es STRING, BYTES, TUPLE (and the corresponding
|o¢_1;,\-cs l_OC.§, lOL'.l3. LOCl\]. t»RAHi,, and LOCO. All external TYPEs in this class are of PRIHTYPE
UVEClOR_ li\antplc:
| llVl_t'.lOR I O I
1 -lnnrzth l pointer I
whore lnnql.l\ is thr‘ ILIJCIII nf the UVCCTOR and pointer points to the beginning of the UVECTOR.
“Byto Sti|ng“.1nit "(i|m|.u-tu String"
These two tl.t-<r>\ .\tr~ Jllttnsl ith~nttr:il llytc strings arr bytc puintcrs to strings of arbitrary-size
bytes. I‘Rltll‘rl‘t BYIES l\ thv mil)‘ inc-niher of this class. Character strings are byte pointers to
strings nf .-\<.('ll t‘lt.n.1\t('is PRIIITYPE STRING is thr only tnvntbcr of this class. Both of thtse
Classrs (rttt\|\l nf .1 lrngth .1Ilt|-‘I l‘lll’<l0 hytc pnintcr. In the case of character strings. the byte-size
field Ill the ll_\-|<- pmnn-r is .=\l\va)'\ swt-n hIl'> pcr byte (hence five bytes pcr word). Example:
I STRING I length I
I------r---'----I
l l>yLc~potnt.cr |
where lvnrxth I\ thv llttﬁlll of thc- STRING (in bytes) and byte-pointer points to a byte just before
the ht-qittitiut; of the siting (an ILDB insttttction is ttvcdcd to get the first byte). A ttewly-created
STRING .1l\v.t\-- hm 'OiO700' in thc loft h.1ll'ol' byte-pointer. Unless the string was created by
Sl’Nr\Ml' , ltyll‘-Dt'>tttl.t"r" |mint<. to .1 ll\'CCH'H', whcre the clcntcnts (characters) of the STRING are stored.
p:\Ck('<.l Ittgvtltu ftw In :\ wnrtl
“Fran|t"'
This Clitss gin-- thc nu-r prt1_\;r:un .1 h.-tmllc on its control and variable-reference struclurcs. All
(‘XlCl’ll.ll lYl‘l - Ill tl|i\ rlnss :|rr~ of r‘RIr'lTYt‘E FRAME. Three numbers are needed to designate a frame:
-1 nniqnv is-ht! nlvntifying nunthvr. .1 pnintcr lo the l'rante's storage on 2 control stack. and I
pointcr tn the FROCLSS .1\st>ci:xlctI\\'itlitlic fr.-mic. Exatttplcz
Appendix I
k



"Z14 The MDL Prograimning Language
| FRAME [PROCESS-notnterl
l - - - - - - - - - - - - — - - ]
l iinirttit~—i:l I frame-uotnter 1
wlicrr PROCFSS-pr,iintc-r pﬂillls to tlic dope words of a PROCESS vector. and unique-id is used for
valitlatmg; (immig IEGM 7) the frame-pointer, which points to a frame for some Subroutine call
on tlic rumrnl stack.
”TupIt"'
.-\ ttiplo pniittvr IS :4 cnttiitmq pnmlcr tn A vector on the control stack. lt inay be a pointer to the
.'ll'QlllIl(‘Ill\ in .1 Kiiliirmtiitr iir a pnmtt-r gtiicraled by the "TUPLE" declaration iti a FUNCTION. Like
nbjcet- m 11lI'|\lI‘\'|ﬂll\ t‘|J\\. l|l(‘\(‘ fY1)J{‘\I1\ contain a unique identifying number used for validation.
PRIHIYPE TLIPLL i~ the niily mt-tuber Or1ili\ class, Example:
I llIF‘lE I unique-id I
1---------------t
I -Z"l¢"')U" l uoinner I
Otlicr §tni.1i;r ('Il.i~-.<--.
The rest of tho \tt>r.it;c rl.1\~c\ lll(illli(‘ xtrictly internal TYPEs and pointers to special kinds of lists
and \'t‘t.ln|\ lil.t- I-i<.1=i\ .-\ M0:-l\ .miJ »'\SOC>. A pair for any LOCATIVE except a LOCO looks like a
pair for tho (O|lY‘\l1IH|l1lIIL: '~i|1I(ll|l'('. l‘\C(‘|)l of course that the TYPE is different. A LOCO pair looks
like .1 |Il|\il" pail .iiul llt'('t1\ .i wmtl CIIIL1 a Ii.-ill" for its value: the unique-id refers to a binding On the
control ~t.1-cl. nr in the "\__=ti-li.\l stack" if zero Thu; LOCDs are m a sense ‘stack objects" and are more
restrictml |li:m mlici it\(.'\ll\'\"i.
Au OfI‘$ll i» '~ll'\I(‘l1 with 1|lf' lull! X m the right hall’ of the value word and the Pattern in tlie left
half. Qmt-r the l’:itir_-m c.1ii lm t‘ll|lCl’ .1ii ATOM or a FORM. the left lialf actually points to a pair.
\vii' 1 \ n " " ' '
ici |)I!|||l t 11!! .'lllll.'\i i'.'lll\“fl) The Pattern ANY IS recognized as a special case: the left-half
pmiitrr i< rcrn. zmtl iin |i.‘tll' I\1|\rl1» Thus. if you're making the production version of your program
and want in sat-n \ﬂIll(' nnraqr. _vnii can do soiuctliiug liLe (SETS FOO (PUY—DECL .FOO ANY>> for
all OFFSE l\.
Appendix I
X
4
I
I
t
l
1
>
l
t
1
 
1111111111
 
11111
 
11111



‘I’
The MDl. Pr0g1aln111im; Langnagt 215
nsic D.\t.1 ">'I|uct11rcs
B
Lists
List clc-tncnts are pairs linked mg:-tl1cr by the right halvcs of their first words. The list is
tr.-r|nin.1tml hy .1 7ern in the right hall’ of the last pair. For example the LIST (1 2 3) would look
IiLe this:
I LISI I O I
1 - - - - -1 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
--
l 0 I - - - -
-—>| FIX I - - - - -
—->I FIX I - - - - -
-->I FIX I O I
-------  1»---1 1----1 1----1
1 1 1 1 2 1 1 3 1
Thr use nf l3l\tlll(‘l\ tn tic tngrtlmr rlo111<‘n1s cxplaitxs why new eletncnts can be added easily to a list.
how sharing am! CIICIII-'\|Il_\' wmL.c1c. The links go in only one direction through the list. which is
why :\ list v.'.1ttttﬁt hr B/\CKrd or TOPp0d: then.-‘s no way to find the RE$Ted elements.
Since \ntltt' .\i DI \-.1l1|r~s l'(‘d]llll'(‘ :1 wnnl and a half for the value in the pair, thcy do not fit directly
intn list rlmiwnxs. This prnhh-in is solwd by having “deferred pointers". Instead of putting the
datnni (Itl'(‘(lI_\‘ H110 the list ch-inc-nt. a pointer to another pair is used as the value with the special
internal TYt‘[ n[t[P., atttl the real tlatnin is put in the deferred pair. For example the LIST (1
"hello" 3) would lrml. liLc this:
ILISTID I
1-----1 -----  - - - - - - - - - - - - - - - - - - - -
-—
I O I ----—-)I FIX I — - - - -
-->IDEFERI - - - - -
-—>I FIX I O I
-------- -----1----1 1----1 |----1
I 1 I I "'-- I 3 |
. . . . . . . . . . . . _ _ _ . . .
____ | -___------_
I
--------- -- 1
ISTRINBI 5I<—
1 - - - - 1
[byte-pntrl
Appendix l
¥



2l6 The MDL Programming Language
Vectors
A vcctnr is .1 hlncl. nf rmitigimus words. More than one pair can point to the block. possibly at
different pl:n:cs itt the hlncl.: this is how sharing occurs among vectors. Pointers that are different
arise from RFST rtr GROW/BACK operations. The block is followed by two "dope words‘. at addresses
just largrr than thr I.-irgcst address in the block. Dope words have the following format:
/ /
l I
I I
I tyne l grow |
I — — - - - - - - - - - - - - - l
I tenqth I gc I
The Varirttls ficltls have the follotving meanings:
type -- The fmittli hit frnm who loft (II-e "vector bit". 40000 octal) is always one. to distinguish these
\'t'clnf tlnpo \\/KYIUS from a TYPE/value pair.
ll‘ tlm iIII_Y|l-l'\Il|t‘f hit ix Icro, thcu the vector is a UVECTOR, and the remaining bits specify the
uniform IYPI hf tItt' rlomcnts. CHUTYPE just puts at new TYPE code in this field. Each clement
is limitt-tl tn .1 ﬁllf‘-\\lll'|.1 value: clearly PRIHTYPE STR1NGs and 8YTESes and stack objects can't
go in nnil'm|h \'cctr\rs.
If thv ltigli-t-idt-r hit is one and the TYPE bits are lero. then this is a regular VECTOR.
If thv liitgli-miirr hit is nnr .-ind the TYPE bits are ||ot all zero. then this is either an ATOM, a
PROCt.\S_ an /iSOC_ or .1 YEHPLAIC. The special internal format of these objects will be
dcscrihml a l|ttl(' later in this :tppendix.
length >- Tho hi;_h-mttci bit IS the m.1ik bit. uscd by the garbage collector. The rest of this field
spa-cifir-~ thr nnmlmr nf words in thv blo:L. including the dope words. This differs from the
lvtigtli I_'I\'l‘ll in |1.-tits prviltliltg to this vector. since such pairs may be the result of REST
opt-rntinns.
grow -e This is :t<-|n.1lly two llinv-bi! fields. specifying citltcr growth or shrinkage at both the high
and low cntls of the rector. The fields are usually set only when a stack tnust be grown or
shrunk.
gc >- This is used by tliv garbage collector to specify whcre this vector is moving during
C0|Itp2C(in||.
Examples (nnmhvrs in nctall: the VECTOR [l 'bye" 3] looks likc:
Appendix l
7
L
 
lllllllll
| Z  
lllll
 
llll



f
I‘
The M DI. Prngvannnning l.aug||agc 217
|VI:C|OR|DI
I---——-I --------------- --
I -6 I -——-->---——>| FIX I I
-----------  I-----—-I
I 1 I
ISTRINGISI
I-----—-I
I byte pointer I
IFIXI I
|>_._
I 3 I
I/NOODOIOI
I--—----I
I I0 I I
The UVECIOR '[ -l 7 -4! ] lnnks like:
IUVECTORIOI
|------| --------------- --
I -3 I —---~--~--->I -I I
I 7 I
I -4 I
l40000+FIXl0|
1-------I
I 5 I I
Atoms
llllcrnmlly. rnnun arc \|)('ciaI vector-lil c obj:-cl.s. An alrnn contains a value cell (the first two words
of the blnc L. fi|I\'(I in \\'I|(‘lI(-VP! the global or local value of the ATOM is referenced and is not already
there). an OBL I51 pninlcr. and :1 prim nan1c(PNI\r1E). in the following formal:
Appendix I



215 The MDL Programming Language
I tyne l btndid I
| puinznr-to-value I
I oointer-to-OBLIST I
\\—
\\—
print.-name
I(AS(iIl with NUL nndding on end)I
I ATOM I valid-Lyoel
l--'-~----------I
I lr-n nth I qt: I
If the Lynn firhl cnircspnntis to TYPE UHBOUND. then the ATOM is locally and globally unbound.
(This is tliﬂ'<~rr~nt rlﬁlll :t pair. wlirre the santc TYPE UNBOUND is used lo mean nnassigltcd.) If it
corresponds tn IYPQ tOCI (nn internal TYPU, then the value cell points either to the global stack. if
|J1l'll|\(l is rem. m to a l1\\*.t| cmttml stack. if btndid is non-zero. The bindid field is used to verify
whether the lncnl \'.1lnc pnintctl tn by the value cell is valid in the currcnt environment. The
pointr-r-t.n-OBI I51 is pirhvr :t counting pointer lo an oblisl (uveclor). a positive offset into the
"transfer vector" (fm pure l\1'OM<-). or zero. meaning that tltis ATOM is not on an OBLIST. The valid-
tyoe fioltl tells wltctlicr or not the ATOM represents a TYPE and if so tlte code for that TYPE; grow
values are ttt~vt't' ltrcdt-ti for atnnts.
Associations
/\ssoci:tlion'~ are also ~pt‘ci:tl \'t‘t‘t0r-|iLc nhjects. The first six words of the block contain TYPE/value
pairs for lltv ZIEH. IIIUICMOR and AVALUE of the ASOC. The next word contains forward and
baﬂtward pnintcrs in the chain for that bucket of the association hash tablet The last word
contains forward and backward pointers in the chain of all the associations.
Appendix l
7'
Y



T
4iIII____
The P~{Dl. Prngranttning Language 219
I ITFM I
|----------—~---I
| pair I
| motc/ttotz I
I---------—-——--I
I pair I
I AVALUE I
I - - - - - - - - - - - - - - - I
I Dntr I
I bucket.-chain pointers I
I association-chatn aointers I
I ASOC I O I
I — - - - - - - - - - - - - - - I
I l2 octal I gc I
PROCESS?‘-
A PROCESS vcctnr looks exactly like a vector of TYPElvalt|e pairs. It is diffzrenl only itt that the
garbagc rnllcrmr trrnts it tliffcrctttly from a normal vector. and it contains extremely volatile
ittfortnntinu when the PROCESS is RUNNING.
Tcnt|>l:ttc-.
In a tomplztto. tltr |tltt|tlJt‘t in the tynt‘ field (left half of first dope word) identifies to which "storage
alloratintt rl.1-\“ this TEIII"I_I\T[ bulnttgs. and it is ttstd to find PDP-IO instructions in internal tables
(frozen lI\‘(‘\'lﬁ|\I I'm |>mfn|ntIng LEI-'GTlt_ HTH. and PUT operations on any object of this TYPE.
The |!rt'tqr.1ttt\ In Imihl tl|("~t' tables arr not part of the itttcrprctcr. but the intcrprctcr docs know how
I0 ttw thc-in p|nprtl_\'. The crmtptlvr can put those ittstrttctiotts directly in cotnpilcd programs if a
TCHPLAIF is norm FtESTc-dz nl|t(‘t\\'is(‘ it tntttt Ict the interpreter discover the appropriate instruction.
The value wnrtl nf a template pair cnntains. not a counting pointer. but tltc number of elements
that |IJ\'P hm-n RII3lrrI nff in the loft halt‘ and a pointer to the first dope word itt the right half.
Appendix l



220 The MDL Programming Language
The Control Stncl.
Accmiinlamrs \\'illl symbolic names AB. TB, atid TP are all pointers into the RUNNING PROCESS‘:
cmitrrit stacL. AB ("argmiieiit lime") is a pointer to the arguments to the Subroutine now being run.
lt is set up liy the Siitirrmtint--c.1ll ttiediator. and its old value is always restored after a mediated
Subroiitme r.1ll ictmiis. ttl (“tr-tiipnraries base“) points to the frame for the running Subroutine and
also seri-es .-is :\ \1:|i'l. time pointer. The TB pointer is really all that is necessary to return from a
Stibrotttitte -- given .1 \':tlite to return, for example by FRRET -- since the frame specifies the entire
state of the calling rrititine 1l"("tetttporaries pointer") is the actual stack pointer and always points
to the ciiriciit tﬂlt of the crmtinl stack.
W'liilr is-1-'re rm the siitijrct ot arcmtmlntors. we might as well be complete. Each accumulator
cnntains the \;iliie woiil of .1 pair. the corresponding TYPE words residing in the RUNNING PROCESS
vcctnr Wlieii .1 l"llOt'l'SS is ttnt RUNNING (or when the garbage collector is running). the accumulator
ccinieiits .iri- '~|tIIl"tl m the i-ecinr. so that the objects they point to look like elements of the PROCESS
and tlitis .11:-not g.-iili.1_qe-crillcctilile.
/\CClllIIIl|.'lIl'\f'\ A. ll. C. D. F anil O are iiscd almost entirely as scratch accumulators. and they are
not .s:ii-eit ﬁr it-siriieil aci-riss ﬁiihrrmtiite calls. Of course the interrupt machinery always saves these
and all other ;((‘(‘ll|ll|ll.\l(II'$. A and 8 are used to return a pair as the value of a Subroutine call.
Other than that \|\l'('lRl lcature. they are _|i|st like the other scratch accumulators.
H ttttd R are ll'~('tl iit rmming R$llllRs. H i.s always set up to prtittt to the start of the RSU8R's code.
which is aitu.xll_\- _jttst a itttifotin vector of instructions. All jumps atid other references to the code
use M as ;m lIt(l(‘\ register This lIII\l\(‘S tlic code lricatioii-inseiisitive. which is necessary because the
code nvi-cmr will inm~i~ .-irrmiirl. R is set up to point to the vector of objects needed by the RSUBR.
This ."tccntmil.1tr\i is iieccssiiry because objects itt garbage-collected space can move around. but the
p0i|tl('r.s to them m the t’('fl'l'?|lC(' vector are always at the same place relative to its beginning.
FRH is the mti-riiril fiatiic pointer. tiscd in compiled code to keep track of pending Subroutine calls
when the control stat-L i.s lioavily used. F’ is the internal-stack pointer. used primarily for internal
calls in the ilIl(‘f|II'(‘lC!.
One of the nicest fr.-itmes oi’ the Mt)l. envirrmmeiit is the mtiformity of the calling and returning
sequence. .ut Siilmmtmes -- Lintli liuilt-in F/SUBRs and compiled RSUBR(-ENTRY)s ~- are called in
exactly the samr nay .-ind rctiirii the same way. Arguments are always passed oit the control stack
and results .1l\».-iys ctttl up m the same accumulators. For efficiency reasons. a lot of interttal calls
within the mti~i|iir~ter cirrmiireiit the calling sequence. However. all calls tttade by the interpreter
when riinnmg ttser prrigrams go tlirrmgli the standard calling sequence.
A SllhI'"lllill(‘ call is mitintcrl by one of tlirce UUOs (PDP-l0 instructions executed by software
rather tli:m linrilwaie). I-tC/\LL ("MDI call") is used when the number of arguments is known at
assemble or compile time. .-mtl this ntitiiber is less than l5. QCALL ("quick call’) may be used if. in
addition. an RSLIIH-Z(-ENTRY) is being called that cait be called "quickly" by virtue of its having
Appendix l
‘F’
J;



4
l
I
l
l
I
The MDI. Prn_Qratntning Language 22l
special infnrtnatinn in its rt-frrence vector. ACALL (“accuntulator call") is used otherwise. The
general tnethrnt nf calling a Snhrnutine is to PUSH (a PDP-l0 instruction) pairs representing the
argnnn.-nts nntn lhv ct-ntrnl stack via TP and then either (ll HCALL or QCALL or (2) put the number of
argnnients Ill!" :ttt .-terttnntlatnr and ACnLL. Upon return the object returned by the Subroutine will
be in arrntnnlatnis A antl B, antl the arguments will have been POPped off the control stack.
The call it\uli:ttnr sti-res the rnntc-nt.s of P and TP and the address of the calling instruction in the
rurrrnt franic 4|)rti||I(‘(l tn lay TB) It aho stores MDL's “binding pointer" to the tnptnosl binding in
the rnntirvl stnrl ITltr~ hitnlings are linl.ed tngctlicr through the control stack so that searching
through l||t‘tn is tnr-to offirit-nt than looking at every abject on the slack.) This frame now specifies
the entire state nf the cnlh-r when the call necttrrcd. The mediator then builds a t|e\v frame on the
gnnlfﬁl st.-it-l .\tttl st--res a pmntcr hark to the caller's frantc (the cnrrcnt contents of 18). a pointer to
the Sttlnuutinv lwi|v__; ralletl, and the new enntr.-tits of AB, which is a counting pointer to lhe
argttntcnts .'\tt(l is cntnptttod from the infnrtnation ilt tlte HCALL or QCALL instruction or the ACALL
accntnnl.~itnr. TB is then set up to point to the new fratne. and its left half is incremented by one,
making a urn nniqne- -i‘lv The mediator then transfers control to the Subroutine.
A contrnl stack frame has seven tvnrds as shown:
I“""§;I;}"'"I";;§};;i;;;Z"I
i'"LQ§;L;I};“’I'-LZ;l'}§;;;__'I
I"'"_';§;L;;§l';;§;L;Z""__'_I
Ii"'l$l;5';I;;I§;';;ZLZ;Z"""I
I"""""';;§;;'; "" """"'I
I"""“'"‘;;§;;'};"""""_'I
I"";;l;;';;III;;';;$lL;;"""I
The first tlir0t- “mils arr" set up rlnring the (all tn the Snhroutitte. The rest are filled in when this
routine calls ztttrvllmt Snlnnntine. The left half of TB is incremented every titne a Subroutine call
occurs Rllt] is nsi-tl .ts the nntquc—\d for the frame. stored in frame and tttple pairs as mentioned
before. Ohvinn~l_\ this til is not strictly unique. since each 256K calls it wraps around to lero. The
right halt‘ nt“ ll! is rilnays li-ft pointing nne word past llte saved-callittg-address word in the frame.
TP i.s also left pointing at that wind. since that is the top of the control stack at Subroutitte entry.
The argnnn-nts tn the called €ttbrrnttme are below the frame on the control stack (at lower storage
-1ddt'rss(~sl, ntttl the trntpnratics fnr the called Snbronttnc are above the frame (at higher storage
3dLlrP§\t"s). Tlit'\r nrgntttr-tits atttl tr-ntpnraries arc just pairs stored on the control stack wltilc needed;
they are all that remain nf UNSPECIRL values in compiled programs.
Appendix I



T”
222 The MDL Programming Language
The fnlln\vin§_' fugure _\||ﬂ\vs what lhc control slack might look like after srveral Subroutine calls.
/ /
I I
I I
I arus. for S1 I
I I
I frame for S1 I
_ _ _ _ _ _ . . . . . .
__.. . <__
I I
I Lcmns fnr Sl I
I I
I I
I nrgr, for S2 I
I
I fr-amo for S2 I —--
___ _ _ _ _ _ . . _ . . . _
__ < . . _ _
__
I
| t.r~nnr. fr-r 52 I
I
1 M-
1 wl
1 I
1 I
|— |- _
I nrn:~ fnr
I franc fnr S3 I --—-—--
I/I
w
Lnmps for
(non)
The ahnvr f||_'ur<* \lm\\~. l||(‘ fralnc-s all Iinkrd logclhtr lhrongh the control slack (the "execull0II
path"), <0 that ix 1- r.1\f In rrlurn 10 lhr caller of a given Subrnuline (ERRET or RETRY). _
1
Subrnulinc ('\il is nr¢mupIi~.lmd silllpl)’ by llu: call mediator. which loads the righr hall’ of TB from ‘
the pr("\'irv\|s |'r:\\n<‘ pninu-r. rC\lOl’(‘3 the "binding poinu.-r". P, and TP, and transfers control back to I
the ilnlrnrlirm I'nlInw|n_|_; the s.-wcxl callmg addrcss. I
Appendix I
L



7-
The M DI. l‘rn;_-r:tnt|tti|t;; Language 223
I Va riaglqils -.-1'! us 2
All lr\t:tI !\lOtt \-.~iliu-s are kept on the control stack of the PROCESS to which they are local. As
dcsctilmtl ltt'fttr('. the atnnt contains a word that points to the value on the control stack. The
pointer l'~ ;t\'ttt.1Il_\' tn .1 six-word "binding block" on lhc control stack. Binding blocks have the
fnllntvmg l'n|m:tt:
I UIND or HBIND I prev I
I potntcr to f\lOH I
I value I
I-------‘----"-I
| pair I
I clccl I UHIQUB-1d I
I nrovtous-binding I
WIIBFE:
BIND lIl(’.1II\ this is .1 binding for a SPECIAL ATOM (the only kind used by compiled programs).
:|t|(| lltllttﬁ !lI(‘Ill\'~ this is a hinding for an UNSPECIAL ATOM -- for SPECIAL checking by the
intcrpretc-r:
prev pﬂitt1S tn thc clmt-st prev/inns binding block for any ATOM (the "access path" -- UNHIND
nhjtvrts arc also linkrtl Ill this rhainl:
dc-cl pﬁtttts in :tl_1£CL associated with this binding. for SET(LOC) to check:
\tntqttt*—1(li\tt<»t‘<lfnr \'ﬂ|i(lJllOlI of this block: and
DFPVIOIIS-ltllltllnﬂ pﬂiltls tn the closest prt-vinns binding for this ATOH (used in unbinding).
ﬂitttlitttgs rirv gr-|tr~i.1tr~dli_v an internal snlirnntinv called SPECBIND (nantc cotncs front SPECIAL). The
callcr tn 5|‘! tilllrtlt l'LtStlvs Cf\lI\(‘fll|lV(‘ si\-word blorks onto the control stack via TP bcforc calling
SPECBINU. '|‘ht- first wnrd nf c.1rh block contains the TYPE code for ATOM in its left half and all
mics Ill its riight hall. SPFCIZIHII ll\L‘S this hit pattern to identify the binding blocks. SPECBIND's
cnllcr .t|\t1 fills in l|ll' nv~\t thtrc \\-rtrtls and lcavrs the last two words empty. SPECBIND fills in tht:
rest .1lltl |l'2l\‘t'\ llw "htniling pnintcr" pointing at the mptnost binding on the control stack.
SPECBINU ntsn strncs .1 pnintcr to the current binding in the value cell of the atom.
Appendix l
I“



1’
22.; The MDL Programming Language
Unhimlim; 1-. .1\~< "lllpii\|I(‘(l during Snhrnntinr rotnrn. When the previous frame is being restored.
the call nit'tli.1tr\r clivrLs to \t-1' if tho saved “binding poinler“ and the current one are different: if
thcy an-. SPFCSIORF is rallctl. SPECSTORE runs through the binding blocks. restoring old value
pﬂi|Ilt‘l§ Ill .\lﬂllI\ until thr "htnthng pointer" is cquzl to the one saved in the frame.
Ob\'ir>tt-l\' v.-m.-ililv litmlitig is Inme l'"ll\[7llC-'\l(’d than this. because ATOM; can have hntli local and
glnbnl \‘.1luc\ rttttl (‘\('tt ililfrit-nt lm~:tl \-.1lu<~s in diffcnrnt PROCESSes. The solution to all of these
atldivimml pintilmus hrs in the hinclid fichl of the atrnn. Each PROCESS wctor also contains a
ctlrrvul tvintlttl. \\‘lmm-vi-: an AKOHR lncal value is dcxircd. tlic RUNNING PROCES$'s bindld is
cit:-clu-it .‘lk'.\lll\l tti.ii nf tlii-.11mn: ii they .-up the .\.1|ne. the atom points to the current value: if not.
the cunt-nt l‘ROC['Z>S'\ rnutrnl stncl. tntt\t be st-arcltrd In find a binding block for this ATOM. This
blllrlillt: \lllT‘IIXf‘ |uit_lt\’ hr rnllttl '\h.-tlln\\- l.nndnig". The searching is facilitated by having all
bituliti->5 lllilfl s linlt-tl tn;_'('tlit‘|'. Rt‘l't‘1ritt§ tn glnhal variables is accomplished in a sitnilar way.
using .\ vift tntt ||i;i| |~ it-fciimt tn as the "global stack". The global slack has only an ATOM and a I
v:ilti(- slot Int varli \‘.\rt;tbl(‘. sinrc global values never get rebound.
EV/\L uilli ttwprct tn :t tliffcrz-nt rttvirminiciit rnincs sonic additional problcnis. Wliettevcr this kind
of EVA! l\ zlnnc. .1 lunml ||l‘\\' htmlicl is grncratcd. forcing all current local value cells of atoms to
Rp[)(‘;lI in\-.tlttl lr-cal \':tlttc\ ll|ll\I |in\\' be nhtaincd by st-:|rclung the control stack. which is
ineffit it'|t| lﬁllllilllrll tn _||I\| pulling Iltrnt nut of the atoms. (Th: greatest inefficiency occurs when
an ATO!-1‘\ LV/\l |\ ll\'\|‘f nsc-rl twice in a tow in the satnr: environment.) A special block is built on
the cnntinl ~t:i<L and linlt-tl intn the bundling-block chain. This block is called a "skip block" or
"1-nvirnninrnt splirc“. and it clivcrts the "access path" to the new environment. causing searches to
become l'(‘iiIll\'l‘ in this new i-nviron|nent_
Appendix I
L_



The MDL Programming l.:|nguagc 225
Appendix 2. Predefined Subroutines
T|,¢ fnllntvim; |\ :1 very hrief description of all the primitives (F/SUBRs) currently available in
MDL. 'l‘hc-se tlesutptinns are in no way tn he considered a definition of the effects or values
prodm-r-I by the pvimitivrs. They Just try to he as complete and as accurate as is possible in a
single--st.1tr-menu ill-seriptinu. lIr>\vt‘\'('r. because of the complexity of ntost primitives. many
impnrtnnt .1'~\tlttlpliﬁtt\ Jtntl l’(‘\|flCllUll$ have been omitted. liven though all primitives return a
value. smite (|t‘\(ri|1tintl\ mention only the side effects produced by a primitive. because these
priinitiws .1romr\st often usrtl for this effect rather than the value.
A description is given in this fonuat:
name (rttgitnvt.-"71"3)
doe!
English (|(‘\Cl'|])lif\Il
This fmmnt is int:-mlml tn lor-L lite .1 FUNCTION drfittitinlt. omitting the call to DEFINE and all
internal \'.'\Fi.'|lI|t‘\ and cmte. The I7.=’r'L\ is Just the ATOM that is used to refer to the primitive. The
n.-tines nf the !"_r:Q't »'~I'I'- are intended tn be t|ttll‘t|t0|liC or suggestive of their meanings. The doc! is a
FUNCTlON-'~l_ylr' Dttt tr||.1pu~r H) for thr primitivr. In some cases the DECL may look unusual.
bP(‘:\l|\|- it is itttvttrlvti tn convoy inl’nrm.1tion tn a person about the uses of arguments, not to convey
informntimi tn the 2\tl)l interprett-r r-r cnmpilcr. For example. (OR FALSE ANY) is functionally
equiv.-item in Arm‘, hut ll indicates that only the "truth" of the argument is significant. Indeed. the
[OPT . . .1 rnnstrttttiﬂtt is nltrn usrrl illegally, with other elements following it: be warned that
MDL \\-outrt nnt .'lC(‘(‘|1I it An argnuwltt is included in the satne LIST with VALUE (the value of the
pritttili\ e\ lmty if the argument is actu.-ally returned by the primitive as a value. In other words.
IDECL ((VALUf ARC) .. .) implies (==? .VALUE .ARG>.
" ("‘lUl’LC" FACIORS)
IDECL ((V/\lUl) (OR [IX l'l.OAl>
(Ir/\C‘lORS) <lUVLl: [REST (OR FIX FLO/\T>]>)
multiplies alt ar_\;umcnts tngether (arithmetic)
"‘ ("TUPl["' YERNS)
IDECL ((VI\l_U[) <OR FIX FLO/\T>
(TERMS) <TLlPLE [REST (OR FIX FLOAT>]))
ldds all atgtunents together (aritlnttclicl
Appendix 2
L



7
?
\
22‘; The MDL Programming Language
- ("CPI IONI'\l " HIHIIIHU “IUPI L" SUHTR/UIINUS)
5DECl ((V/'\lUI_) (OR FIX FLO/H)
(HIHIIFHK1) (OR YIX FLU/\T>
(SIIIIIIZAIIFIJDS) (TRIPLE [REST (OR FIX Fl.OAT>]))
sllblrnrts nllu-1 .1|§;||nu~||Is frmn firs-I argmncn! (arillmlelic)
/ ("OI‘11O|'J/\l" UIVILIIIID "TUPLK" DIVISORS)
IDECL ((\/AI III’) (OR [IX FIOAT)
(IIIVIFIIHP) <OR PIX l'l.O/\T>
(UIVISORS) <HIPlE [RI-ST (OR FIX FLO/\T>]>)
dividnw firu arg|u||r||1l>y ﬂI|\(‘( argnulelns (ariiliullrlit)
CI7 (HIINIII R)
WDECL ((V/HUI‘) (OR ‘T ‘FF/\LSE ())
(HUHBIR) (OR FIX FLQRY))
Ieils wluvllir-I .1 numhm |\ IFFO (prrdicale)
I7 (NIIHIHR)
IDECL ((VI‘\lUl) <OR ‘T ‘(FALSE ()>
(NIHHHI-4) (OR FIX i'LOAT>)
tells \\'|ll'||Il‘f :\ numlu-r n nu:-(pr1'|Jic:ue)
ISTEP (PROCFSS)
IDECL ((V/\llH PRO(‘|>SS) PROCESS)
causes 2 VROCFSS In Plllrr si||_qlr-slop mode
==? (OHJICT-I Ol'1JfCT~P)
*'DEC\ (IV/HUI) (OR ‘I ‘H/\lSl{ ()>
(OBJ!CI-I OUJECY-2) ANY)
ltlls wlirihrr rum n|)_](‘(‘I§ are "cxac|ly' equal (predicate)
=? (OBJECT-I 0h.u rt-7)
lDECL ((Vl\LUE) (OR ‘T 'IFALSE ())
(OBJECT-l OBJECY—Z) ANY)
tells whcilwr Iwn nhjrcls air ".<rrm-rlir.-ill)" equal (predicate)
ABS (NUHBLR)
IDECL ((V/\l.UC) (OR FIX FLOAT)
(IJIIIIHI R) (OR FIX FlOAT))
rtlurns :ab>nInIe value of .1 nmnbrr (arillmlelic)
ACCESS (CIIANNFL ACCESS-POINTER)
IDECI ((V/\|.Ul CHf\NNl'|) CHANNEL
(ACCESS-POINIER) FIX)
sets acccss pninlcr for nc.\l I/O transfer via a CHANNEL
Appendix 2
L



‘T’
4
I
The M l)l. T'rngr.1mu\||\g lnnglmgc 227
ACTIVATE-(.H4'\RS ("OPTIOH:‘\L" STRTHG)
d[)[C[ ((\Il\l Ill STRTHG) STRING)
sols nr n-nu nk um:-||up| (l|.1r.1<k‘|s fnr11-rminallyping(Tcucx and Tops-20 version; only)
AGAIN (“OT‘T1O|i»'\L" (ACT TVATIOH .LPROG\ !-INTERRUPTS))
00101 (tvnlui) ANY
(/'\(‘TT\If\TTON) ACTIVATTOH)
r(*s\||uc~ v\cruIim| at l|l(' giwu ACTIVATION
ALLTYPFS ()
#DECl. ((\//\llIT) '~'V|'ClOT( [R[ST f\TOH]>)
relurns llm VIC 101% Hf all type ||.1|n(‘s
AND ("/\Ri'-.8“ /\R(3$)
ITDECL ((\/Allll) (OR FALSE /'\HY>
(ARCS) l T51)
compmcs lH\;|r:1| ".1ml"m' |rull|-\'.1|ucs. evaluated by the Subrouline
‘ AND’ ("THP|L" IUVIL)
WDKCL ((V/\l UT) (OR T/HST ANY)
(1uPlL] 1uPLE)
cnmpun-- |r\g|c.1|".1n<l" nl’ tum]:-values. evaluared at call time
AHDU ("TLlI‘Ll " \-IORUB)
l[)ECL_ ((\/AI lH') UORD
(\~lOT-IDS) <TUP|T. [REST (PRTHTYPE HURD))>)
(‘(\lIl|)llll‘> hi\\\~i\c "mud" nf machine words
APPLIC/\l3ll 7 (OILTT CT)
IDECL ((\//H ll!) <Oll ‘T ‘ll/\LSF ()>
(OBJFCT) I\HY)
I tolls whcllmr .'\n;u|nr||l ix :\pp|ical.:|c (prcdicalc)
1
T APPLY (I\PT‘| TCAIKLT "TlJT‘\f" ARGUMINTS)
WDECL ((VI\(.UE') I\NY
(Al"l"l_IlIl\BLE) APPLICABLE (ARGUHENTS) TUPLE)
applies finu :u;;|||m~nr In llm nlhcr arguuncms
APPLYTYPF (TYPF "OPTlOHI\L" HON)
FDECL ((\/I'\l.L|[) (OR ATOM APPLICABLE '#FALSE ()>
(TYPE) RTOM (HON) (CR RTOH /\|"PLICF\BLE>)
lvpecifics or rclurns» hnw a ¢l:|l:\ lypr i\ applied
Appendix 2
~J



T
228 The MDL Programming Language
ARGS (CAI I )
VDECL ((V/\l lll-_) ILIPLE
(CALL) (OR TRM-IE £HV]ROr-‘HENT ACTIVATION PROCESS>)
returns :n|_;u|uru!\ nl’ a givrn ||n4r(‘Iur||r:d Subrmllinc call
ASCII (COIN -OR—C|l/‘\R/\C|LR)
4'DECL ((V/HUI) (OR CH/\Rf\CI[R FIX)
(('()lII —OR-CI!/\RA(‘T[.R) (OR FIX CH/\RACIER))
rvturus (‘ll/KR/\fiH R wnh givrn ,\§(Ill rode or vicc vcrsa
ASSIGNED? (ATOI1 "O['1IOhf\L" EHV)
"DICK ((\!/Hill) (UR '1 ‘"F!\lSI' ()>
(AIOH) f\1L‘/H (FHV) (OR |'Rl\H[ LHVIRONMENT ACTIVATION PROCESS>)
l('|l5 wlu-llu-r an f\IOr1h.1<. .1 Inca] value (pl'Pdi(‘.'\(E)
ASSOCIA1 IONS ()
‘DECK ((\If\llH) (OR ASOF, ‘if/\lSE ()>)
rnlurns llw fun nl-J:-cl m rho ;n\o<‘i.1lio||cl1:\in
AT (STRLICTURIU "Oi‘lIOHAl" (N 1))
'D[CL ((V/\llIl) lO(‘I‘\I1\/l,
I (SIIUICTIIFFD) SIRUCTURKD (N) (OR FIX OFFSET))
rclurus .1 |1‘l1’.1l|\'(‘lﬂllI(‘ Nil: rlrmrul of a slruclure
/\T/\N (NUHIHRJ
4DECL ((V/Hill) IlO!\T
(HllHI1[,R) (OR FIX TLOI\T))
relurln arr r:|u;;<~n( nf .1 numhrr (arillum-tic)
ATOM (PH/\NE)
"D[Cl ((Vf\LlI[') AID-‘1
(l'Hf\fH ) Z‘-IRIHG)
creams nu ATOH with :\ §;i\-en namr
AVALUF (ASSOCIATION)
ﬂDhCl. ((\II\|l|}) ANY
(ASSOCIAIIOH) ASOC)
rclurus xhr "v:|lm~" field of an association
Appendix 2
A



The MDL l’r<\_gr.1|n|ning Language 229
!
BACK (STRUCTURE "OF‘T1OHI\L" PU
IDECL ((V/\LLl[) <OR VECTOR TUPLE UVECTOR STORAGE STRING BYTES TEMPLATE)
(N) FIX
(STRUCHIIZP) (OR <!’RIHTYPE VECTOR> (PRIHTYPE TUPLE>
<PRIP1TYVE UVECTOR> <PRIHTYPE STORAGE)
<l"RlMTYPE STRING) (PRIHTYPE BYTE$>
<PRIl1TYPE TEHI"Lf\TE>>)
r£'pl3(‘E"> \ﬂ||u' vlcnmnls r:-mnvcd from a non-list structure by RESTing and C|1lIlg¢&(0 primitive data
lype
BIND ("/\Rf‘.§" ARES)
IDECL ((\1/'\llIl) /'\HY
(ARCS) (LIST [OVT ATOM] LIST [OPT OECL] /\NY>)
executes srqucmi.-4|1-\|:rcs>ir-us wilhoul providing a bound ACTIVATION
BITS (WIDTH "Ol‘I!OHI\l" (RIGHT-EDGE 0))
VDCCL ((V/'\LU[) BITS
(\-lIl|T|IP.]GllT—[UC[)F1X)
creates a hi! n|a\L fnr PUIHITS and GETETITS
BLOAT ("OF'T1Oll4'\l "
(IF-‘Kl’ 0) (STACK D) (lOCAl.S D) (GLOBALS D) (TYPES O) (STORAGE 0) (P-STACK 0)
MIN hllﬁw-IOCAI (;l1.O\J-GlOilI\L GROW-TYPF GROW-STORAGE PURE P-STACK-SIZE STACK-SIZE)
IIDECL ((\I/KLIIL) FIX
(I'R(_\' SIAUL LOCALS GLOBALS TYPES STORAGE P—STACK MIN GRO\l—LOCAL GROW-GLOBAL
F-ROW-TYPI GROW-STORFTGL PURE P—STACK-SIZE STACK—SIZE) FIX)
allocates vxlrn _\|f\|RgP lr~|npm.1rily
BLOAT-STAT ("(JI‘llO!1/\L" STATS)
FDECL ((Vf\|ll|‘) <lIVl"CTOR [27 l'IXT>
($1/us) <uv&.cTOR [27 /\HY]>)
gives garbage-rnllvclm and unrngc >1.-uisrics
BLOCK (lO0K—lll‘)
4'DECL((\Ii\l_lll lOOK~lIl') (OR OULIST (L151 [REST (OR OHLIST 'DEFAULT>]>>)
SETs OBLISI fnr lunling up A10?’-s during READiug and P!\RSEing
BOUND? (l\|OH "Ol‘11OHl\l" l>HV)
WDECL ((V/\l.|.|E) <OFZ ‘T 'iH’\LSE ()>
(ATOI1) /\lOl"1 (YHVJ (OR FRAME ENVIRONMENT ACTIVATION PROCE$S>)
Ktlls whvrhcr an ATOM is locally hmmd (predicate)
Appendix 2
‘



-  
230 The MDL Programming Language
BREAK -SEQ ((78.1! CT PROCFSS)
4DECl ((V/\l ll! PROM SS) PROCFSS
(OHJ[l_'.1) AHY)
mndifi:-s r\n-unnu \t'q||l'||r(' of anmhcr PROCESS
BUFOUY ("Ol'11OH:\| " (CHI\NHl-l .O\lTCHAN))
#Dl,Cl ((V/\l Ul (THf\HHE_L) CHANHLL)
wrixcs mu all inn-rn.1lMl)L lmffrrs for an oulpul CHANNEL
8YIE—S1ZL (BYHS)
IDFICL ((V/\l|ll) FIX
(HY1LS)YSYTfS)
r(‘luYlI\ snr of h}u~\ In .1 |I)'I(‘-Sffillg
BYTES (SIZE "IUl'LL" El.EHENTS)
ﬂD[Cl. ((V/\l,U[) F>YH'S
(SI/F) IIX (FHMFHTS) (TUPLE [REST FIX]))
crcau-a :\ by!‘--wrung; frnu|1~\phnl :nrg|unen\s
CHRNL IF-‘I ()
‘DfCl ((\I/\l ll!) (l lS\ {RI ST C|IANHLL]>)
rﬂurnx :1 lTS1 of rmrcnlly npcn I/O (ill/\NNCLs
CHANHYL ("Oi‘lIOlJ»'\l" (HODIQ "R[!'\D") "YUPLE" FILE-NAME)
IDECL ((V/ulll) (H/\umL
(HO[Ii;) SIHING (T]LE—HI\NE) TUPLE)
creams :m l|||r‘||)('|\Cd I/O CHANNEL
CHTYPE (011.1!-Ci IYPF-)
lDECL ((VALu[) ANY
(OU-WCT) ANY (TYPE) RTOM)
lIl3Lt‘$ a nmv pair \\-uh :1 givcn data lypr from an old one
CHUTYPE (UVECIOR TYPE)
IDECL ((Vf\lHf UVECTOR) <l"RIHTYP[ UVCCTOR)
(lnw) Almn
clsanngcs the dam type of llne elem:-nls of a uniform veclﬂr
CLOSE (CHANNEL)
IDECI, ((\/AIIIF CH/\NNFL) CHANNEL)
closvs an IIO CHANNEL
Appendix 2



€ Th!‘ M DI. l'rng|an|n|ing Language ZSI
* CLOSURE (FIIHCIIOH "TUI'LE" VI\RIf\BLE5)
IDECL ((\/AL IJF) C LOSURE
(FIIHCIION) IUNCIIOH (VARIABLES) <TUPLE [REST ATOH]>)
"bill(|.\" llm l'|m~ \'.1|i:\l\lv\ of :4 FUHCIKOH in currcnl values
- com) ("m:(.s" r.Lr\u5l'S)
JDECL ((\J/uul) ANY
((‘lf\ll.\l$) <l lSl <l IST (OR FALSE ANY>> [REST <LIST (OR FRLSE ANY)>]>)
e\-aluau-s cnmlninns -'\ll\| wlorlcd expression
CONS (Nil-l—IlI'll[Hl LIST)
IDECL ((V/\l.llE) [151
(Hh\J—ELLl’ll»HT) ANY (LISI) LIST)
adds an (‘|(‘llI(’l|l lﬂ (ho frnnl of :1 LIST _
COS (NLIMRER)
JDECL ((Vf\l_lJC) FLOAT
(HIIHIIFR) (OR FIX TLOI\T>)
rcturln rn-inc~ of .1 lnululrm (arilhmclir)
CRLF ("OPI IOlZf~l_" (CH/\HHEL .OUTCHAN))
WDECL ((VAl ut) '1
(('H/\HHI' L) CHAHNI I )
prinls a \‘.'l|ri:\gv.--rrluru and line-feed via an oulpul CHANNEL
DECL-CHECK (“Ol‘II0llAL‘ SWITCH)
WDLCL ((Vf\lllF) <0R ‘I 'lFI\LSi-. ()>
(SWITCH) <OR FALSE !\HV>)
enables nr |l|\.1\»k-~ lypc-dcclaralimu checking
DECL? (Qlldl-CI I’/\lH RH)
IVDECL ((Vf\l|.lL) (OR 'l ‘I'FI\LSE ()>
(OB-JCCI) ANY (VATTERH) (OR ATOH FORH))
tells whclhcr .1nnh_i<~c| malrluw 2 lypc 1|;-claraliun (predicate)
DEFINE (‘l-lﬂlll; "ARCS" ARCS)
WDECL ((VAl HE) ATOM
(H/U1! ) :'\HY (ARES) (LIST [OPT ATOM] LIST [OPT DECL] ANY>)
sets rho glnlml vallm nf :\n /\l0l-1 In .1 FUNCTION
ocrmxc ('1:/uu ~-m:r..<.'- macs)
vocal ((Vf\llll) mom
(ll/'\l1E) /\.‘lY (ARGS) (LIST [OPT ATOM] LIST [OPT DECL] ANY>)
sets the glnbal valuv nf an ATOM IO a MACRO
Appendix 2
I



I
232 The MDL Programming Language
DEMSIG (N/\H|')
UDFCI ((Ul\\lIl) (OR ‘T ‘iTAlSE ())
(H/\I1[) SIRING)
signals an l'l"~' dncmnn
DIS/\nll (lH|i|-‘H|||'1)
FDICL ((\JI'\\UI IHIERRUPT) IHEADER)
disables an inlr||n|>t
DISHISS (V/\| "OPIKO-‘H\l" ACTIVATION INT-LEVEL)
IDECL ((\IALllE VAL) ANY
(ACIXVIATTON) ACYXVATION (IHT—LEVEL) FIX)
di§II\i\\!‘\ an iulmxupl nrrmn-urc
ECHOPAIR (IH Ulll)
IDCCL ((\/Al UL IN) CIIAHIJEL
(GUI) flllﬂll-'11)
cn0nlin.1\r~< l.'() ( H/\H.‘H Ls Fm crhning characters on ruboul
FMP1Y’ (ORJICI)
lﬁfcl ((\l!\|lll') (OR ‘T ‘IIIHSF ()>
(OUJLC1) STRUCTURED)
lvlls \~'h\'lI-rr :\ \lruruuv.- has zcrn ch-mcnls (predicate)
EN/\Bl_i' (INHHI-!|!F‘l)
WDCCL ((\/f\L\JL INIIRRLIPT) IHE/\DER)
enablcs an mu-runpl
ENDBlOCK ()
‘DECL ((V/HUI) <OR OBIISI <lI$T [REST (OR OBLIST 'D[FAULT>])))
restores ll|(‘ .Ol3l I51 Hm! c-xincd before corrcspondiug call to BLOCK
EH79‘/—LOC (I IHRY)
ODECL ((VALUL) FIX
(K IHRY) R$U!lR—lNTRY)
returns (hr ﬁl'f<r‘l in Ih!‘ rndc vrclor of an RSU|3R—[NTRY
EOVB ("IUf'lE" WORDS)
IDECL ((VALU[') WORD
(UORII3) <1UP(E [REST (PRIKTYPC VORD)]>)
computes binvise ”¢qui\'.1le||cr" of machine words
Appendix 2
. -



T
The M DL I'rn_g|;un|ning Language 233
[RRET ("Ol‘ll0N/\L" \/I\L (FRAME .LERR\ !-IHH;RRUP'lS))
d!D[CL ((V/KLUIT) /'\HY
(VAI) ANY (FRRHI) FRAME)
contiunvs t-\'.1|tt.\tinn from the last ERROR or LISTEN or front 2 given FRAME
ERROR ("Ill|"lE" INTO)
5DLCl. ((V/\lU[_) ANY
(INFO) HIPIE)
stops and tnfmtns usvt nf :tn t-rror
ERRORS ( )
FDFCI ((V/'\llH') OFJISY)
retttrns tho Ont X51 win-rt‘ t-rrnr tnessagcs are located
EVAL (/\NY "OI"lIOH!\l_" THU)
IDECL ((VAl.l_ll) ANY
(IHV) (OR I-RAHE ENVIRONMENT ACTIVATION PROCESS))
evaluates an (‘Xpr(‘s\|m\ in a given (~nvimnnn:nt
EVALTYPE (IYPIZ "OP! {OH/\L" HOW)
JDECL ((VI\l|l£) <C1R ATOM APPLICABLE ‘IF/\LSE ()>
(TYPE) ATOM (HON) (OR ATOM AI‘PLICl\BLE))
spetifies 0| rrtntns how .1 data type is t*v:tluaIrd
EVENT (H/\H[ "O|'l1ONl\L" PRIORIIY WHICH)
IDECL ((Vl\\l|[') IHFADCR
(H/\Htj) <0R SIRIHG ATOH IllEADER> (PRIORITY) FIX (WHICH) <OR CHANNEL LOCA‘l'IVE>)
sets up an intcrrupt
EXP (NlIf‘Hl[\'Z)
IDECL ((\JI\l llf) Tl O/\T
(NUHHKII) (OR FIX FlOI\T))
rotnrns "0" In the |H'\\\‘t‘I of a number (arithmetic)
EXPAND (ANY)
IDECL ((VI\LUE) ANY
(ANY) ANY)
evaln.-ttcs its mgnmrnt (nnly nnrc if a HACRO is involved) in the top-level environment
FILE-EXISTS? ("TUPLE" FILE-NAME)
VDECL ((\//KLLIE) (OR ‘I (FRLSE STRING FIX)>
(F1ll‘-Nl\M[') TUVLC)
(lasts for cxistcttco of a filc (predic.1t9\
Appendix 2
L



T
I
234 The MDL Programming Language
FXLE—L[NGTH (Irwu)
‘DF,Cl ((Vl\Il|| ) I IX
(IHFH) CIh'\HHi_L)
rclurus lh(' ~y\u-m-provided lvnglh of a file open on an input CHANNEL
F ILECOPY ("OPT ION/\l " (INCH . INCHRN) (OUCH .OUTCHAN))
EDECL ((V1'\l.U[ ) T IX
(INCH OUYH) CHANNEL)
tnpirs rh.1|.n|c| s fxrnn mm CIIANHIL In another unlil e|\d~of~file on the input CHANNEL
FIX (Hm-1l3lR)
l'D[CL ((V!\l_llE) FIX
(HIIHRIR) (OR FLOAY F1X>)
returns ||\lvgm |).'\|‘l nf J\ numhrr (ariilnnc-tic)
FLATSIIL (ANY HAY. "Ol"TIOIU\L" (RAUIX 10))
IDECL ((V/\lll[) (OR FIX '.*i'»‘\LS[ ()>
(I\l-IY) ANY (HA)! RI\DI)() FIX)
rt-unrln n||n|l|<-| nl’ <l|:n.\c|\'|'> um-dod (O PRINJ an object, if not grealer than given maximum
FLOAD (" Ill[‘l F " l]lI'-HMH -AND-l.DQK-UP)
IIDECL ((v/um) "'l|Ot:L"
(F ll F -H»'\|‘1F -AND-l OOK-UP) TUPLE)
rend‘ and c\"nlu.1l(~~. all nbjvcls in a film‘
FLOAT (HIIIHH R)
#DECL ((VAlllE) FLOAT
(HHHIIFR) <0R FIX Fl.OAI))
returns flrmrinug-pmnr \'.\l||(‘ nf a number (arithmetic)
FORM ("TU|‘LL" [_LE|'1§H1S)
FDECL ((VI\l UK) iORP1
(FIIHI HIS) H|I’l[')
creates :\ FORM frmn r~\pli¢i! nrgllnlmuis
FRAMT ("OPTION/\L" (FR/\Hi' .LCRR\ !-INTERRUPTS))
IDECL ((\m1m,) IRA!-1|
(FRAME) <OR YR/\HE ENVIRONMENT ACTIVATION PROCES5>)
rﬂurns :\ |ut‘\'inn- Kuhrrulllnc call
FREE-RUN (PROCI SS)
//occL ((v/nun) <o|< mzoccss -ur/use ()>
(PROCESS) PROCESS)
causes a PRO(‘.l.S5 10 Icavc single-slcp mod:
Appendix 2
A



Ir
Th; MDL |'|n§;r.1m|n|ng l.:\nguage ‘Z35
FREEIY (SIIHICIIIRI)
IDECL ((\/I\1lI[) (DIX VLCIOR UVECIOR STRING lSYlES>
(SIRU('.1\lRl ) <0R (PRU-HYPE VECl0R> (PRIMTYPE TUPl_E> <PRIHl'YPE UVECTOR>
(PRIHTYPE STRlNG> <PRIHTYPE BYT£S>>)
lllalu-s cnpy of :ug|u||cm in nmn-moving garbage-collected space
FUNCT (l'Rl\Hl')
JDFCI ((\/Mill) Mon
(I RI\I-ll ) <OR IRAN! ENVIRONMENT ACTIVATION PROCES5))
returns §nl»rm\||nr u:n||v of a given previous Subrouline call
FUNCTION ("/\P.F-S" ARCS)
JDECL ((V/\lUl) FUNCTION
(ARCS) (L151 [OPI ATOM] LIST [OPT DECL] ANY))
crc-airs a FUNCTION
G='! (NLINIH R-1 HIIHIZER-2)
IDECL ((VI\LUEl <OR ‘T ’0FI\LSE ()>
(IILIHIIFR-l NUMBER-2) (OR FIX FLOl\T>)
tells whmhrr fi|'~l zugnrumnl i\ grrnrcr lhzn or ¢qual to second (predicate)
G? (NUMBER-1 NUMBER-Z)
I'DECl ((wu Hr) <0R '1 HVFALSE ()>
(HIIHHI R-l HUl"llIi'R—2) <OR FIX TLOAT>)
tells whether first mgunu-||| is gr:-aler than second (predicate)
GASSIGNIB? (ATOM)
ﬂDEcL ((w\|_|n) <0|z -1 'ar/\LsE ()>
(ATOM) ATOH)
rolls whc|hc| an AIOH has .1 ;;|nb.1lva|uc(prcdicau=)
QBOUND7 (/\1Ol'l)
IDECL ((\m|,u[) (OR ~1 '0?/use ()>
(RTOH) ATOH)
Iells wlu-Ilmr an AIOH rvcr hall a global value (|)r('dic2fe)
GC ("OPl lOH.I\l" MIN (EXHAUSIIVE? <>) MS—FREO)
(OECL ((VA\ HE) FIX
(mu HS-I mo) six (EXHAUSYIVL7) <0R FALSE ANY>)
causes :| g.1|b;|_L'o tI\llm'('li4'\I| and changes garbage-collection parameters
GC-DUMP (ANY I‘RlHlll)
"DECL ((\)/UH!) <OR ANY <llV[CTOR <f‘Rll'lTYPE \(ORO>>>
(ANY) l\l|Y (PRIHIB) <02 CHI\HNl>_L H\LSE))
dumps an ﬂl)_jrc\ w rh.-n in can bc rcpmduced exactly
Appendix ‘Z



T
2,38 The MDL Programming Language
CC-HON ("OPTION/\L" SWITCH)
PDECI ((\/AIIJT) <OR ‘T '4Fl\LS[ ())
(SWITCH) (OR I'/USE /\NY>)
(urns garbngl--rﬂllvtlinuu nnnnilnriug off or on
GC-RF/\n (REAIIB “OPTION/\L" (i'0F—ROUTINE '<ERROR ...>))
‘DECL ((\/Al Ill) /\NY
(RLADU) (‘H/'\HHEL (EOF—ROUTINE) ANY)
inputs :|n H|)|1‘(l Il|.'|l \v,1sprr\'im|sly GC-DUP1Ped
GDECL ("/\R(§$" ARCS)
§DECL ((v/uuf) /'\HY
(ARES) (l [ST [RYST (LIST [REST ATOH]> (OR ATOH FORH)]>)
d¢'cl.'\|r\ Hm I_\|1t‘/\I|||(‘l||rP nf the glnhal valuc of ATOM;
GET (XHH IHUICAIOR "OF‘IIOHAL" (IF—NOHE (>))
IDECL ((V/HUI.) ANY
I (IHH) -’.0R STRIICTURFD ANY) (INDICATOR) (OR FIX OFFSET ANY) (IF-NONE) ANY)
C1085 NTH nr GE TPROV
GET—DECl (l\TOH—OR OT TSFT)
‘DECl ((\//HUI) (OR ATOM FORM '4TAlS[ ()>
I (/‘\|()f‘|-OR—OFF'SiIT) (OR LOCD O¥FSET>)
gels lhc l\ po \|(‘(‘|.'lf.'lIirn| fnr an /\TOM's value or an OFFSET
GETBIIS (I ROI! I I! lﬁ)
FDECL ((Vf\LUl) \-IORTI
(IROH) <OP. <i'RIr1TYl‘E WORD) <PRIHTYPE STORAGE>> (FIELD) BITS)
rrlnrus 2 hi! firlrl nf .1 lIl.'A(‘|||II(‘ word nr STORAGE address
GETL (ITU1 IHHIC/'\IOR "OPTIONAL" (IF—HOHE (>))
ﬂ[‘I[CL ((VAl.UC) <OR IOF-I\TIVE LOCAS ANY)
I (Ill!-1) (OR SIRUCIURLD ANY) (INDICATOR) (OR FIX OFFSET ANY> (IF—NONE) ANY)
does AT 0| GI; TPI
GETPL (IITH INLIICATOR "Ol'IIOI€/\L" (IF-NONE <)))
FDECL ((\//\l(II) <OR IOFAS ANY)
(ITFH IHNICATOR If-NONE) ANY)
returns a |ﬂv.1l|v(‘ In .'||| 3s\0<‘i;Ili0||
GETPROF (IHH IIJTIICAIOR "OPTIONAL" (IF-NONE <)))
IDECL ((V/\LUE) I\HY
(ITEM INDICATOR IF-NONE) ANY)
return» rho \'.1luc awncialrd with an ilcm under an indicator
Appendix 2
L



The MDL Programming Language 237
GLOC (ATOM "OPTIONAL' (MAKE-SLOT <>))
IOECL ((VI\LUE) LOCO
(ATOM) ATOM (MAKE-SLOT) (OR FALSE ANY>)
returns I localivc lo the global-value cell of an A701
GO (LABEL)
IDECL ((VALUE) ANY
(LABEL) (OR ATOM TAG>)
goes to a label and continues evaluation from there
snow (U/VECTOR tun BEG)
IDECL ((VAl.L|f) (OR <PRIMTYPE VECTOR> (PRIMTYPE UVECTOR))
(U/VECTOR) <OR <PRIMTYPE VECTOR) <PRIMTYPE UVECTOR>> (END BEG) FXX)
increases the size of a vector or uniform vector
GUNASSTGN (ATOM)
IDECL ((Vl\LUE ATOM) ATOM)
causes an ATOM to have no global value
GVAL (ATOM)
IDECL ((VI\LUE) ANY
(ATOM) ATOM)
returns rho global valnc of an ATOH
HANDLER (IHEADER HANDLER "OPTIONAL" (PROCESS IPROCESS 0))
IDECL ((VALU[) HANDLER
(Tlll'.ADlTR) [HEADER (HANDLER) (OR HANDLER APPLICA8LE> (PROCESS) PROCESS)
creates an imcurupl HANDLER
HANG ("Ol"TIONAL" (UNHANG <>))
JDECL ((VALUE) ANY
(UNHAHG) ANY)
does nollning. inlcrrnplibly. potentially forever
IBYTES (SIZE LENGTH ‘OPTIONAL’ (ELEMENT 0))
IDECL ((Vl\LUE) BYlES
(SIZE LENGTH) FIX (ELEMENT) ANY)
creates a h)-lc-slring from implicit arguments
IFORH (LENGTH “OPTIONAL” (ELEMENT ILOSE 0))
IDECL ((VALUE) Foam
(LENGTH) FIX (ELEMENT) ANY)
creates a FORM from implicil arguments
Appendix 2
8%
_



238 The MDL Programming Language
ILIST (IENGIII "OPTIONAL" (ELEMENT ILOSE 0))
IDECL ((VALUF.) lIST
(LENGIII) FIX (ELEMENT) ANY)
creates a LIST from implicit argumeuls
IMAGE (CODE "OPTIONAL' (CHANNEL .OUTCHAN))
IDECL ((Vl\LllF CODF) FIX
(CHANNEL) CHANNEL)
studs an imagv-nindc character via an oulpul CHANNEL
IN (POINTER)
JDECL ((Vf\LUF) ANY
(POINTER) LOCAIIVE)
reruriu lhc rllljrcl pninted I0 by a lncalive
INDEX (OFFSET)
ODECL ((VI\LU[) FIX
(OFFSET) OFFSET)
fetches llu: inlrgral par! Of an OFFSEI
INDICATOR (!\SSOCI/XTION)
IDLCL ((Vl\llIl ) ANY
(ASSOCIATION) ASOC)
returns Ihc "indicau-\r" ficld of an association
INSERI (|‘NI\HI; OBI ISI)
IDECL ((VALUE) ATOM
(PNAHE) <OR ATOM STRING> (OBLIST) OBLIST)
adds an AIOM I0 an OBI IST
INT-LEVEL ("0PTIOHAL‘ NEH-INT-LEVEL)
IDECL ((VALUL) FIX
(NE\J—1H1-LEVEL) FIX)
returns and/nr sols current inlvrrupl Iwrvel
INTERRUPT (NAME "TUPLE" HANDLER-ARES)
IDECL ((Vl\lUF) (OR ‘T 'lFALSE ())
(NAME) (OR STRING ATOH IHEADER) (HANDLER-ARGS) TUPLE)
CBUSES an IIHCFIIIPI I0 OCCIIY
INTERRUPIS ()
IDECL ((Vf\LUE) OBLIST)
returns the OBLIST nu which iulerrupl names are kept
Appendix 2
A



‘F
I
The MDL Prn@;r:\n|n\i|\g l:\|n:;|x.1g1.- 239
[PC-HANIIIIR (IZOIIY IYY'| QTHFR-NI'\|‘1[-1 QTHER-NAME-2
“Q|"1XOHf\L" (HY-H:'\HE-I <UNl\HE>) (MY-HAHE"Z <JNAHE>))
IIDECL ((\J/'\l.U[) ‘T
(P,Ol>Y) -IOP. STRING UVCCTOR> (TYPE) FIX
(Ol|HR—H,‘\HI -1 OTHFR-Hf\P1F-P MY-NAME-1 HY-NAME-Z) STRING)
is lhc hnih-|n h.1u<l|vr fnr “lPC" (ITS vcrsmn only)
IPC-OI F ()
‘DECK ((Vl\l|\l) ‘1)
sl0p\ all li\u~ning rm Ila? H‘(Z devict’ (ITS versinn only)
IPC-on ("oI'1m|ml " (MY-H/\-‘1[—l <UNAME>) (HY-N/\HE~2 <JNAHE>))
IDF.Cl ((Vf\l Ill) ‘I
(nY~|;mu -1 HY-uAHi_-2) SIRXNG)
listens on Iht‘ ll'(I ulrvirr (ITS vcrsinn only)
ISTORf\(wk (lEI|(‘l|l “O$‘1IOHf\l" (El£MFNT ILOSE 0))
GDECL ((\//\l LIE) STORAGE
(I l'Hl’.T|I) FIX (FLFHFNT) ANY)
crc.1u~- :\ nnu-;;.1rhn§;r--¢nllrcrml STORAGC from implicit arguments (archaic)
ISTRING (LEHGIH "OPTIONAL" (ELEMENT '\“@))
IDECI ((\/l\lUl) STRING
(IENGHI) FIX (FLEHENT) ANY)
crl.-ales a (‘|II\l;\\‘l("r-'~lrill§ frnm implicnl arguments
ITEM (ASSO("U\1IOH)
JDECL ((\I/HUI) ANY
(ASSOCI/\l1ON) ASOC)
rt.-lurnx Hm "nu-nu" fivhl of an as~nri.1linn
ITUPLE (IIHGHI "O\"lIOHI\L" (ELEMENI ILOSE 0))
IDECL ((Vf\LlJh) HIVLE
(LENGTH) FIX (ElEHEHT) ANY)
creams a HIPII frnm iIII|7|i(‘iI arguments
IUVCCTOR (LENGTH "OPTIONAL" (ELEMENT JLOSE 0))
FDECL ((\//\lUl') HVFCTOR
(IIHGIH) IlX(l|L?1[NT)!‘\NY)
creales :1 IIVLCIOR fxmn i\H|1|i€il a|gu|uents
IVECTOR (KEHGTII "OPTION/\l_" (CLEMENT ILOSE 0))
FDECL ((\/Allll) VECIOR
(IENLIH) I IX (F_lH‘|ENT) f\NY)
creams a VECTOR flmn ilnplicil arguments
Appendix 2
V .l



240 The MDL Programming Language
JHAHE 
'D£Ct ((V/HUI) SIRIHG)
rt.-turtt\ tltt- “_|nh tmntr" llr M [H75 prncrss
L=7 (N\_lrll’-!>_R—1 HUI‘-ULR—2)
wotict ((\1;\t|_|r) <01? 't ‘IFALSE ()>
(Hllllllii(—l rettttftrﬂ-7) (OR FIX FLOAl'>)
tvlls wlu-tltvr l’it~t nrgutm-nt I\ In-.\> than nr equal tn second (predicate)
L? (NUPIBI ll—l HIIHI‘-I R-Z)
‘UECI ((\/Altll) <OR '1 'llf\lSF ()>
(Nllllill ll-1 lllll1B[R-Z) (QR FIX FLOl\T>)
tolls \V||l'||I(‘f [int argtttttrttt is loss than second (predicate)
LEG/\L7 (SI/\( k—O|l-ll (Tl)
I'DECl ((VI\l lII') <OR ‘l ‘IT/\l.§[ ()>
(SIf\CK-OCJFCT) /\HY)
tells wlwttu-| .1|;;uiuvnt (which might live on tltc control stack) is still legal (predicate)
LENGTH (Ql'l.1[l‘.‘l)
IDEQCL ((V!\l|ll ) I IX
(Ol!.\l CT) SIRIICIUHFD)
return- tlu-uutnln-1 rvf rlotnc-ttts. in z structure
LENGl'll" (OUJFCI MAX)
IDECI ((\lI\l|ll) <0tzr1x -4/rnt_5C ()>
(O[lJl>_l‘.l) SIRUCIIIRID (MAX) FIX)
tells tvltctltrr Ii-ngtlt of uructttre is loss than or equal to an integer (predicate)
LINK (LXPR l‘NI\{ll "Ol‘llOH/\l" (OBLIST <1 .OBLIST>))
UDECL ((V/'\lUL' LXPR) ANY
(PH/\l'\[') STRING (OBLISI) ODLISI)
creates :\ syttihnlic I INK tn any expression for READiug
LIST ("ll,ll'LL" LLU-‘-EH15)
IDECL ((v/tutt) LIST
(IIIHIHIS) TUPLEY
creatvx a l IS! ftmn vxplirit argutttcttls
LISTEN ("TUl'l.[" INFO)
4D[CL ((V/\llll') /'\HY
(Into) tut-tr)
stops and ittfnrms user that MDL is lisleuiltg
Appendix 2
Y
T



T
I The MDT. Programming Language
|_|__OC (ATOM "OPTIONAL‘ ENV)
IDECL ((vALu£) LOCU
(ENV) (OR FRAME ENVIRONMENT ACTIVATION PRDCESS))
returns a lncaiivc to the local-value cell of an ATOH
LOAD (CHANNEL “OPTIONAL‘ (LOOK-UP .O8LIST))
IDECL ( (VALUE) ‘ "DONE"
(LOOK-UP) (OR OBLIST (LIST [REST (OR OBLIST 'DEFAULT>]>>)
reads and wnlu.1|r_w :\ll nbjz-r.|s via an input CHANNEL
LOCATIVE? (OBJECT)
IDECL ((VALUE) (OR ‘T 'IFALSE ()>
(OBJECT) ANY)
tells whellver an nbjecl is 2 Iocative (predicate)
LOG (uunncn)
IDECL ((Vl\ll|E) Fl OAT
(NUMBER) (OR FIX FLOI\T>)
returns natural lrvgarillnn of a number (arithmetic)
LOGOUT ( )
IDECL ((VI\LUE) ‘OF/\LSE ())
logs nnl of rhr opcraling syslcm (useful for background processes)
l LOOKUP (rnnns OBLIST)
IDECL ((Vl\LUE) (OR ATOM 'lFl\LSE ()>
(PHAMC) STRING (OBLIST) OBLIST)
returns an ATOM fnnnd on 2 given OBLIST
LPARSE ("OPT ION/\L"
24]
(STRING _l"ARSE-STRING) (RADIX I0) (LOOK-UP .OBLIST) PARSE—TABLE LOOK-AHEAD)
I IDECL ((VA|.UF) LIST
(STRING) STRING (RI\DIX) FIX (PARSE—TABLE) VECTOR (LOOK-AHEAD) CHARACTER
(LOOK-UP) <OR OBLXST <LIST [REST (OR OBLIST 'DEFAULT)]>>)
returns z LIST of Ilic objects parsed from a STRING (sections 7.6.6.3. l5.7.2_ 171.3)
LSH (HCRD AMOUNT)
IDECL ((VALUE) WORD
(T-IORO) <PRIMTYPE UORD) (AMOUNT) FIX)
shifts hits in a lI'|5\(‘llilll‘ \vnrd
l
LVAL (ATOM "OPTIONAL" ENV)
IDECL ((VALUE) ANY
(ENV) <05? FRAME ENVIRONMENT ACTIVATION PROCESS>)
returns The local value of an ATOM
Appendix 2
i
L



<r
242 The MDL Programming Language
MAIN ()
IDECL ((VALUE) PROCESS)
returns (PROCESS 1 (the main PROCESS)
HANIFEST ("lUPLE' ATOHS)
IDECL ((VALUE) ‘T
(ATOMS) <TU|"LE [RES1 ATOH]>)
declares the global values of ATOM; lo be constant
HANIFEST? (ATOM)
IDECL ((Vhl.UE) (OR ‘T 'lF'ALSE ()>
(ATOH) AIOH)
tell» whether the global value of an ATOM is constant (predicate)
HAPF (FlNl\L—TCN LOOP-TCN ‘lUl‘LE" SYRUCTURES)
IDECL ((VI\|UF) ANY
(FINAL-FCN) (OR APPLICABLE FALSE> (LOOP-FCN) APPLICABLE
(STRUCTURES) <TUl‘LE [REST STRUCTURED]))
maps funmtinu mun ricmrttts of structures
HAPLEAVE ("OP‘l'IONI\L‘ (VAL T))
IDCCL (
(VAL) ANY)
leaves tho most rcccnt MA PFIR with a value
MAPR (FINAL-FCN LOO!'—FCN "TUPLE" STRUCTURES)
IDECL ((V/\l UF) ANY
(FIN/\L—FCN) <OR APPLICABLE FALSE) (LOOP~FCN) APPLICABLE
(STRUCTURES) <TUF'LE [REST STRUCTURED]>)
maps function nnto REST: of structures
HAPRET ("TUPLE" ELEHENTS)
IDECL (
(FLCHCNTS) TUPLE)
returns A variable numhrr of objects to the current MAPF/R
HAPSTOP ("TUPLE' ELEMENTS)
IDECL (
(ELEMLNIS) YUPLE)
HAPREB. then Slﬂps looping of MAPF/R and causes application
HAX ("TUl"L[" NUMBERS)
IDECL ((Vl\LUE) (OR FIX FLOAT)
(NUMBERS) <TUPLE [REST (OR FIX FLOI\T>]))
returns the greatest of its arguments (arithmetic)
Appendix 2
A



'.'
L
The MDI l'rn;;r:unmiug Langnagn 243
HE ()
UOFCI ((\II\llI|') PROCISS)
r€l||rn\ lhv currvnt l‘RO('.l*_SS
T1CM[1[R (OHJFCT STRUCIUREJ
JDKCI ((\/Alli!) (Oil $H§UCHlR[D '5F/\LS[ ())
(OBJRCI) ANY (STRUCTURE) STRUCTURED)
tclls whcllu-r an vbjvcl is "stu|cturally“ vqual to some element of 2 structure (predicate)
HEHQ (011.11 rl suwcium)
vDE(IL ((V/HUI’) (OR SIRUCIURED '1Fl\l.SE (J)
(OIXJE FT) ANY (STRUCTURE) STRUCTURED)
tells \\'|ll"‘|l(‘I .'\||I\]1i"tl i\ "o.\att|y" cqual to sonic clement of a structure (predicate)
MIN ("1lli‘l[" IH|I1ULl(S)
»n(ct, ((vm ur) <0R FIX FLO/\T>
(NIIHUI RS) <1llI‘ll' [NFST (OR FIX FLCWT)]>)
returns Il|t' |(‘.'l\l nf |t'~ argnunneuls (arillnmvtic)
HOBLISI (HAHI, "Of‘IlOHAL" (LENGTH 13))
ﬂDFt‘.l. ((\//\| ut) Om 151
(Hl\Hi) AIOH (LENGIH) FIX)
crcntrx or grit» an OLH IS!
HOD (NIIMIU N HOIIIII U5)
4DECL ((V/\| Uk) !lX
(NUIIULR HODLILUS) FIX)
rtlulrns \|||||l||t'|-Iln-rlrvlir rr|\\;\imlt‘r (ﬁxed-point rcsiduc) (arithmetic)
MOHAD? (OBJEC-1)
"DECL ((VI\LUF) (OR ‘T 'ﬂFALSE ()>
(OHJFCT) ANY)
tells wht'tlu"r an nttjvct is eithm ||||\Xruv:lltr€d or an empty structure (predicate)
N==? (Ol3.1['C1~] Ol'!.JFC1—2)
IDECI ((VI'\\lII) (OR '1 ‘FF/\L$F ()>
(Oﬂdl-"C1-I ORJlC1—?) ANY)
tell» wl|t'll:t'r two nh_|t-cu arc NOT "exactly" equal (predicate)
N=? _(()B.1l C1—l Olkli C1-2)
FDECL ((vr\lui) <0rz -1 ‘IF/\LSL ()>
(on.u;c1-1 OBJEC1-2) ANY)
Itlls \v|u'\rl\t~r twn nh_;crts am NOT "srructurally“ cqual (predicate)
Appendix 2



"Y"'
2»!-1 The MDL Programming Language
NE TACC (PH/\HH| l)
*D[Cl ((\//Hill) <OR ('|U'\|lHEL 'lFAl_SE ()>
(Fill-hhll ] CIIIUJIIEL)
-'iCCPpI\ .1 m~xu-mt. cnunlncrxinn
NE TS (f||f\Hl1lL)
‘DY Cl ((\/l\l III ('i|i\H|~H'l) CH/'\NNPl)
fort:-\ f‘I])(‘|.‘lI|||1:<\_\'\l('||| n¢~!\vnrk-C|U\HNFL ln|H'cr to bl‘ srnl
NETS1»'\T[ (CH/\Hf||l)
‘DICK ((\f/\1llI ) <ll\/FCIOR VIX FIX FIX)
(('H/'\HN|,|,) Cl!/'\hh! L)
relunn sI.1rr'|nfv-rmalirm fur :\ uolwnrk CHANNEL
HFUTYPE (JJILJ-I‘|'i’E O|I‘I~IYI'I "OPTIO-‘lI\L" PATYCRN)
5Dl'C| (1,U;'\l ll! |JL\-.'»1\'X‘I~) IHOH
(OllI—I‘:'l'|] IUOH (PATILRN) (OR ATOM FORM))
dcfinz-s .1 uru.» (l.u:~ l\|\(‘
NEXT (f\S.'wO<‘11'\lION)
‘DECl ((\/f\L|lL) 'OR /\SOC ‘NF/\LSE [)>
(ASSOFIAI JON) ASOC)
re|urn\ l|u"n1"\f nh_|v~<r nu rhv :|\'-ﬂrinliﬁxl chain
H[X1FHR ("()I‘II(1lh’\i" ((.HA'\HHiL .If1‘CH/\H) (COF-ROUTINE '(ERROR ...>))
‘DEC! ((\/hill!) <O;-5 C|lf\Pf\CIlR FIX)
((Hf\HHll ) (‘ll/'-Hlill (fOF—ROUTIF-'E) ANY)
rc-n|ru\ rho \|\."\lJC|\'| |h.1rw|lln('.\rb0 rend vna an input CHANNEL
NOT (OILH ITI)
"DEC! ((\I:\|lIl) <OH ‘Y ‘*$l\|SF_ ())
(OUJFITT) (OR Ff\lS[ I\NY))
<‘0l1\p||Iv\ lngiq .11 "||n|" of ,1 lrulh-valm:
mu (3IFu|r1\||ul\ '-0:-now/\1_'~ N)
PDECL ((\//\|ur> mnr
I my <o|z Fxx orFsF_r>)
f(‘Icl|(~'~ I||r- Nvh r~h-u|r~|n of :\ urnrlurr
OBL IST 7 (AIOH)
‘DICL ((\//\|lH) /.ﬁR OHLISI "'FALSC ()>
(Alon) Mm-1)
re-turns .1|| /\IO>1'<» ORLISY or l'.1l\(~ If vmne (prvdicale)
Appendix 2



I
The M DI l‘rrv;;|":n|uni|\_q I.-ungulagc 245
Q?F (XHH iIRlH‘1 “OPTIOHIH " WHICH)
dD['(‘_l ((V/’\I Ill) (OR llf\HDll'R IHFRDLR ‘IWRLSE ()>
(HHLIUIIIPI) (OR H!\HDl£R iHEf\UER STRING ATOM) (HHICH) (DR CHANNEL LOCATIVE>)
remnvrs nu lIIl(‘l|H|H IIAHDI YR or dvwroys an iuhrrrupl
CF? 5l*T (H \‘/\l H HH)
0D£Cl ((\//\l ll!) OI I lwlf
(H) fl! (I‘f\lIl‘RH) (OR ATOM FOR|‘1>)
(I'l‘JH‘\ :\n i\\|r\_'r‘r “uh ;\lla<l|rn! Iypc 4|:-cI:|r.\li0n
OH (N/RH!‘ /\i‘|"l_I1./'\l1ll PRIORITY "OPTIONAL" (PROCESS U) HHICH)
v/DLCL ((w\1m) IIAHULER
(€|.’\HI) (CIR STIIIHG ATO|*1> (f\PF‘lICAU\E) ﬂ\PPLICl\BLE (PRIORITY) FIX
(l‘|l(1Flf~’-S) /OR I-IX !‘ROCLSS> (WHICH) (OR CHANNEL LOCATIVE>)
turns on .||| i|\n~uu|>\ and <-|r.1Iv< an iulcrnupl HANDLER
OPEN ("OI‘IIOf|:'\l" (HUD! "Ri'_l'\D") "IUPLE" FILC—Hl\ME)
HDECL ((\U’\ll|l) (OR (.Hf\HNll <F/\LSE STRING STRING FIX>>
(HOPE) SIRIHEL (l'H.L-H/'\HE) TUPLE)
crcnlrs and ﬂ|)(>||\ .n| I/O CHAHHITI
OPEN-Nll ("Oi'l!OHI\L" (NOW "Rh‘\D“) "HlPLl;" FILE-NAME)
n/DECK ((\/M111‘) (OR CllI\HHEL <fM_S€ STRING STRING FIX)>
(Mom) smnm (FILE-NAME) TUPLE)
creates and II|‘l(‘ll\ an I/O Cll/\HNI L wirhnm changing file's reference date
OR ("/\RCS" /‘\F-‘.GS)
IDECL ((V/HUI‘) <0R I’/\l.SC ANY)
(ARCS) I ISI)
compuu-\ log“-:\l ill(|ll5l\'l'"l'1l'" of uulh-values. evaluated by the Subroutiuc
OR? ("TLIPI I " IIIPI F)
AIDEQL ((\//\llI[) <0R I/USE ANY)
(iurui) Tur'lL')
computes lngiral im hnivc "or" of \r||ll|-valnnra. cv:\luau:d at call time
ORB ("TUPlL" WORDS)
IDECL ((\/ALUL) NOR!)
(LJONUS) <TllF‘L[ [REST (PRIHTYPE NQRD)]))
cn|\|purrw ln|\viu~ invlu-i\-v "ﬁr" nf machine words
OVERIZLOU ("OPTION/\L" SWITCH)
WDECL ((V/Hill) (OR ‘T '1'?/-XLSE ()>
(SUIICH) <OR ANY F/\L§E))
EIHIDIES nr (li\;\hl('\ n\'L-rflmv trrnr farillunclnc)
Appendix 2
4; '



v
246 The MDL Programming Language
PARSE ("(>|~1l0:m| "
(S,IR1H(, ,I'/'\RSl”—STRIHG) (R/\UXX 10) (LOOK-UP .QBLIST) PARSE-TABLE LOOK-AHEAD)
-DCCL (tunnury ANY
(ﬁliilflh) .\lil1|‘iG (R/\DIX) FIX (P/\RSE—T/XBLE) VECTOR (LOOK-AHERD) CHARACTER
(l()’1i\»|;i‘) (Oi! QBLIST (LIST [REST (OR OBLIST 'DEFKULT>]7>)
p:|r'~:-s .1 SIHINL mm an nh_|<-cl fwrlinlls 'I'.G.G.‘2_ l5.7.‘Z. 171.3)
vcour <um:| 01 I xx 1)
rDECL ((\/m nu) I'(Oh[
(lmrll) slmurz (orrssr) FIX)
rrcau-\ |>(\i|lH'| In pull‘ FZSIJRR (‘ml(‘
PHRNL (/\i0§1]
'/DYCl ((\l|\[|H) STRING
(mom) Mon)
rt-Iunn lhv |>|n1l-n.1|||r- nf an !\iO|‘1a\ a dulincl copy
PRIHIYPI (OH-H I l)
am-Cl ((\I/\lll]) MOM
(OU_1L(.Y) /\HY)
rolurnx lhv puunnivc l|.1l.1 lypc of an OLIJPCI
PRIHIYP}-1‘ (Iv:-1)
!Dl'_(,l ((\};'\lHl) ;'RIHIYf‘L'-C
(lYI‘l) RICH)
gvls :1 "um.1\_<‘ .1llm.ninn rmlc" for a data lypc
PRIPH (Oli.1(_(l "(',\i‘!!0H/\\," (CHANNEL .OUTCH/\N))
WDECL (H/r~1ui Olidi c1) ANY
((.H/'\\‘HHi) ("ll/\HN[\)
prints an I\|>>|('(’I \'|:\ .1|\vuIpm CHANNEL
PR INC (Olldfli T "OP! IOIML " (CHANNEL .0UTCll!\N))
wmcu ((\//\l 111 mam r I) ANY
(<'|mm:x1) ('ur\m:l L)
prinl\ :\|| M-_|\~¢\ \-|.\ .m nlllpnt CHArmEL wilhoul STRING or CHARACTER brackets or ATOM trailers
PRINI (OP-.H Fl "(\S'1 1O|iI\l " ((‘Hl\l‘ih'E\_ .OUIClU\N))
FDECL ((\/m LI! or-kn c I) nuv
(l H/'\Hi<'[ L) (,|l/‘\|'lHLL)
prints an (Il1_\:‘Cl vi.-| an nulpnl CHANNEL between new-line and space
Appendix 2



7
The INTDI. Prngramnling Langllagr 247
PRINTB (RTIFTFR CHANNEL)
dDECl ((V/\l\|I' BLIFFER) (<OR UVECTOR STORAGE) [REST (PRIHTYPE HORD>]>
(CH/\NliFl.) CHANNEL)
writes binary infnr|nalion via an nnlpul CHANNEL
PRINTSTRTNG (HUN-LR "OPTION/\L" (CHANNEL .OUTCHAN) (COUNT (LENGTH .BUFFER>))
QDECL ((V/\LUE COUNT) FIX
(BUFFER) STRING (CHANNEL) CHANNEL)
writes rr\nl(~nts nf A STRING via an onlpul CHANNEL
PRINTTYPE (TYPE "OPTIONAL" HOV)
WDECL ((\J/\LUT) (OR ATOM APPLICABLE WIFALSE ()>
(TYPF) I\1OH (HOV) (OR ATOM APPLIC/\8LE))
specifies or rclmns lmw a dala type is primed
PROCESS (STARTUP)
¢DECL ((V/\| lll) PROCESS
(5?/xmur) APPLICABLE)
creates .\ new PROCESS with given slarlup function
PROG ("ARGS“ ARES)
IDECL ((Vf\lUE) ANY
(ARCS) (LIST [OPT ATOM] LIST [OPT DECL] ANY))
QK('c||I0s '~(-qnz-nlinl rxprrssinns
PURIFY ("TlJF‘LE" TUPLE)
IDECL ((\/ALUE) ANY
(TUPIL) TUPLE)
purifies nbjecrs fnr 1-lvarmg by different operating-system processes
PUT (ITEM INDICATOR "OPTIONAL" VAL)
CDECL ((\IA|HF) ANY
(ITF-H) -IOR STRUCTUREO ANY) (INDICATOR) (OR FIX OFFSET ANY) (VAL) ANY) I
slorrs inln slrurlurc ﬁr docs PUTPROP
PUT—DECl (IDENTIFIER PATTERN)
IDECL ((V/\LUE IDENTIFIER) (OR LOCD OFFSET) I
(PATTERN) (OR ATOM FORH>)
changes I||(‘I)'|1(‘ decimation for an ATOHK value or an OFFSET |
PUTBTTS (TO FIELD "OPTIONAL" (FROM 0))
IDECL ((V-ALUE) <PRIHTYPE WORD)
(TO FROM) <PR1HTYPE WORD) (FIELD) BITS)
sets a bit field in a machine word
Appendix 2
E



248 The MDL Programming Langulge
PUTPROP (ITEM INDICATOR "OPTIONAL' VAL)
IDECL ((VALUE) ANY
(ITFH INDICATOR VAL) ANY)
(dishss-ociales a value will: an item under an incliralor
PUTREST (IIEAD TAIL)
IDECL ((VAl UE HEAD) (PRIHTYPE LIST)
(TAIL) <PRlHTYPE LTST>)
replaces the res! of a liar
QUIT ()
IOECL ((VI\LUE) 'IFALSE ())
exits from M DL gracefully
OUITTER (BIAS-TYPED CHANNEL)
IDECL ((VALUE HAS-TYPED) CHARACTER
(CHANNEL) CHANNEL)
is lhe illI(‘rrllp| hannilrr for ‘G and “S quit features
QUOTE ("ARGS' ARGS)
IDECL ((VALUE) ANY
(ARGS) LIST)
re(urn> the first argument unevzluated
RANDOM ('OPTTOHAL' S[ED—l SEED-Z)
IDECL ((Vl\LUF) FIX
(SEED-I SEED—2) FIX)
generates a uniform pseudo-random integer (arithmetic)
READ ("OPT IONI\l '
(CHANNEL .INCHAN) (EOF—ROUTINE ‘(ERROR ...>) (LOOK-UP .OBLIST) READ-TABLE)
IDECL ((VI\LUE) ANY
(CHAHNTL) CHANNEL (EOF—ROUTINE) ANY (READ-TABLE) VECTOR
(LOOK—lIP) (OR DBLTST (LIST [REST (OR OBLIST 'DEFAULT>]>>)
reads one objcrl via an input CHANNEL (sections ll.l.|.l. ll.3. l5.7.l. l7.l.3)
READB (BUITFR CIIANNII ‘OPTIONAL’ (EOF-ROUTINE ‘(ERROR ...>))
QDECL ((Vf\l_UE) FIX
(BUFFER) (<OR UVECTOR STORAGE) [REST (PRIHTYPE \lORD>])
(cununu) cnmuuu (EOF-ROUTINE) ANY)
reads binary infnrmllinn via an inpul CHANNEL
Appendix 2
I
>
IIIIIIIIIII
I



i
The M DL Programming Language 249
READCHR (“OPI1ONI\L" (CHANNEL .INClIAN) (EOF-ROUTINE ‘(ERROR ...>))
IDECL ((VALUE) <OR CHARACTER FIX)
(CIIAHHEL) CHANNEL (EOF-ROUTINE) ANY)
reads one clnaractrr via an input CHANNEL
READSTRING (BUFFER ‘OPTIONAL’ (CHANNEL .INCHAN) (STOP (LENGTH .BUFFER>)
(EOF—ROUTINE ‘(ERROR ...>))
IOECL ((\lALUE) FIX
(BUFFER) STRING (CHANNEL) CHANNEL (STOP) (OR FIX STRING) (EOF-ROUTINE) ANY)‘
reads intn a STRING via an input CHANNEL
REALTIHER ( "OPT1ONAl ‘ INTERVAL)
IDECL ((VI\LUE) (OR FIX FLOAT 'lFALSE ()7
(INTERVAL) (OR FIX FLOAT>)
sets or fetches intcrval for rcal-lilne interrupts (ITS version only)
REMOVE (PH/\HE ‘OPTIONAL’ OBLIST)
IDECL ((VALUE) <OR ATOM WFALSE ()>
(PNAHC) <OR ATOH STRING) (OBLIST) OBLIST)
removes an ATOM from an OBLIST
RENAME ("TUPLE' FILE—NA.HE/S)
IDECL ((VALU[) (OR 'T (FALSE STRING FIX>>
(FILE—HAME/S) (TUPLE (OR STRING CHANNEL>>)
renames or deletes a disk file
REP ()
IDECL ((VALU£) ANY)
is the built-in function for READ-EVAL-PRINT loop
REPEAT ("ARGS" ARCS)
IDECL ((VALUE) ANY
(ARCS) (LIST [OPT ATOH] LIST [OPT DECL] ANY))
executes scqncntial expressions repeatedly
RESET (CHANNEL)
IDECL ((VALUE) <OR CHANNEL (FALSE STRING STRING FIX>>
(CHANNEL) CHANNEL)
reopens an I/O CHANNI-L at its beginning
REST (STRUCTURED "OPTIONAL" (N 1))
IDECL ((VAlUE) STRUCTURED
(N) FIX)
removes the first N elements from a structure and changes to primitive data type
Appendix 2
L



250 The MDL Programming Llngunge
RESTORE ("Oi"TIONAL' NAME-I NAME-2 NAHE—3 NAME-4)
IDECL ((VALU[) "RESTORED"
(NAME-I NAME-2 NAME-3 NAHE—4) STRING)
restores MDL3 slat! from a fik
RESUME (VAT '0PTTONAl" (PROCESS <RESUHER)))
IDECL ((VALUE) ANY
(VAL) ANY (PROCESS) PROCESS)
transfers rxecnlinn Io annvhrr PROCESS
RESUMER ("O$>TIOHAL' (PROCESS <HE>))
IDECL ((VALUE) <OR PROCESS ‘IFALSE ()>
(PROCESS) PROCESS)
returns rhe PROCESS than last resumtd the given PROCESS
RETRY ("OPTIONAL' FRAME)
IDECL (
(FRAME) FRAME)
relries a prev-inns Snbrouline call. usually from the error level
RETURN ("OPIIONAL" (VAL T) (ACTIVATION .LPROG\ !-INTERRUPTS))
IDECL ((VI\LUE) ANY
(VAL) ANY (ACTIVATION) ACTIVATION)
leavcs a FROG/REPEAT Will! z value
RGLOC (ATOM "OPTIONAL" (MAKE-SLOT <>))
IDECL ((VALUE) LOCR
(ATOH) ATOM (HAKE—SLOT) (OR FALSE ANY>)
returns 2 Io¢a|i\'e IO lhe global-value czll of an ATOM for pure-program use
ROOT ()
IDECL ((VALUE) OBLIST)
returns the OBLIST containing names of primitives
ROT (WORD AHOUNT)
IDECL ((VAl,UF) WORD
(WORD) (PRIHTYPE WORD) (AMOUNT) FIX)
rotates bin in a machine word
RSUBR (CANDIDATE)
IDECL ((VALUE) RSUBR
(CANDIDATE) (VECTOR (OR CODE PCODE) ATG1 DECL [REST ANY]>)
creates an RSUBR
Appendix 2
i
I)



T
Th? MDL l'rn!;1an||ni|\g Language: 251
RSUBR-EHIRY (CAHIIIIJATE OFFSET)
QDECL ((V/XLUT) RSUBR-[HTRY
((‘/\Hl)l|)»\l[) (VECTOR <OR ATOM RSUBR) ATOM DECL> (OFFSET) FIX)
adds
an <-uny lminl In an RSUBR
RSUBR—l_THK ("Ul"TIOH»'\L" SWITCH)
‘DY
CL ((VI\l|ll) (OH ‘T ‘WFIALSE ()>
(S\Jlll‘l|) (OR lf\lSE /\HY>)
enablvs ur 1li\;ihl:-- xliv alllnllmlic RSUBR linking feature
RUNINT ("llll‘|l" illl‘l[)
MDECL ((V/\lLll) /\HY
(TUPLE) lllPl E)
:ppli(‘\ inlvnupr lmmllor (Tﬂr inxcrnal usc only)
RUNTIMER (“O1‘TIONI\L“ INTERVAL)
IDECL ((V/\LUE) (OR FIX FLOAT WVFALSE ())
sets nr rm:-hm i||lr"|\':|l frir !lll\-Ii|l|(' interrupt (ITS version only)
(lNlTRVAl) (OR TIX Tl_Ol\T))
SAVE ("TUl‘LC" FlL['-HI\.H[-AHD—GC?)
40[cL ((\JAllll) "‘Sf\\/l'l'|"
(lllh-HAMl—ﬂHh-GP?) <lUPlE Lovw STRING] {opt srnxuc]
[OPT STRING] [OPT STRING] [OPT (OR FALSE ANY>]>)
writes (hr (‘llliIL' \-l.‘|ll‘ 4-T !\ll)L I0 a file
SEND (Ol|llR—lJ;’\Ill -1 Ollll'R—N/'\Hlf—? ll0DY
"Of'TIOfla'\L" (TYPE U) (MY-NA|‘1E—1 (UNAHE>) (HY-NM1E—2 (JNAHE>))
‘DE
CL ((VAllll) (OR ‘T '~'fALSE ()>
(OT|lI’R-Nﬁlll ~1 0llll'R~NI\M[-2 HY—N/\ME—l HY—NAHE—2) STRING (TYPE) FIX
(llOl\Y) <0]; STRING STORAGE <UVECTOR [REST <PRIHTYPE HORD>]>>)
sends an ll’(I llI('\§I\\_'P (ITS version nnly)
SEND-HA1! (OIHIR-NAHI—l OlH[R—HAME—2 noov
"OPIIONAK" (IYPF 0) (HY-NAME-1 <UHAHE>) (HY-NAME-2 <JNAHE>))
IDECL ((\//‘\Ll1[,) -1
(oinln-unnr-1 OTHFR-NAHE—2 HY-NAME-1 HY-NAME-2) STRING (TYPE) FIX
(uouv) <on SlRlHG SIORAGL <UV[CTOR [REST <PRIHTYPE woRo>]>>)
sends an ll’(Z IllP\\.1'::l’ and wnils fnr il Io be received (lTS version only)
SET
(ATOM LVAl "orvlounl" tnv)
IIDECL ((VAl UI lvm) /\r:v
(l\TOl‘l) /\lOH (l:NV) (OR FRf\M£ ENVIRONMENT ACTIVATION PROCESS>)
cliangcs Hm lncal valuc of an ATOM
L
Appendix 2



v
'25‘! The MDL Prograunvniug Language
SEYG (AIOH (.\.'/\l]
IDI CL ((\l/U Hi» (EV/'\l) l'\HY
(IUD?!) /\IOi1)
cl::l|n__;:~s llm L-I1-lml value of an ATOH
$ETl.O( (PUINH R OIMHCT)
4DECL ((\J/\L|JL OBJECT) /\NY
(POIHH Fl) LO(I'\T1VE)
cha|\g;c~\ Ihr (r-nlvluls pnilllrd ID by 2 lncalivc
SIN (HUIHIYR)
l|')E'CL ((\./Al HF) IIORT
(HHIHZI R) (OH [TX llO»‘\I))
returns sum nf :1 numhvr (zunllnnclic)
SLEEP (<OR F IX IIO/1'!) "OPIXONAL" (UNHANG (>))
'DE:Cl ((\/!'\lI|l) I-HY
(UNI!/'\H(§) ANY)
dnvs |\<nh|m_;. mu-||||p\il>l)'. who givcn ||\|n\b('l' of seconds
SHIWH ("()l'l IONA! " il IR! FIORY)
/IDkCl ((Vf\LUk Ull([EiORY) SIRIHG)
acts nr rc-m|n~ ll|(" ah|('(lfIr_\' nnmn mom! by dc-faull for new l/O CHANNEL;
SOR1 [PHI H ki1'-SH-1\|f "Oi‘7iOH/\\“ (RECORD-Ll'_HGTH 1) (KEY-OFFSET U)
"HIP! F" OTHFR-S!RUCS-AND-RECORD—LEHGTHS)
IDECI (\'\/I‘\ll1[ b.?'v'—SH-IHC) (OH <$‘i(IMTYP[ VECTOR) (I-YRIHTYPE TUPLE> (PRIHYYPE UVECTOR>>
(Hilly) -.OFP. IALSL I\I‘l‘lICf\Bl_[> (RE,COR0—LEHGTH KEY-OFFSET) FIX
(Ollll It-5Hill('$-/'\Hl)-RXCORT|~1LNGTH§)
<Hli'lL [i-{L51 <OR <F‘RIHIYPE VECYOR> <PRIl1TYPE TUPLE) <PRlHTYPE UVECTOR>) FIX]>)
s0rt'~ clcunrnn of .1 \I|\|rl|lr:‘ and ncmralngcs other slruclures
SPECIAL-(Ill PK ("(_l$’TIO|l/'\l" SWITCH]
PDECL ((V/\Llli’) (OR ‘Y '*'|'/\lSE ())
(SWITCH) ‘OR f\HY |'l\LS[>)
rurnx i|||vrpn~Ivr \|-r<i.1l-clurrhng nu nr off
SPECI/'\L—llOD[ ("OPIIO|‘Zf\k" SWITCH)
IFDECI ((\/f\\U[) <OR '5X‘lCI»‘\L 'UNSF'ECIAL>
(SWITCH) (UR 'Sl'!'CII\l_ 'UHSPEClAL))
sols spvcinlly &lvrI.1r:\lmn nu‘-d by default
Appendix 2
L



The MDL l‘rrv\;r.1nnniu_r; Language 253
SPNAHE (ATOM)
IDCCL ((\/i\1lI[ ) STRING
(AIOH) AIOM)
returns l||(‘ prinl-na|m~ of an ATOM by sharing il
SQRT (NUIHELR)
FDECL ((VA| lll) Fl0I\l
_ (llllﬂlllll) (OR ll)( I~L0l\T))
returns \qn:u<' um! Of :1 number (arilluuolicl
SOUOTA (SYNHOI )
IDECL ((\//\ll|l) (OR IIX ‘ii/\LSE ()>
(SYHBOI ) (PR1!-HYPE \JORD))
grls Ihc anlllmw nf nu inlcrnal imcrprrlrr symbol (for internal use only)
STRCKI ORII ("I\|lG5" ARCS)
IDECL ((\/./'\LIl[) .l'\NY
(/'\R('-S) LIST]
applicx :\ funclinn I0 Sl.’\(‘l~(‘(|3l’§llIII(‘1IIS(£ll'C|I3iC)
STAYE (F'RO([SS)
‘DCCL ((\//~l.Uf) ATOM
(PIZOCI 55) PROCESS)
returns a PROCESS! curmm male
STRCOMI‘ (5lRlHG—l SlR1NG'2)
IIDLCl ((\l/\llll) (OR '1 '0 ‘-1)
(Slﬂlllfwl SIRING-Z) (OR ATOM STRING>)
comp:\r¢~<. nvn cI|.1|arI<'r-xlrings or lwo priul-names
STRING (“1lll‘l l " I l INHJIS)
QVDECL ((V/\l I15.) SIRIHG
(CLEHHJTS) <'lUF‘L£ [R[ST (OR STRING CHAR/&CTER)]>)
cr4\a|o\ .1 rh:\|.1< lr|'~\!|i|I§ from caplicil arguments
STRUCTURFU7 (OBJECT)
WDECL ((VI\llJF) <OR '1 'rFALSE ()>
(Qll.1F(‘.T) !‘\HY)
tells \vl|vlhvr an ¢\hv|:'<*l ns sIrucl|lr('d(pr1‘dicalv:)
SUBSTITUTY (H|'\-I OID)
¢DECl ((Vl'\ll|l- Olh) ANY
(HEW) /\HY)
subsliluu-s nnc nbjvcl fnr nnmhcr Ill lhe r.-mire address space
Appendix 2
L



25-5
The MDL Programming Language
SUBSTRUC (INCH "Of"llONI‘\l" (RFSY U) (AMOUNT (- (LENGTH .OBJECT> .REST>) TO)
IDECL ((\J»'\lll! IO) <OR IIST V€CTOR UVECTOR STRING BYTES>
(IROH) (OR <I'R1H1YP(-_ lIST> <PRIHTYPE
VECTOR) <PRlHYYPE TUPLE>
<F‘RINlYf'[ UV[CTOR> (PRIHTYPE STRING) <PRIHTYPE BYTES>)
(RLST AHOIHU) FIX)
c0pics(p.1|r -~11 n '~||\|rIn1(' mm aunxhrr
suxcrnr (v/\| '-0:-zzormu (mzocess <RESUMER>))
il')FCI ((w.1n| ) ANY
(\./AL) /u.-r (vnoc1~,ss) PROCESS)
causes l||(‘ \ n||("||X PROCESS lo div and rcsnnl€.\ another
TAG (I/\l§l I )
WDECL ([\l/\\lH) IAG
(LNH 1) AIOI1)
creams :| (AG fﬂr \|'~(‘l1)' GO
TERPRI ("OPT IOI-':'\L “ (CHMJNI L .OUTCH/\N))
WDECL ((Vi\l_Ul) ‘FFALSE ()
(C|li\H;.‘l'l ) (,l|/\HNl L)
prints a c:\|ri.1qr»|c‘rnrn and lino-fund vi: an outpul CHANNEL
TIME ("IU|'l L" IGTJORED)
"D[Cl ((\I/H Ill) [IO/1|
(1r,r:0|:1 I1) mm E)
returns l||t‘ \'I.||v\r~d uxuculicm unw in seconds
TOP (SIRIIFTUIH)
PDECL ((\J/\ll*£ ) 'iOR VtC1OR Il.l$’li UVKCYOR STORAGE STRING BYTES TEHPLATE)
(STRU('TLIRE) <01! (PRIMTYPE V[CYOR> <PRlHTYPE TUPLE>
<PRIHTYf‘E UVITCTOR) (PRIHTYPE STORRGE>
(PR1!-HYPE STRING) <PRIHTYPE BYTES> (PRIHTYPE TEHPLl\TE>>)
replaces all <-lmnvms r('|||r\\'t‘d from a non-list structure by RESTing and changes to primitive data
Iypc
TTYECHO ((IH»‘\!H2il .\\JI1CH)
ﬂDECl ((VI'\LUi. l.'H/'\!ilJF,L) CHANNEL
(SVITFH) <01? FAXSE I\HY>)
turns z-clmin_q mf (h:n.1< zvrs typed nu a lrnninal) On or off
TUPLE ("llI1‘l{~" FHHFPHS)
3DECL ((\/f\l_!_|[) YUPLC
(fl I HFUTS) TUPLE)
create; a HIPLI from (~\pl|ciI argunlcnls
Appendix 2
7



7
Tlm MDL l'mgra\n|uiug Language 255
TYI ("0I>11our\1." Cl|i\HHE_L)
IDECL ((\//\| url cum/\c1r,s:
((‘||Armfl) CllANNll)
iupuls :1 CH/\Hf\CHR (mm .1 u-ruuiual immediately
TYPE (OBJl'C‘l)
IDECI ((VI\lL||) AIOH
(0B.1u:1) ANY)
rﬁlurns l||z‘ (Lam lypv of au nbjccl
TYPE-C (|\'l"l “Ol’l lOHl\l" PRIHYYPE)
IDECL ((V/\l l|l') lYl'[—C
(FYPY l"RIllTVl‘lQ) ATOM)
lI\3Ll‘\ ;\ l|Al.1—l}‘\(‘ rmlc for plnrr-progr:|u\ use
‘l'YPE—\J (‘lYl'L "Ol‘llQNI\L" PRIHTYPE RIGHl—HkLF)
IDECL ((\/fxllJI') TYFT-U
(lYl'l l'l(]HlYPl'_) ATOM (RIGllT—llALl') <PRIHTYPE UORD>)
nunkos :\|ln1:\-lypz-m:n-hiur word for pure-program use
TYPE? (OUJLCI "ll|l“L[" TYPES)
#0EcL ((\!r\|||l ) <01! ATOM 'r'FALSE ()>
(Ol3Ji_(li) /\NY (IYPLS) (TUPLE ATOM [REST »'\TOH]>)
tells \»l|<'llmr .1u<vl|_jvcx's \l.1l:| lypc is one of the given types (predicate)
TYPEPRIH (l\'l'l")
0DECL ((V/'\L||L) /\lOl-1
(IYPE) I\'lOll)
returns :4 1131.1 l)/pr'§ plllllilivl‘ l)'p('
ura/ma ()
IDECL ((\//\LLll';l smtuoa
rclurn\ llm "rum |\:\|nr'“ rvf MllL‘s |)l'0(C'>S
UNASSICH (A1071 "OPTIOHf\L" EHV)
IDECL ((V/Kl lI[ ATOI1) /\TO§"|
(i'|l\!) (OR l'RI\l"1|" FHVIROIJHENT ACTIVATION PROCES$>)
causes :\u /\lOH lnl|:<\‘z~ un lnr.1l\'aluc
UHHANITCST ("TLlPl[" AIOMS)
FDECI ((\/!\lll[) '1
(IHOHS) <lUPLL [RESI A10-‘1]>)
declares Ilm glnlml values of ATO|‘1sur>\ l0 be cnuslauls
Appendix 2
L



‘Z56 The MDL Programming Language
UHVARS! (OH-H CT "O|"IiONI\L" RRDIX)
v'D[CL ((\/mu!) SIRIUS
(OUJITT) ANY (RAUIX) FIX)
creams :1 F-Htlrm r(‘pr(‘\('lII;\1|ﬂIl nf an objccl
UNHINU (‘HOIU1/'\l 'C\ [/\N—UP)
oDECL ((V/\| :11) ANY
(NOIH1/\\ FLL/\l'<'—Uf‘) ANY)
spccifm- 1h'.'\u|||;;-|||) dunng un|\-Inca] relurn
UTYPE (UVLCIOR)
IDYCL ((\Il'\l\ll) /'\IOH
(HUIFIOH) <I‘RHHYPE UVkC1OR))
rcunn- l||l' :l.u.1 I)'|\(' nf all vk-n|om~ of a uniform veclor
U\/CCYOH ("1Ui‘ll" ill HFHIS)
l'lJ&CL (tvm Ill) Hm (,10R
(KLLHI HIS) TUPLE)
crcau-s .1 HVI (I011 hnm (‘\Pli(‘H :Irgu|m‘|\ls
\II\L IO-TYPL7 (IYl‘[)
3D[CL ((V/\LlJl') 40R TYPE-C 'ﬂFl\LSE ()>
(TYPF) mom)
lelh u-I-1~v|-m .1“ /\iC'I1|<lh('n;\|nr: uf a Iypc‘ (predicate)
V;4LR[T (H! $51361 ]
4Di-‘Cl ((vm|u J '-rmst ()
] (NI ssnm) <oR STRING FIX>)
p3!s'a(‘\ R lI|(’\'~.H__'(‘ In I|l(' \|l|H'l’lnl' €‘l|)('fI!\ill§:-5)'.\|CIll p\’DCP5$
VALKIF (AIOH "O|'liOf.‘Al " IHV)
PDCCL ((V/'\| Hi-) ANY
(ATOM) A30?! (ENV) (OR FRAME ENVIRONMENT ACTIVATION PROCESS>)
returns xhr Sm-.1l -n 1-l\(' lllt‘ global value of an ATOM
VECYOR ("|lH‘lI " ilflli HIS)
"DECl ((\II\l_U[') VLCIOR
(I IIHI H75) Tlll"lF)
creams 2 V! CIOH from ('\|1H(‘iI .1r§nnu-Ills
XJNAHE ()
IVDECL ([\JALI_l[') STRING)
returns Il|(' “inlr‘|uh-:| Jnh name" nf MI)l.'s process
Appendix 2
L



Y
The MDL l‘rn;gr.w|nming laugnngr
XORB ("TllI‘LE" WORDS)
IDFCL ((\//UNI‘) L-'OH[]
(WORDS) <TlH"lF [REST (PRIMTYPE \J°RD)]))
compun-s hirwn-c uxclm.n-1: "or" of mncluue words
XUNf\H|' ( )
iDECL ((V/HUI) SIRIHG)
returns Ihc "iuxvmlul nu-r n.1u\c" of MDL3 process
Appendix 2
L
257



‘Z58 The MDL Programming Language
Appendix 3. Predefined Types
On Il|(~\t' tun p;\tj(‘\ is .1 tahlr showing rach of MDL's prcdcfined TYPEs. its primitive type if
duffmmit. .1n-l\:uinn\ [Imp-: S Fnr SlRUC‘|URE.D. E for EVALTYPE not QUOTE, and A for APPLICABLE.
X l\\(‘.1n\ tlml an nhn-it of llml TYPL cannot be CHTYPEd to and hence cannot be READ in (if
attcnqHvd,n CAH'|>fHIYVI-lNlOrrnwislnuah
B n\oan~ that an t>|1_|rrI nf that TYPL cannot hr RFAD in (if attempted. a STORAGE-TYPES-DXFFER
rrrnr n n~n,|l|. that |n\lr.\t| it it» built by thc intcrprcu.-r or CHTYPEd to by a program. and that its
PRIHIMI it-pit-~vn1.1||n|| |nnLr'~ il lnnk as tlinngln its TYPEPRIH were difftruit.
‘A nwans that .\n nl|_|cc1 nf that TYPF is PR1NTcd using ‘L notation and can be READ in only that way.
TYPE
ACTIVATION
ASOC
ATOM
BITS
UY1hS
CHANNEL
CHARACTLR
CLOSURF
CODE
DECL
DISNISS
ENVIRONHI HI
FALSE
FIX
FLOAT
FORM
FR/\Nl
1' SUUR
FUNCTXON
H/'\Nl)l I R
IHEADLR
ILLEGAL
INT[RNAl
LINK
LIST
LOCA
YYITVRIH
IR/\Hi
UOHH
V! (IOR
WORD
l [Si
IIVI ClOR
LIST
ATGH
IRNH
l lhl
MIORI)
\JO1![)
l l$‘|
NOIPTI
I [Si
Ul CIOH
VELIOR
WORD
I|ilfF‘.HI\l -TYPE
AYOH
EA
A
A
D3’
X
B
X
B
XW
XXXXX
B
€0lllIII€ll\$
sic: only one S
can be return:-d by interrupt handler
"|ntcrrnpt header"
(-arbage collector may put this on non-LEGAL? object.
slmnld not be seen by programs
forlernlhialshorﬂiand
locative to TUPLE
Appendix 3
L
 



<y
The M DI. Prngrainniing Langnagt‘
LOCAS
LOCB
LOCO
LOCL
LOCR
LOCS
LOCT
LOCU
LOCV
LOSE
MACRO
OBLIST
OFFSET
PCODE
PRIHTYPE —C
PROCESS
QUICK—fNlRY
OUICK—HSUBR
READA
RSUBR
RSUHR-I-N [RY
SEGHFH1
SPLICF
STORAGC
STRING
SUBR
TAG
TEHPlA1E
TIME
TUPLC
TYPE—C
TYPE—V
UHBOUHU
UVECTOR
VECTOR
WORD
_i>_
UORU
[I51
UVECTOR
OFFSET
WORD
HORN
VECTOR
VLC\OR
FRAME
VFC1OR
VPCIOR
LIST
LIST
HORD
VECTOR
WORD
WORD
HORU
UORU
S
S
S
S
I/‘U7!/lU\Z/\U\
H
S
S
S
M M
rnm
A
A
D
A
A
A
3'
WUQWUNDNWW
X
Z
Z
X W S
'/./B
X
'/./8
I
Q x X
X N 8 W
259
lncalive to ASOC
locaxive to BYTES
Iocalive In G/LVAL
locavive to LIST
ll'ICiIi\'? to GVAL in pure program
localivc to STRING
lncalivc to TEHPLRTE
Iocalive lo UVECTDR
localive [0 VECTOR
a placc holder
"pnrc code"
"prinnypc code"
an RSUBR-ENTRY Ihal has been QCALLI.-d and RSUBR—
LINKed
an RSUBR (ha! has been OCALLcd and RSUBR-LXNKed
in cof slot during rtcursivt READ via READ-TABLE
if codc vcclor is purelimpure. respectively
for returning many "liIlg$ via READ-TABLE
If possible. use FREEZE SUBR instead.
for non-local G05
Tlic inxcrprcxcr ilsclf can‘! build one. See Lebling (1979).
\|s£‘d inlernally to identify FRI\HEs
vector on the control slack
"type code"
":ypr: word"
value of unassigned but bound ATOM. as seen by localives
"uniform vector“
Appendix 3



260
The MDL Programming Language
Appendix 4. Error Messages
Thi-. is ,1 liu of .1II crrrvr»n.-uuing ATOHs initially in lhc ERRORS OBLIST. in the left-hand column.
and apprn|»r|.-nv (‘\.1ll\p|(‘\ or l’iH(‘itl;\liOlI$. whrrc necessary, in the right-hand column.
l\CC[SS—I1\1IllRI
ALRTAIPY-IIII'lIJI I1~IRRFT—NON—l'ALSE- IO—REDEFINE
APPI Y-OR—$TI\('rlI Ol‘H—(7I —I'SUIlR
I\RG~\-lROHI.- IYl"f
I\RGI|P1lH'l~QUl-UT >1’-‘hllﬁl:
/\IO|‘1-I\IRI/'\I1\'-ll|IRf
/\TOH—IIOI—IY|‘I ~IJ»'\I~1I-OI!-SPFCI/\l_—SYNI3OL
/\IOM—(7N—|IlllIRI Hl—Ol\l II‘-l
l\TT[.‘1Pl-IO-IXIII AI;-O\-lH—SIOl|ENC[
AT'lFl"|l"T- I0-t’|lf\-‘IL.I -HAHIILST-VARIABLE
AT‘IIfMI‘I—l(\~CIﬂSI'~ITY»CI|I\|INE'L
AT lkMV'l- IO—1|I I I R-IIIJIII I I IU\Ill Ir -INTERRUPI
ATIEI-1l"l - IO-(J-‘O1-I»\/I f iOR— TOO-MUCH
Al ILHI‘ I - (O-IlllHf§—f\IOllf~.—l'lJi\M[
ACCESS, RESTORE (Tenex and Tops-20
versions only)
First argument to APPLY. STACKFORPL
MAPF/R doesn't EVAL all its arguments.
(ASCII 999>5 Second argument to NTH
or REST too big or small.
<INS[RI "I" (ROOT>>$ (LINK ‘T 'T'
<ROOT)>$
OECL problem
INSERT, LINK. REMOVE
<BRE!\K—SEO T (l1E))S
<CLOSE .INCHl\N>$
"U|\dcl’crabl:" interrupt (mg. "ERROR')
while INT-LEVEL is too high to handle it
GROH argument greater than <' 16 1024)
<PUT (SFNAHE T) I !\T>S
I
ATTEMPI — IO—I-IIIJII,-PIIRI -SIRIICIURE
/\TTEI'1l'I-IO-Sll1(.1[1E -10-SELF
BI‘\D-l\RGI|I‘lfNI—LIbI
Bl\D—1\SCll-CIIMI/\CIFR
alu.-mp! to write into pure page
(SUICIDE <HE))$
<GOECL (‘HI’) STRING)$
A character with wrong byte size or
ASCII code more than I77 octal has been
read (how?)
BI‘\D—SYl{S-IIFCL
Bf\D—ClII\NHl I
BAD—CIr\U5E Argument to COND is non-LIST or empty
LIST.
DECL in bad form
bad use of DEFAULT i|| LIST of OBLI$'|'s
RSUBR-ENTRY does not point to good
RSUBR.
BAD—[)I Cl/\RI\TIOH—LIST
Bf\D—[II I /\II| I-OI‘.l ISI~S|>‘I-Ell ICATION
BAD-EHII/IY—BLCCK
BAD-EIIVI RONHIHT
B/\D—I> l)(Ul'S
8AD—FUH/\RG
BAD-GC-RI"/\D-T ILE
CLOSURE in bad form
Appendix 4
L



T
The MDL Prngrannnnng Language
BAD—INl"UT—8UI'FER
BAD- L INK
BAD-Y1I\CRO-‘IABLIE
BAD-OBLI$T-OR-LI5T-THEREOF
BAD-PARSE -STR ING
BAD-PNAHE
BAD-PRIHTYPFC
BAD-TEHPLAIE-DATA
BAD-TYPE-CODE
BRO-TYPE—NAHE
BAD-TYPE-SPFCIFICATION
BAD~USE-OF-BYTE-STRING
BAD-USE-OT-MACRO
BAD—US€-OT-SOUIGGLY-BRACKETS
BAD-VECIOR
BYTE-SIZE-BAD
CANY—CHTYPE-INTO
CANT-FIND-TEMPLATE
CANT—OPEH-OUTPUT-F ILE
CANT-RE TRY-ENTRY—GONE
CANT—SURST1TUYE-HITH-SIRING-OR-TUPLE-AND—OTNER
CAN\‘T-PARSE
CHANNEL—CLO$ED
CONTROL-G?
COUNT—GREAliR-IHAN-SIRING-SIIE
DANGEROUS-INTERRUPT-NOT-HANOLED
DATA—CANT—G0-1N—UH!FORH-VECTOR
DATA-CAN\‘T-GO-IN-SYORAGE
DECL—ELEHEN1—NOT-FORM-OR-ATOM
DECL-VIOLATION
DEVICE—0R-SNAHE-UIFFERS
ELEMENT-1YPE—NOT—ATOM-FORM-OR-VECTOR
EHPTY-FORM-IH-DECL
EMPTY—OR/PR]H1YPE—FORH
EHPTY-STRING
END-OF-FllF
ERRET—TYPE-NAME-DESIRED
ERROR—IN—COMP1LED-CODE
FILE-NOT-FOUND
FILE—SYSIEH-ERROR
Appendix 4
L
26!
(for 1 CHANNEL)
<GUNASSIGN <CHTYPE ﬁnk ATOﬂ)>
.READ-TABLE Or .PARSE-TABLE is not I
vedon
Alleged look-up list is not of TYPE OBLIST
or LIST. '
non-STRING argument to PARSE
attempt to output ATG1 with missing or
zero-length PNAHE
ATCI1 purports to be a TYPE but isn't.
DECL problem
03$
( )5
Bad argument to RSUBR-ENTRV
'NET' CHANNEL
<CHTYPE 1 SUBR)S
allempl to GC-READ a structure containing
a TEMPLATE whose TYPE does not exist
SAVE
attempt to RETRY I call to nn RSUBR-
ENTRY whose RSUBR cannot be found
(SUBSTITUTE 'T' T>$
<PARSE ")S <PﬂRSE ')'>$
(READ (CLOSE channoI>>S
'~c
<PRINT$TRING " .°UTCHAN l)$
(See section 21.8.15.) (ITS version only)
!['STRING']S ![<FRAHE)]$
FREEZE ISTORAGE
RENAME
DECL problem
(OR) or <l7R1HTYPE> in DECL
GIEADSTRIHG ">3
RESTORE



‘Z62
FIRST-ARG-WRONG-iYPE
FIRST—ELEHENT~OF-VECTOR-NOT-CODE
FIRST-VECTOR-ELEHENT-NOT-REST-OR-A-FIX
FRAME-NO>LONGCR-EXISTS
HANDLER—ALREADY—IN—U$E
HAS-EMPTY-BODY
ILLEGAL
ILLEGAL-ARGUH[NT—DLOCK
ILLEGAL—FR/\HE
ILLEGAL—LOCATIVE
ILLEGl\L~Sl'Gl‘ll'NT
ILLEGAL-TENEX—FlL[—NAHE
INT—DEVICC—WROHG~TYPE—[VALUATION—RESULT
INT[RNAL—BACK-OR-TOP—OF—A-LIST
INTERNAL—INTERRUPT
INTERRUPT-UNAVAIIAQLE~ON—TENEX
ITS—CHANHl|S~FXHAU5T[O
MEANIHGLL5S~PARAHETER—DECLARATION
MESSAGK-T0O—ﬂIG
HUDDLE—VlRSlOHS-DIFFER
NEGATIVE-ARGUHLHT
NIL-LIST—OF—OBLISTS
NO—FIXUP-FILE
NO—ITS-CHANNELS-FREE
NO-HORE—PAGE5
NO—PROCFSS—TO-RESUME
NO~ROOH-AVAXLABIE
NO—SAV~F ILE
NO-STORAGE
HON—G-BIT-CNARACTER-IN-FILE—NAHE
NON-APPLICABLE-REP
NON-APPlICAHlK-IYPE
NON—ATOMlC—ARGUH£NT
NON-ATOMIC-DBLIST-NAME
NON—DSK~DEVlC[
NON-EVALUAiFAHlf—1YPE
NON—EXlSTENT-IAG
NON—STRUCTURED-ARG-TO-INTERNAL—PUT—REST-NTH—TOP-
Appendix 4
The MDL Programming Language
RSUBR in bad form.
IDECL ((X) (LIST [FOO]>)
(unused)
<lFUNCTION ((X)) l>S
attempt lo PRINT a YUPLE that no longer
exists
Third and later arguments to MAPF/R
not SYRUCTUREO .
(Tcnex and Tops-20 versions only)
function for "INT" i||put CHANNEL
returned non-CHARACTER.
in compiled code
(unused)
(Tenex and Tops-20 versions only)
interpreter couldn't open an ITS I/O
channel.
bad object in argument LISY of Function
XPC (ITS version only)
RESTORE (version - release)
(SET OBLIST '()> TS
MDL couldn't find fixup file (section
l9.9).
IPC-ON (ITS version only)
for pure-code mapping
(OR <RESUHER) <RESUHE>>S
MDL couldn't allocate a page to map in
pure code.
MDL couldn't find pure-code file (section
19.9).
No free storage available for GROW.
(VALUE REP) not APPLICABLE
T! -3S
(unused)
(unused)
(unused)
OR-BACK in compiled code
L



‘T
The MD]. l‘rngr.1mmiug Langnagc
HOH—TYl"[-FOR-|'R1MTYPE-ERG
NOT-A-I lY—l\'P( -CIIAHNLL
NOT—l|f\NlIl I D
NOT—lN-I\RG—l KS1
NOT-1l‘vl—M/\l"~l"lll¢'('.l1OH
HOl—IH—l‘ROG
N Ill-l1Y—/'\—fi[ CAT l\/E -Hlllllll R
l‘llH—Rl'$l - l'll‘l ~Olll —Ol'—R/\HGl'.
HULl.-Sllllllf,
HUHﬂLR~OlIl —Ol'—R/\HG[
ON—AH-OBI ISl>f\l_RL'/\fIY
OlIl—Ol'—l'3O\|lJ[lS
OVERPI OW
l"DL—OVl RT l OH-[3\ll'FER-E~_Xll/\USTED
l‘ROC!‘SS—llOl -Rl Mill/'\lll l
PROCI-_$§--HOT -lllll-l1‘\l‘.l l- —OR-RkSUH/'\l§LE
l‘UR[—LO/\D-F/‘tll lllli
REi\Dl_R~SYlllAX—l RROR~l'l'lR[ T-ANYTHI-NG—TO-GO-ON
RSUBR—l'l‘lll{Y-lllil ll’-llil ['1
RSUBR—lN—l1/\D-FORMAT
RSUBR-l I\t'.l-L5»! IXHP5
SFCONO-!\|l[;-‘»~'ROl’lG- l YPE
STORQK-[ —TYl‘[_S-l!1l'F[IR
SYRUC l URi —t“.Olll1'\‘lHS—lllll!llM|'/\BLE -TYVE
SUBSTXTUli_—lYl‘[—FOR-TYPE
TEMPLATE —TYPS'—ll»\|"ll —HOT—OT-TYPE-TEMPLATE
TEMPl_!\'|E—lYi‘L—\!IOL»'\TION
TllIF1D—l\RG-\~'ROHl'.—lYl‘L
TOO-l F-\»l-f\l—1ﬁl|llllllS—Slll"F‘| ll ll
TOO-Mf\NY—/\R(»S- IO-PRlMlYPl.—DECL
TOO—l'lI\HY-f\R[‘-S-lO~bl‘ECll\L-UHSPECIAL-DECL
TOO-NI\NY~/\R(2lllll'lJTS"5Ul"PLIED
TOP—LE_Vi l -l~liftlll
TYPE-f\l_Rk/\UY—LXlSlS
TYPE—NlSll:'\lCH
TYPE-UNl\l T IH(.(|
TYPES—|7]!'l Fil—IN-SlCRi\(;l —OBtlECT
Appendix 4
L
263
<PRIHTYPE nomypn in nsct.
First argument to OFF not 0N<~d.
TUPLE or IYUPLE called outside argument
LIST.
HAPRET, HAPLEAVE, HAPSTOP not within
MAPF/R
<RETURN>$ <I\Gf\IN>$
in compiled cone
in compiled code
zero-length STRING
ZEBBS
<XNSERT l (ROOT>>$
<1 ‘( )>S BLOAT argument too large
</ 1 0>S <" lE30 1E30>S
Stack overflow while trying to expand
stack: use RETRY.
use of another PROCESS3 FRAME, etc.
Pure-code file disappeared.
RSUBR-ENTRY whose RSUBR cannot be
found
KEEP-FIXUPS should have been true when
RSUBR was input.
<CHTYPE 1 LIST>$ <CklUTYPE '![1]
LIST>S
(BC-DUMP (HE> <>>S
(SUBSTITUTE SUBR FSUBR>$
attempt to GC—REM) a structure containing
a TEMPLATE whose TYPE is defined but is
not a YEHPLQTE
(PRINTYPE any . . .)
<SPECIAL any . . .>
<ERRET) (FRAME (FRAME <FRAHE>>)S
NEVTYPE
attempt to make z value violate its DECL
XSTORAGE



T
264 The MDL Programming Language
TYF‘FS—[\l|I|R—IH-UNIFORM-VECIOR ‘[1 (>15
UHASSIGNIn—\./i\RIl'\i1LE
Uh’/\1Ii\{l|lI1—I‘1'\I||~Hf\H£ >SFPARATDR "5
UHBOUHH-\l/\R ]f\Rl E
urmmteu ll ENDBLOCK wilh no |na!c.l:iug BLOCK
UVECTOR-I'll!-1Y5‘! -V101 IATXON PUT, SETLOC_ SUBSTRUC in compiled
code
vL'C‘|os<-\ 1 55- |||,-:|,.»: um ms QDECL ((x) <L15T [REST]>)
uR0r4:;_1|1|:| r I 10:4-rlmrmt L <OP£N "HY!-'XLE">$ (Mode missing or
misspell.)
WRONG-HUHl'H"R»()I -/‘\R(>l_|P'1EN'|S
Appendix 4
i



Y
The MDL l'rm__§r.-umning Languagc 255
Appendix 5. Initial Settings
The \'E\Iinll\ s\v|(<‘h(‘\ and useful \';1ri:\h|es in MDL are initially sci up wilh the following values:
<f\CTIV/\lf~C|lARS (SYRIHG <ASCII 7) (ASCII l9> (ASCII l5>>)
;"Tenex and Tops-Z0 versions only‘
<[‘\EC\_-CHECK T)
<llHf\SSIGH <EUNI\SSIGN DE\J>>
<GC-f1OH<)>
(Full lHCl|l\N (SI IG INCH/\N (OPEN "READ" "TTY:">>>
<UHI\S$I(>H Klll‘-l~lXUPS>
(UH/\S5I[;H <CUH!\SSIGH H|‘1l>>
(KIN/'\bSl(‘vH (GUN/\SSIGN HH2>)
<5-l I Olll 151 \'hl,lG OBLISI (<NOBLIST INITIAL l5l> <ROOI))>>
(SKI OIIICHAH <SElG OUICHAN (OPEN "PRINI‘ "TTY:")>)
<O\/ERl'LO\'l Y)
<lINl\$$-lflll R[[ll|'INI')
(l!Slll?II—l.l!JK I)
<SETG <\lHASS1GH SNl‘1> "workmg-d:recfory">
<5-l"[_CIl\L-CIIECK ())
(SF'l'CTI\l -HODI l|H$P[CIAL>
<5[I lHlS—PROCESS (SEIG lllIS—PROCESS (MAIN>>>
(ON "C|li\R" .OUIIICR 8 O ,INCH/\N>
<ON "II‘C" ,IPC-HANDLER l> ;"ITS version only‘
Appendix 5
.4;



T
‘Z66 The MDL Programming Language
References
H1-“Ill. ('.\|l. _|’|.l||Il('lI_ L'§>l.1ng||:|§L1'r_>[ ,\L1||iQ|_|l.1Ii[_|q Mqglcls and Proving Theorems in R b
_ __ __ a 0 ol.
Pvm l|||r"|||.11|I\n.1|_|rn||t(Ir1||lt‘r(‘|lCO on Arrifncnal Intelligence. Ma)/1969.
I Lvblinzj. I’ I).1\ul 'I;I|e \TVD| _VI’_|Qg[nl[Q1Vi>|V|g Ern-irg||me||l. Llboralury for Computer Sciencc.
.\i.l.‘l'.. l!I7.'I.
Moon, f)a\i<l .¢\. \1\(TI__l_S_LRc_|'c|cm-r .\i.1nu.1l. Laboratory for Cumpulcr Scirntc, M.l.T.. April
I974.
References



‘V’
The MDL Programming Language 2‘-I
Topic Index
Parenthesiled words refer to other items in thil index.
arguments
arithmetic
array
assignment
binding
bits
block
boolean
bugs
call
change
character
circular
comma
comnlents
coinparison
conditional
S
‘OPTIONAU "l’UPLE' "ARGS' (parameter)
4 — " I ABS EXP LOG SIN COS ATAN HIN HAX RANDG1 0? 17 I=? L? G7 L17
G=‘! N==?
VECTOR UVECTOR TUPLE STRING BYTES TEHPLATE
SET SEIG DEFINE DEFHAC ENVIRONMENT (value parameter binding)
BOUND? GBOUND? ASSIGNED? GASSIGNED? LEGAL? (assignment value parameter)
WORD BITS PUTBITS GETBITS BYTES RNDB ORB XORB EQVB LSH ROI
BIND FROG REPERT BLOCK ENDBLOCK OBLIST HOBLIST OBLIST? !-
FALSE COND AND AND? OR OR? NOT (comparison)
(errors)
FORM APPLY APPLICABLE? EVAL SEGHENT
PUT-DCCL PUTPRQP SET SETG (side Qffttl)
CHARACTER STRING ASCII PRINC READCHR NEXTCHR FLATSIZE LISTEN PARSE
LPARSE UNPARSE
PUIRESI PUT LENGTH? FLATSIZE
GVAL SETS
; FUNCTION ASSOCIATION
==7 N==? =? N=7 G? L=? L7 G=? O? I7 MAX HIN STRCOHP FLATSIZE LENGTH?
(bonlean)
COND AND OR (boolean)
Topic Index



‘E68
concatcnar ion
coroinine
data type
decimal
do
dump
errors
escape
execute
exit
file system
golo
graphics
identifier
if
indexing
input
inlcger
interrupts
itcrat ion
leave
The MDL Programming Language
SEGMENT STRING CONS
PROCESS STATE RESUME SUICIDE RESUHER HE HAIN BREAK-SEQ KSTEP FREE-RUN
TYPE TYPE? PRIHTYPE TYPEPRIH CHTYPE UTYPE CHUTYPE NEVTYPE PRINTTYPE
APPLYTYVE EVALTYPE ALLTYPES VRLID-TYPE?
(loops execute call)
SAVE (output)
FRAME ARGS FUNCT ERROR ERRORS ERRET RETRY UNUIND
\ “G ‘S “O
EVAL APPLY QUOTE FSUBR "ARGS' (cam
RETURN ACTIVATION (gem)
FILECOPY FlLE—LENGiH RENAME OPEN OPEN-NR CHANNEL FILE—EXISTS7 NH] NHZ
DEV SNH SNAHE
GO TM; UHUIND PROG REPEAT AGAIN RETURN ACTIVATION "ACT' (loops)
STORAGE IMAGE
ATOH PNAHE SPNIKHE LINK LOOKUP INSERT REHOVE OBLISY SPECIAL (plflmtltf
value)
(condilinnal)
NTH OFFSET GET PUT BACK TOP (loops)
READ READCHR NEXTCNR READB READSTRING READ-TABLE BC-READ ECHOPAIR
OPEN ACCESS LOAD FLOAO RESTORE RESEY
FIX (arillunelic)
EVENT HANDLER ON OFF ENABLE DISABLE INY-LEVEL DISHISS INTERRUPT
(loops)
(quit)
Topic Index



Y
The MDL Programming Language 269
laadiug FLO/\D SAVE RESTORE LORD
location (pnimcr)
loops REPEAT PROG RETURN GO ACTIVATION AGAIN HAPF HAPR [LIST IVECTOR
IUVECTOR ISTRING IBYTES IFORH
lnacro 74 34% LINK READ—TABLE PARSE-TABLE DEFHAC EXPAND MACRO
monilor ‘READ’ ‘WRITE’
mulli-processing (vnrouline)
octal "
output PRINT PRINT PRINC PRINTS PRINTSTRING IMAGE SC-DUMP ECHOPAIR FLATSIZE
SAVE TERPRI CRLF OPEN ACCESS RESET BUFOUT NETS
parameter FUNCTION ATOM LVAL SET SPECIAL UNSPECIAL (identifier value)
parenlhcscs LIST
parse PARSE LPARSE PARSE-TABLE UNPARSE
period LVAL SET READ
pointer LOCATTVE AT IN SETLOC LIST
predicllv: (booican)
primitives SUBR FSUBR ROOT GVAL SETG
procedure FUNCTION DEFINE DEFHAC GVAL CLOSURE
quit AG “S "O QUIT VALRET LOGOUT RETURN (loops)
real FLOAT (arillnnelici
recursion (always assumed and built in)
search MEMO MEMBER =7 ==7 (comparison)
sharing SEGMENT GROW SUBSTRUC
side effect PUT PUTREST SETLOC SUBSTRUC (Chang!) I
Topic Index



270
sixbit
sloragv
structure
subroutine
temporary
terminal
text
trailer
true
tty
unbiuding
value
*
The MDL Programming Language
JNAHE XJNAHE SEND SEND-WAIT IPC-ON
GC BLOAT BLOI\T-STAT FREEZE TUPLE 'GC" (structure)
LIST VECTOR UVECTOR STRING BYTES TEHPLATE STRUCTUREO? EMPTY? HONAD?
LENGTH LENGTH? (concatenation)
(procedure primitive)
'AUX" BIND PROS REPEAT
(tty)
(rharacn-r)
!- OBLXST
(boalean)
LISTEN "L “G ‘*9 “D rubout. ECHOPAIR TTYECHO TYI 'BLOCKED' "UNBLOCKED'
ACTIVATE-CIIARS (character)
(binding)
LVAL GVAL VALUE IN SET SETG ENVIRONMENT ASSIGNED? GASSIGNED? BOUND?
GBOUNO? ‘BIND’ ACTIVATION ‘ACT’ (parameter) RETURN (quit loops)
Topic Index



“V
The M DL Prngr:uuu\im__' Language
/\l\ llmk-r_\c0|ml page manllmr rrfrrs I0 2
primary lit'\1.'\'I[IliI\|I2 an nnadnrned pagc
uulubcr rcfr.-rs H’! a -vr0nd:\ry drscripliou.
9»
!$
9-
|_
!-IFALSE ()
.
!<
!>
![
!\
!]
.>“
"ACT"
"ARES"
"AUX"
"BIND"
"BLOCKFD“
"CALL"
~cHAR"
"CLOCK"
"DIVER! -AGC"
"DSK"
"ERROR"
-cxrnn"
"BC,
'ILOPR”
‘INFERIOR“
'INFUT"
"INT"
"xoc"
"xwc"
“ﬂPV“
"nun"
"MUDDLE"
"NAME"
i
I I
N':\n\e Index
"NET'
-ow1~
“O?Ti0NAL'
'PARITY'
“PRINT”
‘PRINTS’
"PRINTO'
"PURE"
an "QUOTE"
[1 “REAU"
Q1 "READB‘
LE! 'REALT'
x13 "nuul-
Q1200 "savz"
(.<_1 200 "sw-
qq “SYSDOUN'
s|_ 'TUPLE'
Qllﬂﬂ “UNBLOCKED'
51 ‘VALUE’
"vR1TE'
21 55 |o0
EL! 4
31$?
33 av s
§j av 103 105
3; so x
IR? L51 xx
3197
!§1 ‘
Lil
I86 195 (
lniloa
!i§ )
51 87
lsn -
|§6
nan
E
lli -
IF?
lsoggg -
nan
E
ans
§i87
0
Name Index
U1
Zgasxsv
‘Q 8| as 137
£§2
U!
£21
LQL
E2
Bl
[Q nos 154 @211
EH
Q2
L52
Eé
U2
!§§
Z2 a7 nos 137
B
El
g12u
245546100
5 |_q9s us Q1 I85 I87
24 LE2
LE2
2451
2455
24 51
gggglslnss
ggnsn
2431
ggxsl
222422
‘Z7!



272
/
13151
07 7|
1?
ISTEP
<
=:?
=1
>
ABS
ACCLSS
ACTIVAIF-CHARS
ACTIVAEIOH
AGAIN
AGC-FLAG
ALLTYPES
AND
AND?
ANOB
ANY
APPLICABLE
APPLICABLF7
APPLY
APPLYYYPE
ARGS
ASCII
ASOC
ASSIGNED’
ASSOCIAYIONS
AI
ATAN
ATOM
AVALUE
BACK
BINARV
BIND
BITS
u
24 40
24
1; 211
P’93
21
1s -
mun ug
ran
\\_4_150 ms ms -20:-
“§?Ql50l75
ngn
m
3370185
Zlwﬂ
an gu
12:
L32
Z1
42 §§
J“
g1g|7a
Fl
|»1 :00 21s
70 70 |75 137
l?3
LLZ
an
-.2-1' 100 Q |a4 217
123
qn 2:5
Uﬁ
my
E
The MDL Prograxm\\i|\g Language
BLOAT
BLOAT-STAY
BLOCK
BLOCKED
BOUND?
BREAK-SEQ
BREAKER
BUFOUT
BYTE-SIZE
BYTES
CALLER
CHANLIST
CHANNEL
CHARACTER
CHTYPE
CHUTYPE
CLOSE
CLOSURE
CODE
COMMENT
COND
CONS
COS
CRLF
DEAD
DECL
DECL—CHECK
DECL?
DEFAULT
DEFINE
OEFHAC
DEHSIG
DEV
DISABLE
DISHISS
ECHOPAIR
EMPTY?
ENABLE
ENDBLOCK
ENTRY-LOC
ENVIRONMENT
EQVB
Name Index
xss Lg
L2§
@145
no
13115 I87
L12
L7_4
101 Q us
§§
5_s §_§ egg 2|:
L§i
L22
65 mi gig nos 104 122
§_~1|oo|s4
<3_§2u
@5216
L92
§§
L§i
L22
Z2
E2
12
@101
@110
Q22:
L21
LEE
Lil
Q |41
LEE
29.5.
M265
L§Z
l7_5 1'/_9 Q
1o| Que
Z1
L§Z
@145
LEE
31 gs-1
E



T
r
~
a The M DI. Prngrnunniug ljnguage
ERRLT
ERROR
ERRORS
EVAL
EVALIYPE
EVENT
EVLIN
CVLOUT
EXP
EXPAND
FALSE
FBIN
FILE-LENQTH
FILE-LXISTS7
FILCCOPY
FIX
FLATSIZE
FLOAD
FLOAT
FORM
FRAME
FREE-RUN
FREEZE
FSAVE
FSUBR
FUNCT
functlon
FUNCTION
Function
G/LVAL
G=?
G?
GASSIGNEU7
GBOUND?
GC
CC-DUMP
GC—HON
GC—READ
GDECL
GET
GET-DECL
GETBITS
In |_.;§_ 175 7.22
1.=<;.|",;1sn -zoo
13 M7 206
33 -as s_s x75 cwc
'15. 6°
l7ﬂl79l8l GROW
;_?_:; curmssxsu
Q73 GVAL
11
I51 HANDLER
HANG
GETL
GETPL
GETPROP
71
:31; IBYTES
um n_g IFORH
mg IHEADER
l(Il ||_1 ILIST
:21 33,-1:1 -3 52135 ILLEGAL
|np_ IMAGE
E vb Lug mo IN
1»-2, ->_.'1 zucmw
INDEX
_ _ ms 2:2 INDICATOR
Q5 INIT
me;-1 ms Q INITIAL
INSERT
um
-_z§ 3| as an so 14 74 75 as so INT-LEVEL
tn; m :47 :50 mrzaum
Q nu INTERNAL-TYPE
21 nnssmupr
.?_s_ mg E sz s-1 nnznaupr-unnn
{L1 IHTERRUPTS
IPC-HANDLER
1 as we-on
7; IPC-ON
Q xsroruusz
v_g us? xsmms
70 13?, ma nan
um _|y_;; ns
101 107 mu
Hr: —'
lOl _|r_»r_ use we nun:
Q1 IUVECTOR
Fri !'!_' IVECTOR
Q 116
I60
;'J
~,u
7 w
§ m
_ W
~1q
Q _
Nanneludcx
273
M
Q
L1}.
@165
gg ns 205
@135
31
gas 4| 117 169 :93 :94 208
na |7__9 no QQ nas
l_9_1
5_5.
E
m @
g 205
E
|o| L01 nae
116 Lg n9
@145
L32
Q
E
15¢ 255
@145
El
259
zsa
L5_* E
LER g
142 Q1
2%
‘E
E
230
51 s4
L22
|7|a|o2|oa||2||:-1114115
use new 184 la-1 I87 xss 1&9
use nae 195 202 202
Q
21
fl



27-I The MDL Programming Language
JNAME
ﬁﬂl
k[EP~l'I)<lJP5 ]_1%_?_ 265
L—INS
L-OUTS
L=7
L7
LQST-OUT
LEGAL’
LCNGTH
LENG1H7
LERR\
LINK
LIST
LISThH
LLOC
LMAP\
LOAD
LOCA
LOCAS
LOCAIIVI
LOCAIIVE7
LOCB
LOCD
LOCL
LOCR
LOCS
LOCT
LOCU
LOCV
LOG
LOGOUT
LOOKUP
LOSE
LPARSE
LPROG\
LSH
LVAL
MACRO
HAIN
HANIFEST
HANIFEST7
llﬁ
I40
.73’,
I-{(2
.~<o:<5!)7 ||6ll8176 QZI4
375
7!
119 |5|
~:
HAPF
HAPLEAVE
HAPR
MAPRET
MAPSTOP
MAX
HE
MEMBER
MEMO
HIN
MOBLIST
MOD
NOMAD?
HUDDLE
1! 57 5 59 GS 72 I86 204 212
¢»';5 — "
IIGIJUIGQIBS
Ilﬁ I75 I93
"_’~
wl I99.
ll?
.'.\.?.
ygj ?|-1
1|;
LIZ
115117193 2|-1
HZ
ms
L11
ll?
l_l_7_
||1_
-u
,.», .
ll?
as \;| r.-1
1._.3x»:."-15.1150
U0 Am
i:_:~.!
N==?
N=?
NBIN
NETQCC
NETS
NETSTATE
NEUTYPE
NEXT
NYXTCHR
NM!
NH2
NOT
NTH
OBLIST
OBLIST?
OFF
OFFSET
OH
OPEN
OPEN-NR
OPT
OPTIONAL
OR
31' 37 HG H9 I6!) I75 I93 ‘I08 OR?
“<1 L"I.'
IZ1 17-; ms
1,31
1_3.>
ORB
OUTCHAN
OVERFLOH
PARSE
Name Index
s_| 92
9.5
Q 92
2:!
22
25
I_7_4_195
E
Z2
2s
liq 1-14
2a
71
E @ E
Q
‘Q
E
Q
I01 Q
Q
g m_s1ss 186193
@
as 9310: I87
@265
Lolzss
7_3
gas
|oo Q9_ m14s|s9194
M!
|7_9
|3_s2|4
Q
ﬁlosm 11311-1 |a4
Q2
LQ
E
Q16
119:1
Q
40 l_0§_ 128 ms
E
§_§_ £143 I53 LE I57



The MDL Progrzmmirng Language 275
PARSE—STRING
PARSE-TABLE
PCODE
PNAHE
PRIMTYPE
PRIMTYPE-C
PRINT
PRINC
PRINT
PRINT8
PRINTSTRING
PRINTTYPE
PROCESS
PROS
156
L-'51
164
22 Q 217
91
‘G_-"
gm 101 112
@9101 11'l
'.>_0 23 -13 12101112141
101 Q
101 ET’:
E
146 @17o10o193 219
s11 13 204
PURE —P/\GE - LOADER 155
PURIFY
PUT
PUT—DECL
PUTBITS
PUTPROP
PUTREST
QUICK—ENTRY
QUICK-RSUBR
QUIT
OUITTER
QUOTE
RANDOM
READ
READ-TABLE
READA
READS
READCHR
READSTRING
REALTIMER
REDEFINE
REMOVE
RENAME
REP
REPEAT
RESET
REST
RESTORE
10$ 131; 104 13
g so as sa Q
gg 1'ss
E31
LE
Q no
164 250
104 259
202
LR]!
Q s2 83
29
20 22 gg 101 122 140 ﬁg
I87
I53
I54
101 E
we !)g_ 101 1051121131117
101 M 112
L32
1_o 20:
1_-1_z_ 1'15
101 1_11
1-10
Wag 205
101 102 Q 112
5-.2 so vs 12s 219
1F8m~
RESUHABLE
RESUME
RESUHER
RETRY
RETURN
RGLOC
ROOT
ROT
RSUBR
RSUBR-ENTRY
RSUBR-LINK
rubout
RUNABLE
RUNINT
RUNNING
RUNTIHER
SAVE
SEGMENT
SEND
SEND-HAXT
SET
SETG
SETLOC
SIN
SLEEP
SHAME
SNH
SORT
SORTX
SPECIAL
SPECIAL-CHECK
SPECIAL-MODE
SPLICE
SPNAME
SORT
SQUOTA
STACKFORH
STATE
STORAGE
STRCOHP
STRING
STRUCTURED
STRUCTURED?
SUBR
Name Index
l7_°
11_o173 172 190
"'_4
{Q1 222
g 93175
E5
@145
Q
1-:7 Q 11;_s19-1
147 Q
le_4 255
Q as 113
H2
E
L72
Q2
10$ @165 zoo
5 72 154
Z22
E
3311751136194
Q s1 1ss 194
11s M119
Q
£1.
M
@103 110 265
s_1 73
62
131151; 193 22:4
Bi
12a m_-1
l5_4
Hi
29.
253
as
L72
&
Z3
gages 100 154 213
W_5
H
gm 147



*1
2
1
276 The MDL Programming Language
Subr‘OuI.\nr\ 1?? I-E
SUBS1I|L|1l, l_‘7'| XJNAHE
SUBSTRUC Iil 56 XORB
SUICIUY IT-I XUNRHE
T 71 [
1/11:. :11; 111.1
rrr11>1,r11r 3; 1{1:?1!1 \
1111-11->1 1?1R1n.>111s11r111-111-1115
1."-1 ma‘ 178 I84 187 1sa 189 1
W1 111111110 227
ruzrnx 71.111111r11 “
11115-vrzomss 12-1111 *1;
TIMF 1"}! “U
ro 1_1_1 *1;
TOP (ilf ')_l5 “L
TOPI 11/1 1 1_>1~'< *0
TODS-20 171.1101’ 1111111211-1 11-111:1 *5
151 1u7 17s 1s4 1&7 133 189
11111 11111 1119 '22? 1
rrvscno 1111111111;
111015 an R0193 21-1 )
TYI 1111 1131371117
rvpc .>r1-1-17-1r141 102 2112121
TYPF-1‘. 17111-
TYPE-H 1_1_.-.
TYPE 1 3-1
TYPEPRIM ->15
1111:1145 -.2111
ullAss1c,11  175
11110011110 “IR 9:10
ul~11-1/11111151 1&1
ull1>x11<sr 11;: 1111
UNSPECIAI Q2 21122::
11111411111 1j.11 -122
UTYPE 11.’?
uvscrorz ;,_1.-,1 5,; 931:5 204 213 211
v/11111-11-1-1.? 11:
vnuzz 1 :>11;>
VALUE :13 1;2_-1_
vscron .11 57 r_ _
~1:
Q1 W
L3
I86 20-1212 216
Name Index
Zﬂ
lﬂ
E
2451
Q g1oo1s-1
2451
ii
1_Z ss 93113
Q9311:
gym
Q9811:-1
Q15!
Q ms @113
245_s
24g
4




